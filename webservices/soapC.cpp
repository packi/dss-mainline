/* soapC.cpp
   Generated by gSOAP 2.7.10 from model_soap.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.10 2008-07-24 09:19:13 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_dss__outParameter:
		return soap_in_dss__outParameter(soap, NULL, NULL, "dss:outParameter");
	case SOAP_TYPE_dss__inParameter:
		return soap_in_dss__inParameter(soap, NULL, NULL, "dss:inParameter");
	case SOAP_TYPE_StringArray:
		return soap_in_StringArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_IntArray:
		return soap_in_IntArray(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		return soap_in_dss__Event_DeleteSchedule(soap, NULL, NULL, "dss:Event-DeleteSchedule");
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		return soap_in_dss__Event_DeleteScheduleResponse(soap, NULL, NULL, "dss:Event-DeleteScheduleResponse");
	case SOAP_TYPE_dss__Event_Schedule:
		return soap_in_dss__Event_Schedule(soap, NULL, NULL, "dss:Event-Schedule");
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		return soap_in_dss__Event_ScheduleResponse(soap, NULL, NULL, "dss:Event-ScheduleResponse");
	case SOAP_TYPE_dss__Event_Unsubscribe:
		return soap_in_dss__Event_Unsubscribe(soap, NULL, NULL, "dss:Event-Unsubscribe");
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		return soap_in_dss__Event_UnsubscribeResponse(soap, NULL, NULL, "dss:Event-UnsubscribeResponse");
	case SOAP_TYPE_dss__Event_Subscribe:
		return soap_in_dss__Event_Subscribe(soap, NULL, NULL, "dss:Event-Subscribe");
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		return soap_in_dss__Event_SubscribeResponse(soap, NULL, NULL, "dss:Event-SubscribeResponse");
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		return soap_in_dss__Event_GetActionParamsTemplate(soap, NULL, NULL, "dss:Event-GetActionParamsTemplate");
	case SOAP_TYPE_dss__Event_GetActionNames:
		return soap_in_dss__Event_GetActionNames(soap, NULL, NULL, "dss:Event-GetActionNames");
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		return soap_in_dss__Event_GetActionNamesResponse(soap, NULL, NULL, "dss:Event-GetActionNamesResponse");
	case SOAP_TYPE_dss__Event_Raise:
		return soap_in_dss__Event_Raise(soap, NULL, NULL, "dss:Event-Raise");
	case SOAP_TYPE_dss__Event_RaiseResponse:
		return soap_in_dss__Event_RaiseResponse(soap, NULL, NULL, "dss:Event-RaiseResponse");
	case SOAP_TYPE_dss__Group_RemoveDevice:
		return soap_in_dss__Group_RemoveDevice(soap, NULL, NULL, "dss:Group-RemoveDevice");
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		return soap_in_dss__Group_RemoveDeviceResponse(soap, NULL, NULL, "dss:Group-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Group_AddDevice:
		return soap_in_dss__Group_AddDevice(soap, NULL, NULL, "dss:Group-AddDevice");
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		return soap_in_dss__Group_AddDeviceResponse(soap, NULL, NULL, "dss:Group-AddDeviceResponse");
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		return soap_in_dss__Group_RemoveUserGroup(soap, NULL, NULL, "dss:Group-RemoveUserGroup");
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		return soap_in_dss__Group_RemoveUserGroupResponse(soap, NULL, NULL, "dss:Group-RemoveUserGroupResponse");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		return soap_in_dss__Apartment_AllocateUserGroup(soap, NULL, NULL, "dss:Apartment-AllocateUserGroup");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		return soap_in_dss__Apartment_AllocateUserGroupResponse(soap, NULL, NULL, "dss:Apartment-AllocateUserGroupResponse");
	case SOAP_TYPE_dss__Room_SetName:
		return soap_in_dss__Room_SetName(soap, NULL, NULL, "dss:Room-SetName");
	case SOAP_TYPE_dss__Room_SetNameResponse:
		return soap_in_dss__Room_SetNameResponse(soap, NULL, NULL, "dss:Room-SetNameResponse");
	case SOAP_TYPE_dss__Room_RemoveDevice:
		return soap_in_dss__Room_RemoveDevice(soap, NULL, NULL, "dss:Room-RemoveDevice");
	case SOAP_TYPE_dss__Room_RemoveDeviceResponse:
		return soap_in_dss__Room_RemoveDeviceResponse(soap, NULL, NULL, "dss:Room-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Room_AddDevice:
		return soap_in_dss__Room_AddDevice(soap, NULL, NULL, "dss:Room-AddDevice");
	case SOAP_TYPE_dss__Room_AddDeviceResponse:
		return soap_in_dss__Room_AddDeviceResponse(soap, NULL, NULL, "dss:Room-AddDeviceResponse");
	case SOAP_TYPE_dss__Apartment_DeleteRoom:
		return soap_in_dss__Apartment_DeleteRoom(soap, NULL, NULL, "dss:Apartment-DeleteRoom");
	case SOAP_TYPE_dss__Apartment_DeleteRoomResponse:
		return soap_in_dss__Apartment_DeleteRoomResponse(soap, NULL, NULL, "dss:Apartment-DeleteRoomResponse");
	case SOAP_TYPE_dss__Apartment_AllocateRoom:
		return soap_in_dss__Apartment_AllocateRoom(soap, NULL, NULL, "dss:Apartment-AllocateRoom");
	case SOAP_TYPE_dss__Apartment_AllocateRoomResponse:
		return soap_in_dss__Apartment_AllocateRoomResponse(soap, NULL, NULL, "dss:Apartment-AllocateRoomResponse");
	case SOAP_TYPE_dss__Modulator_GetName:
		return soap_in_dss__Modulator_GetName(soap, NULL, NULL, "dss:Modulator-GetName");
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		return soap_in_dss__Modulator_GetNameResponse(soap, NULL, NULL, "dss:Modulator-GetNameResponse");
	case SOAP_TYPE_dss__Modulator_GetDSID:
		return soap_in_dss__Modulator_GetDSID(soap, NULL, NULL, "dss:Modulator-GetDSID");
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		return soap_in_dss__Modulator_GetDSIDResponse(soap, NULL, NULL, "dss:Modulator-GetDSIDResponse");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		return soap_in_dss__Apartment_GetModulatorIDs(soap, NULL, NULL, "dss:Apartment-GetModulatorIDs");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		return soap_in_dss__Apartment_GetModulatorIDsResponse(soap, NULL, NULL, "dss:Apartment-GetModulatorIDsResponse");
	case SOAP_TYPE_dss__Device_GetDSID:
		return soap_in_dss__Device_GetDSID(soap, NULL, NULL, "dss:Device-GetDSID");
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		return soap_in_dss__Device_GetDSIDResponse(soap, NULL, NULL, "dss:Device-GetDSIDResponse");
	case SOAP_TYPE_dss__Device_GetValue:
		return soap_in_dss__Device_GetValue(soap, NULL, NULL, "dss:Device-GetValue");
	case SOAP_TYPE_dss__Device_GetValueResponse:
		return soap_in_dss__Device_GetValueResponse(soap, NULL, NULL, "dss:Device-GetValueResponse");
	case SOAP_TYPE_dss__Device_SetValue:
		return soap_in_dss__Device_SetValue(soap, NULL, NULL, "dss:Device-SetValue");
	case SOAP_TYPE_dss__Device_SetValueResponse:
		return soap_in_dss__Device_SetValueResponse(soap, NULL, NULL, "dss:Device-SetValueResponse");
	case SOAP_TYPE_dss__Device_EndDim:
		return soap_in_dss__Device_EndDim(soap, NULL, NULL, "dss:Device-EndDim");
	case SOAP_TYPE_dss__Device_EndDimResponse:
		return soap_in_dss__Device_EndDimResponse(soap, NULL, NULL, "dss:Device-EndDimResponse");
	case SOAP_TYPE_dss__Device_StartDim:
		return soap_in_dss__Device_StartDim(soap, NULL, NULL, "dss:Device-StartDim");
	case SOAP_TYPE_dss__Device_StartDimResponse:
		return soap_in_dss__Device_StartDimResponse(soap, NULL, NULL, "dss:Device-StartDimResponse");
	case SOAP_TYPE_dss__Device_Disable:
		return soap_in_dss__Device_Disable(soap, NULL, NULL, "dss:Device-Disable");
	case SOAP_TYPE_dss__Device_DisableResponse:
		return soap_in_dss__Device_DisableResponse(soap, NULL, NULL, "dss:Device-DisableResponse");
	case SOAP_TYPE_dss__Device_Enable:
		return soap_in_dss__Device_Enable(soap, NULL, NULL, "dss:Device-Enable");
	case SOAP_TYPE_dss__Device_EnableResponse:
		return soap_in_dss__Device_EnableResponse(soap, NULL, NULL, "dss:Device-EnableResponse");
	case SOAP_TYPE_dss__Device_DecreaseValue:
		return soap_in_dss__Device_DecreaseValue(soap, NULL, NULL, "dss:Device-DecreaseValue");
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		return soap_in_dss__Device_DecreaseValueResponse(soap, NULL, NULL, "dss:Device-DecreaseValueResponse");
	case SOAP_TYPE_dss__Device_IncreaseValue:
		return soap_in_dss__Device_IncreaseValue(soap, NULL, NULL, "dss:Device-IncreaseValue");
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		return soap_in_dss__Device_IncreaseValueResponse(soap, NULL, NULL, "dss:Device-IncreaseValueResponse");
	case SOAP_TYPE_dss__Device_TurnOff:
		return soap_in_dss__Device_TurnOff(soap, NULL, NULL, "dss:Device-TurnOff");
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		return soap_in_dss__Device_TurnOffResponse(soap, NULL, NULL, "dss:Device-TurnOffResponse");
	case SOAP_TYPE_dss__Device_TurnOn:
		return soap_in_dss__Device_TurnOn(soap, NULL, NULL, "dss:Device-TurnOn");
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		return soap_in_dss__Device_TurnOnResponse(soap, NULL, NULL, "dss:Device-TurnOnResponse");
	case SOAP_TYPE_dss__Set_SetValue:
		return soap_in_dss__Set_SetValue(soap, NULL, NULL, "dss:Set-SetValue");
	case SOAP_TYPE_dss__Set_SetValueResponse:
		return soap_in_dss__Set_SetValueResponse(soap, NULL, NULL, "dss:Set-SetValueResponse");
	case SOAP_TYPE_dss__Set_EndDim:
		return soap_in_dss__Set_EndDim(soap, NULL, NULL, "dss:Set-EndDim");
	case SOAP_TYPE_dss__Set_EndDimResponse:
		return soap_in_dss__Set_EndDimResponse(soap, NULL, NULL, "dss:Set-EndDimResponse");
	case SOAP_TYPE_dss__Set_StartDim:
		return soap_in_dss__Set_StartDim(soap, NULL, NULL, "dss:Set-StartDim");
	case SOAP_TYPE_dss__Set_StartDimResponse:
		return soap_in_dss__Set_StartDimResponse(soap, NULL, NULL, "dss:Set-StartDimResponse");
	case SOAP_TYPE_dss__Set_Disable:
		return soap_in_dss__Set_Disable(soap, NULL, NULL, "dss:Set-Disable");
	case SOAP_TYPE_dss__Set_DisableResponse:
		return soap_in_dss__Set_DisableResponse(soap, NULL, NULL, "dss:Set-DisableResponse");
	case SOAP_TYPE_dss__Set_Enable:
		return soap_in_dss__Set_Enable(soap, NULL, NULL, "dss:Set-Enable");
	case SOAP_TYPE_dss__Set_EnableResponse:
		return soap_in_dss__Set_EnableResponse(soap, NULL, NULL, "dss:Set-EnableResponse");
	case SOAP_TYPE_dss__Set_DecreaseValue:
		return soap_in_dss__Set_DecreaseValue(soap, NULL, NULL, "dss:Set-DecreaseValue");
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		return soap_in_dss__Set_DecreaseValueResponse(soap, NULL, NULL, "dss:Set-DecreaseValueResponse");
	case SOAP_TYPE_dss__Set_IncreaseValue:
		return soap_in_dss__Set_IncreaseValue(soap, NULL, NULL, "dss:Set-IncreaseValue");
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		return soap_in_dss__Set_IncreaseValueResponse(soap, NULL, NULL, "dss:Set-IncreaseValueResponse");
	case SOAP_TYPE_dss__Set_TurnOff:
		return soap_in_dss__Set_TurnOff(soap, NULL, NULL, "dss:Set-TurnOff");
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		return soap_in_dss__Set_TurnOffResponse(soap, NULL, NULL, "dss:Set-TurnOffResponse");
	case SOAP_TYPE_dss__Set_TurnOn:
		return soap_in_dss__Set_TurnOn(soap, NULL, NULL, "dss:Set-TurnOn");
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		return soap_in_dss__Set_TurnOnResponse(soap, NULL, NULL, "dss:Set-TurnOnResponse");
	case SOAP_TYPE_dss__Apartment_GetRoomIDs:
		return soap_in_dss__Apartment_GetRoomIDs(soap, NULL, NULL, "dss:Apartment-GetRoomIDs");
	case SOAP_TYPE_dss__Apartment_GetRoomIDsResponse:
		return soap_in_dss__Apartment_GetRoomIDsResponse(soap, NULL, NULL, "dss:Apartment-GetRoomIDsResponse");
	case SOAP_TYPE_dss__Apartment_GetRoomByName:
		return soap_in_dss__Apartment_GetRoomByName(soap, NULL, NULL, "dss:Apartment-GetRoomByName");
	case SOAP_TYPE_dss__Apartment_GetRoomByNameResponse:
		return soap_in_dss__Apartment_GetRoomByNameResponse(soap, NULL, NULL, "dss:Apartment-GetRoomByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		return soap_in_dss__Apartment_GetGroupByName(soap, NULL, NULL, "dss:Apartment-GetGroupByName");
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		return soap_in_dss__Apartment_GetGroupByNameResponse(soap, NULL, NULL, "dss:Apartment-GetGroupByNameResponse");
	case SOAP_TYPE_dss__Set_ByGroup:
		return soap_in_dss__Set_ByGroup(soap, NULL, NULL, "dss:Set-ByGroup");
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		return soap_in_dss__Set_ByGroupResponse(soap, NULL, NULL, "dss:Set-ByGroupResponse");
	case SOAP_TYPE_dss__Set_Remove:
		return soap_in_dss__Set_Remove(soap, NULL, NULL, "dss:Set-Remove");
	case SOAP_TYPE_dss__Set_RemoveResponse:
		return soap_in_dss__Set_RemoveResponse(soap, NULL, NULL, "dss:Set-RemoveResponse");
	case SOAP_TYPE_dss__Set_Combine:
		return soap_in_dss__Set_Combine(soap, NULL, NULL, "dss:Set-Combine");
	case SOAP_TYPE_dss__Set_CombineResponse:
		return soap_in_dss__Set_CombineResponse(soap, NULL, NULL, "dss:Set-CombineResponse");
	case SOAP_TYPE_dss__Set_RemoveDevice:
		return soap_in_dss__Set_RemoveDevice(soap, NULL, NULL, "dss:Set-RemoveDevice");
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		return soap_in_dss__Set_RemoveDeviceResponse(soap, NULL, NULL, "dss:Set-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		return soap_in_dss__Set_AddDeviceByID(soap, NULL, NULL, "dss:Set-AddDeviceByID");
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		return soap_in_dss__Set_AddDeviceByIDResponse(soap, NULL, NULL, "dss:Set-AddDeviceByIDResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		return soap_in_dss__Set_AddDeviceByName(soap, NULL, NULL, "dss:Set-AddDeviceByName");
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		return soap_in_dss__Set_AddDeviceByNameResponse(soap, NULL, NULL, "dss:Set-AddDeviceByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		return soap_in_dss__Apartment_GetDeviceIDByName(soap, NULL, NULL, "dss:Apartment-GetDeviceIDByName");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		return soap_in_dss__Apartment_GetDeviceIDByNameResponse(soap, NULL, NULL, "dss:Apartment-GetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDevices:
		return soap_in_dss__Apartment_GetDevices(soap, NULL, NULL, "dss:Apartment-GetDevices");
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		return soap_in_dss__Apartment_GetDevicesResponse(soap, NULL, NULL, "dss:Apartment-GetDevicesResponse");
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		return soap_in_dss__Apartment_CreateEmptySet(soap, NULL, NULL, "dss:Apartment-CreateEmptySet");
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		return soap_in_dss__Apartment_CreateEmptySetResponse(soap, NULL, NULL, "dss:Apartment-CreateEmptySetResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		return soap_in_dss__Apartment_CreateSetFromDeviceNames(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceNames");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		return soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		return soap_in_dss__Apartment_CreateSetFromDeviceIDs(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		return soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		return soap_in_dss__Apartment_CreateSetFromGroup(soap, NULL, NULL, "dss:Apartment-CreateSetFromGroup");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		return soap_in_dss__Apartment_CreateSetFromGroupResponse(soap, NULL, NULL, "dss:Apartment-CreateSetFromGroupResponse");
	case SOAP_TYPE_dss__FreeSet:
		return soap_in_dss__FreeSet(soap, NULL, NULL, "dss:FreeSet");
	case SOAP_TYPE_dss__FreeSetResponse:
		return soap_in_dss__FreeSetResponse(soap, NULL, NULL, "dss:FreeSetResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_in_dss__SignOff(soap, NULL, NULL, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_in_dss__SignOffResponse(soap, NULL, NULL, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_in_dss__Authenticate(soap, NULL, NULL, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, "dss:AuthenticateResponse");
	case SOAP_TYPE_PointerToStringArray:
		return soap_in_PointerToStringArray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "dss:outParameter"))
		{	*type = SOAP_TYPE_dss__outParameter;
			return soap_in_dss__outParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:inParameter"))
		{	*type = SOAP_TYPE_dss__inParameter;
			return soap_in_dss__inParameter(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_StringArray;
			return soap_in_StringArray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:int"))
		{	*type = SOAP_TYPE_IntArray;
			return soap_in_IntArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-DeleteSchedule"))
		{	*type = SOAP_TYPE_dss__Event_DeleteSchedule;
			return soap_in_dss__Event_DeleteSchedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-DeleteScheduleResponse"))
		{	*type = SOAP_TYPE_dss__Event_DeleteScheduleResponse;
			return soap_in_dss__Event_DeleteScheduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Schedule"))
		{	*type = SOAP_TYPE_dss__Event_Schedule;
			return soap_in_dss__Event_Schedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-ScheduleResponse"))
		{	*type = SOAP_TYPE_dss__Event_ScheduleResponse;
			return soap_in_dss__Event_ScheduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Unsubscribe"))
		{	*type = SOAP_TYPE_dss__Event_Unsubscribe;
			return soap_in_dss__Event_Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-UnsubscribeResponse"))
		{	*type = SOAP_TYPE_dss__Event_UnsubscribeResponse;
			return soap_in_dss__Event_UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Subscribe"))
		{	*type = SOAP_TYPE_dss__Event_Subscribe;
			return soap_in_dss__Event_Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-SubscribeResponse"))
		{	*type = SOAP_TYPE_dss__Event_SubscribeResponse;
			return soap_in_dss__Event_SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-GetActionParamsTemplate"))
		{	*type = SOAP_TYPE_dss__Event_GetActionParamsTemplate;
			return soap_in_dss__Event_GetActionParamsTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-GetActionNames"))
		{	*type = SOAP_TYPE_dss__Event_GetActionNames;
			return soap_in_dss__Event_GetActionNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-GetActionNamesResponse"))
		{	*type = SOAP_TYPE_dss__Event_GetActionNamesResponse;
			return soap_in_dss__Event_GetActionNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Raise"))
		{	*type = SOAP_TYPE_dss__Event_Raise;
			return soap_in_dss__Event_Raise(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-RaiseResponse"))
		{	*type = SOAP_TYPE_dss__Event_RaiseResponse;
			return soap_in_dss__Event_RaiseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveDevice"))
		{	*type = SOAP_TYPE_dss__Group_RemoveDevice;
			return soap_in_dss__Group_RemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Group_RemoveDeviceResponse;
			return soap_in_dss__Group_RemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-AddDevice"))
		{	*type = SOAP_TYPE_dss__Group_AddDevice;
			return soap_in_dss__Group_AddDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-AddDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Group_AddDeviceResponse;
			return soap_in_dss__Group_AddDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveUserGroup"))
		{	*type = SOAP_TYPE_dss__Group_RemoveUserGroup;
			return soap_in_dss__Group_RemoveUserGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveUserGroupResponse"))
		{	*type = SOAP_TYPE_dss__Group_RemoveUserGroupResponse;
			return soap_in_dss__Group_RemoveUserGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateUserGroup"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateUserGroup;
			return soap_in_dss__Apartment_AllocateUserGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateUserGroupResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse;
			return soap_in_dss__Apartment_AllocateUserGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Room-SetName"))
		{	*type = SOAP_TYPE_dss__Room_SetName;
			return soap_in_dss__Room_SetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Room-SetNameResponse"))
		{	*type = SOAP_TYPE_dss__Room_SetNameResponse;
			return soap_in_dss__Room_SetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Room-RemoveDevice"))
		{	*type = SOAP_TYPE_dss__Room_RemoveDevice;
			return soap_in_dss__Room_RemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Room-RemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Room_RemoveDeviceResponse;
			return soap_in_dss__Room_RemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Room-AddDevice"))
		{	*type = SOAP_TYPE_dss__Room_AddDevice;
			return soap_in_dss__Room_AddDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Room-AddDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Room_AddDeviceResponse;
			return soap_in_dss__Room_AddDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-DeleteRoom"))
		{	*type = SOAP_TYPE_dss__Apartment_DeleteRoom;
			return soap_in_dss__Apartment_DeleteRoom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-DeleteRoomResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_DeleteRoomResponse;
			return soap_in_dss__Apartment_DeleteRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateRoom"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateRoom;
			return soap_in_dss__Apartment_AllocateRoom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateRoomResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateRoomResponse;
			return soap_in_dss__Apartment_AllocateRoomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetName"))
		{	*type = SOAP_TYPE_dss__Modulator_GetName;
			return soap_in_dss__Modulator_GetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetNameResponse"))
		{	*type = SOAP_TYPE_dss__Modulator_GetNameResponse;
			return soap_in_dss__Modulator_GetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetDSID"))
		{	*type = SOAP_TYPE_dss__Modulator_GetDSID;
			return soap_in_dss__Modulator_GetDSID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetDSIDResponse"))
		{	*type = SOAP_TYPE_dss__Modulator_GetDSIDResponse;
			return soap_in_dss__Modulator_GetDSIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetModulatorIDs"))
		{	*type = SOAP_TYPE_dss__Apartment_GetModulatorIDs;
			return soap_in_dss__Apartment_GetModulatorIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetModulatorIDsResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse;
			return soap_in_dss__Apartment_GetModulatorIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetDSID"))
		{	*type = SOAP_TYPE_dss__Device_GetDSID;
			return soap_in_dss__Device_GetDSID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetDSIDResponse"))
		{	*type = SOAP_TYPE_dss__Device_GetDSIDResponse;
			return soap_in_dss__Device_GetDSIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetValue"))
		{	*type = SOAP_TYPE_dss__Device_GetValue;
			return soap_in_dss__Device_GetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_GetValueResponse;
			return soap_in_dss__Device_GetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-SetValue"))
		{	*type = SOAP_TYPE_dss__Device_SetValue;
			return soap_in_dss__Device_SetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-SetValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_SetValueResponse;
			return soap_in_dss__Device_SetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-EndDim"))
		{	*type = SOAP_TYPE_dss__Device_EndDim;
			return soap_in_dss__Device_EndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-EndDimResponse"))
		{	*type = SOAP_TYPE_dss__Device_EndDimResponse;
			return soap_in_dss__Device_EndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-StartDim"))
		{	*type = SOAP_TYPE_dss__Device_StartDim;
			return soap_in_dss__Device_StartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-StartDimResponse"))
		{	*type = SOAP_TYPE_dss__Device_StartDimResponse;
			return soap_in_dss__Device_StartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-Disable"))
		{	*type = SOAP_TYPE_dss__Device_Disable;
			return soap_in_dss__Device_Disable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-DisableResponse"))
		{	*type = SOAP_TYPE_dss__Device_DisableResponse;
			return soap_in_dss__Device_DisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-Enable"))
		{	*type = SOAP_TYPE_dss__Device_Enable;
			return soap_in_dss__Device_Enable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-EnableResponse"))
		{	*type = SOAP_TYPE_dss__Device_EnableResponse;
			return soap_in_dss__Device_EnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-DecreaseValue"))
		{	*type = SOAP_TYPE_dss__Device_DecreaseValue;
			return soap_in_dss__Device_DecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-DecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_DecreaseValueResponse;
			return soap_in_dss__Device_DecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-IncreaseValue"))
		{	*type = SOAP_TYPE_dss__Device_IncreaseValue;
			return soap_in_dss__Device_IncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-IncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_IncreaseValueResponse;
			return soap_in_dss__Device_IncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOff"))
		{	*type = SOAP_TYPE_dss__Device_TurnOff;
			return soap_in_dss__Device_TurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOffResponse"))
		{	*type = SOAP_TYPE_dss__Device_TurnOffResponse;
			return soap_in_dss__Device_TurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOn"))
		{	*type = SOAP_TYPE_dss__Device_TurnOn;
			return soap_in_dss__Device_TurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOnResponse"))
		{	*type = SOAP_TYPE_dss__Device_TurnOnResponse;
			return soap_in_dss__Device_TurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-SetValue"))
		{	*type = SOAP_TYPE_dss__Set_SetValue;
			return soap_in_dss__Set_SetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-SetValueResponse"))
		{	*type = SOAP_TYPE_dss__Set_SetValueResponse;
			return soap_in_dss__Set_SetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-EndDim"))
		{	*type = SOAP_TYPE_dss__Set_EndDim;
			return soap_in_dss__Set_EndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-EndDimResponse"))
		{	*type = SOAP_TYPE_dss__Set_EndDimResponse;
			return soap_in_dss__Set_EndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-StartDim"))
		{	*type = SOAP_TYPE_dss__Set_StartDim;
			return soap_in_dss__Set_StartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-StartDimResponse"))
		{	*type = SOAP_TYPE_dss__Set_StartDimResponse;
			return soap_in_dss__Set_StartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Disable"))
		{	*type = SOAP_TYPE_dss__Set_Disable;
			return soap_in_dss__Set_Disable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-DisableResponse"))
		{	*type = SOAP_TYPE_dss__Set_DisableResponse;
			return soap_in_dss__Set_DisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Enable"))
		{	*type = SOAP_TYPE_dss__Set_Enable;
			return soap_in_dss__Set_Enable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-EnableResponse"))
		{	*type = SOAP_TYPE_dss__Set_EnableResponse;
			return soap_in_dss__Set_EnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-DecreaseValue"))
		{	*type = SOAP_TYPE_dss__Set_DecreaseValue;
			return soap_in_dss__Set_DecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-DecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Set_DecreaseValueResponse;
			return soap_in_dss__Set_DecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-IncreaseValue"))
		{	*type = SOAP_TYPE_dss__Set_IncreaseValue;
			return soap_in_dss__Set_IncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-IncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Set_IncreaseValueResponse;
			return soap_in_dss__Set_IncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOff"))
		{	*type = SOAP_TYPE_dss__Set_TurnOff;
			return soap_in_dss__Set_TurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOffResponse"))
		{	*type = SOAP_TYPE_dss__Set_TurnOffResponse;
			return soap_in_dss__Set_TurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOn"))
		{	*type = SOAP_TYPE_dss__Set_TurnOn;
			return soap_in_dss__Set_TurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOnResponse"))
		{	*type = SOAP_TYPE_dss__Set_TurnOnResponse;
			return soap_in_dss__Set_TurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetRoomIDs"))
		{	*type = SOAP_TYPE_dss__Apartment_GetRoomIDs;
			return soap_in_dss__Apartment_GetRoomIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetRoomIDsResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetRoomIDsResponse;
			return soap_in_dss__Apartment_GetRoomIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetRoomByName"))
		{	*type = SOAP_TYPE_dss__Apartment_GetRoomByName;
			return soap_in_dss__Apartment_GetRoomByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetRoomByNameResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetRoomByNameResponse;
			return soap_in_dss__Apartment_GetRoomByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetGroupByName"))
		{	*type = SOAP_TYPE_dss__Apartment_GetGroupByName;
			return soap_in_dss__Apartment_GetGroupByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetGroupByNameResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetGroupByNameResponse;
			return soap_in_dss__Apartment_GetGroupByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-ByGroup"))
		{	*type = SOAP_TYPE_dss__Set_ByGroup;
			return soap_in_dss__Set_ByGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-ByGroupResponse"))
		{	*type = SOAP_TYPE_dss__Set_ByGroupResponse;
			return soap_in_dss__Set_ByGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Remove"))
		{	*type = SOAP_TYPE_dss__Set_Remove;
			return soap_in_dss__Set_Remove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-RemoveResponse"))
		{	*type = SOAP_TYPE_dss__Set_RemoveResponse;
			return soap_in_dss__Set_RemoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Combine"))
		{	*type = SOAP_TYPE_dss__Set_Combine;
			return soap_in_dss__Set_Combine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-CombineResponse"))
		{	*type = SOAP_TYPE_dss__Set_CombineResponse;
			return soap_in_dss__Set_CombineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-RemoveDevice"))
		{	*type = SOAP_TYPE_dss__Set_RemoveDevice;
			return soap_in_dss__Set_RemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-RemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Set_RemoveDeviceResponse;
			return soap_in_dss__Set_RemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByID"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByID;
			return soap_in_dss__Set_AddDeviceByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByIDResponse"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByIDResponse;
			return soap_in_dss__Set_AddDeviceByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByName"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByName;
			return soap_in_dss__Set_AddDeviceByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByNameResponse"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByNameResponse;
			return soap_in_dss__Set_AddDeviceByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDeviceIDByName"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDeviceIDByName;
			return soap_in_dss__Apartment_GetDeviceIDByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDeviceIDByNameResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse;
			return soap_in_dss__Apartment_GetDeviceIDByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDevices"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDevices;
			return soap_in_dss__Apartment_GetDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDevicesResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDevicesResponse;
			return soap_in_dss__Apartment_GetDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateEmptySet"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateEmptySet;
			return soap_in_dss__Apartment_CreateEmptySet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateEmptySetResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateEmptySetResponse;
			return soap_in_dss__Apartment_CreateEmptySetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceNames"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames;
			return soap_in_dss__Apartment_CreateSetFromDeviceNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceNamesResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse;
			return soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceIDs"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs;
			return soap_in_dss__Apartment_CreateSetFromDeviceIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceIDsResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse;
			return soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromGroup"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromGroup;
			return soap_in_dss__Apartment_CreateSetFromGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromGroupResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse;
			return soap_in_dss__Apartment_CreateSetFromGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:FreeSet"))
		{	*type = SOAP_TYPE_dss__FreeSet;
			return soap_in_dss__FreeSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:FreeSetResponse"))
		{	*type = SOAP_TYPE_dss__FreeSetResponse;
			return soap_in_dss__FreeSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOff"))
		{	*type = SOAP_TYPE_dss__SignOff;
			return soap_in_dss__SignOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOffResponse"))
		{	*type = SOAP_TYPE_dss__SignOffResponse;
			return soap_in_dss__SignOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Authenticate"))
		{	*type = SOAP_TYPE_dss__Authenticate;
			return soap_in_dss__Authenticate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:AuthenticateResponse"))
		{	*type = SOAP_TYPE_dss__AuthenticateResponse;
			return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_out_xsd__unsignedInt(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_dss__outParameter:
		return ((dss__outParameter *)ptr)->soap_out(soap, tag, id, "dss:outParameter");
	case SOAP_TYPE_dss__inParameter:
		return ((dss__inParameter *)ptr)->soap_out(soap, tag, id, "dss:inParameter");
	case SOAP_TYPE_StringArray:
		return ((StringArray *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_IntArray:
		return ((IntArray *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		return soap_out_dss__Event_DeleteSchedule(soap, tag, id, (const struct dss__Event_DeleteSchedule *)ptr, "dss:Event-DeleteSchedule");
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		return soap_out_dss__Event_DeleteScheduleResponse(soap, tag, id, (const struct dss__Event_DeleteScheduleResponse *)ptr, "dss:Event-DeleteScheduleResponse");
	case SOAP_TYPE_dss__Event_Schedule:
		return soap_out_dss__Event_Schedule(soap, tag, id, (const struct dss__Event_Schedule *)ptr, "dss:Event-Schedule");
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		return soap_out_dss__Event_ScheduleResponse(soap, tag, id, (const struct dss__Event_ScheduleResponse *)ptr, "dss:Event-ScheduleResponse");
	case SOAP_TYPE_dss__Event_Unsubscribe:
		return soap_out_dss__Event_Unsubscribe(soap, tag, id, (const struct dss__Event_Unsubscribe *)ptr, "dss:Event-Unsubscribe");
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		return soap_out_dss__Event_UnsubscribeResponse(soap, tag, id, (const struct dss__Event_UnsubscribeResponse *)ptr, "dss:Event-UnsubscribeResponse");
	case SOAP_TYPE_dss__Event_Subscribe:
		return soap_out_dss__Event_Subscribe(soap, tag, id, (const struct dss__Event_Subscribe *)ptr, "dss:Event-Subscribe");
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		return soap_out_dss__Event_SubscribeResponse(soap, tag, id, (const struct dss__Event_SubscribeResponse *)ptr, "dss:Event-SubscribeResponse");
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		return soap_out_dss__Event_GetActionParamsTemplate(soap, tag, id, (const struct dss__Event_GetActionParamsTemplate *)ptr, "dss:Event-GetActionParamsTemplate");
	case SOAP_TYPE_dss__Event_GetActionNames:
		return soap_out_dss__Event_GetActionNames(soap, tag, id, (const struct dss__Event_GetActionNames *)ptr, "dss:Event-GetActionNames");
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		return soap_out_dss__Event_GetActionNamesResponse(soap, tag, id, (const struct dss__Event_GetActionNamesResponse *)ptr, "dss:Event-GetActionNamesResponse");
	case SOAP_TYPE_dss__Event_Raise:
		return soap_out_dss__Event_Raise(soap, tag, id, (const struct dss__Event_Raise *)ptr, "dss:Event-Raise");
	case SOAP_TYPE_dss__Event_RaiseResponse:
		return soap_out_dss__Event_RaiseResponse(soap, tag, id, (const struct dss__Event_RaiseResponse *)ptr, "dss:Event-RaiseResponse");
	case SOAP_TYPE_dss__Group_RemoveDevice:
		return soap_out_dss__Group_RemoveDevice(soap, tag, id, (const struct dss__Group_RemoveDevice *)ptr, "dss:Group-RemoveDevice");
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		return soap_out_dss__Group_RemoveDeviceResponse(soap, tag, id, (const struct dss__Group_RemoveDeviceResponse *)ptr, "dss:Group-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Group_AddDevice:
		return soap_out_dss__Group_AddDevice(soap, tag, id, (const struct dss__Group_AddDevice *)ptr, "dss:Group-AddDevice");
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		return soap_out_dss__Group_AddDeviceResponse(soap, tag, id, (const struct dss__Group_AddDeviceResponse *)ptr, "dss:Group-AddDeviceResponse");
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		return soap_out_dss__Group_RemoveUserGroup(soap, tag, id, (const struct dss__Group_RemoveUserGroup *)ptr, "dss:Group-RemoveUserGroup");
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		return soap_out_dss__Group_RemoveUserGroupResponse(soap, tag, id, (const struct dss__Group_RemoveUserGroupResponse *)ptr, "dss:Group-RemoveUserGroupResponse");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		return soap_out_dss__Apartment_AllocateUserGroup(soap, tag, id, (const struct dss__Apartment_AllocateUserGroup *)ptr, "dss:Apartment-AllocateUserGroup");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		return soap_out_dss__Apartment_AllocateUserGroupResponse(soap, tag, id, (const struct dss__Apartment_AllocateUserGroupResponse *)ptr, "dss:Apartment-AllocateUserGroupResponse");
	case SOAP_TYPE_dss__Room_SetName:
		return soap_out_dss__Room_SetName(soap, tag, id, (const struct dss__Room_SetName *)ptr, "dss:Room-SetName");
	case SOAP_TYPE_dss__Room_SetNameResponse:
		return soap_out_dss__Room_SetNameResponse(soap, tag, id, (const struct dss__Room_SetNameResponse *)ptr, "dss:Room-SetNameResponse");
	case SOAP_TYPE_dss__Room_RemoveDevice:
		return soap_out_dss__Room_RemoveDevice(soap, tag, id, (const struct dss__Room_RemoveDevice *)ptr, "dss:Room-RemoveDevice");
	case SOAP_TYPE_dss__Room_RemoveDeviceResponse:
		return soap_out_dss__Room_RemoveDeviceResponse(soap, tag, id, (const struct dss__Room_RemoveDeviceResponse *)ptr, "dss:Room-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Room_AddDevice:
		return soap_out_dss__Room_AddDevice(soap, tag, id, (const struct dss__Room_AddDevice *)ptr, "dss:Room-AddDevice");
	case SOAP_TYPE_dss__Room_AddDeviceResponse:
		return soap_out_dss__Room_AddDeviceResponse(soap, tag, id, (const struct dss__Room_AddDeviceResponse *)ptr, "dss:Room-AddDeviceResponse");
	case SOAP_TYPE_dss__Apartment_DeleteRoom:
		return soap_out_dss__Apartment_DeleteRoom(soap, tag, id, (const struct dss__Apartment_DeleteRoom *)ptr, "dss:Apartment-DeleteRoom");
	case SOAP_TYPE_dss__Apartment_DeleteRoomResponse:
		return soap_out_dss__Apartment_DeleteRoomResponse(soap, tag, id, (const struct dss__Apartment_DeleteRoomResponse *)ptr, "dss:Apartment-DeleteRoomResponse");
	case SOAP_TYPE_dss__Apartment_AllocateRoom:
		return soap_out_dss__Apartment_AllocateRoom(soap, tag, id, (const struct dss__Apartment_AllocateRoom *)ptr, "dss:Apartment-AllocateRoom");
	case SOAP_TYPE_dss__Apartment_AllocateRoomResponse:
		return soap_out_dss__Apartment_AllocateRoomResponse(soap, tag, id, (const struct dss__Apartment_AllocateRoomResponse *)ptr, "dss:Apartment-AllocateRoomResponse");
	case SOAP_TYPE_dss__Modulator_GetName:
		return soap_out_dss__Modulator_GetName(soap, tag, id, (const struct dss__Modulator_GetName *)ptr, "dss:Modulator-GetName");
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		return soap_out_dss__Modulator_GetNameResponse(soap, tag, id, (const struct dss__Modulator_GetNameResponse *)ptr, "dss:Modulator-GetNameResponse");
	case SOAP_TYPE_dss__Modulator_GetDSID:
		return soap_out_dss__Modulator_GetDSID(soap, tag, id, (const struct dss__Modulator_GetDSID *)ptr, "dss:Modulator-GetDSID");
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		return soap_out_dss__Modulator_GetDSIDResponse(soap, tag, id, (const struct dss__Modulator_GetDSIDResponse *)ptr, "dss:Modulator-GetDSIDResponse");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		return soap_out_dss__Apartment_GetModulatorIDs(soap, tag, id, (const struct dss__Apartment_GetModulatorIDs *)ptr, "dss:Apartment-GetModulatorIDs");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		return soap_out_dss__Apartment_GetModulatorIDsResponse(soap, tag, id, (const struct dss__Apartment_GetModulatorIDsResponse *)ptr, "dss:Apartment-GetModulatorIDsResponse");
	case SOAP_TYPE_dss__Device_GetDSID:
		return soap_out_dss__Device_GetDSID(soap, tag, id, (const struct dss__Device_GetDSID *)ptr, "dss:Device-GetDSID");
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		return soap_out_dss__Device_GetDSIDResponse(soap, tag, id, (const struct dss__Device_GetDSIDResponse *)ptr, "dss:Device-GetDSIDResponse");
	case SOAP_TYPE_dss__Device_GetValue:
		return soap_out_dss__Device_GetValue(soap, tag, id, (const struct dss__Device_GetValue *)ptr, "dss:Device-GetValue");
	case SOAP_TYPE_dss__Device_GetValueResponse:
		return soap_out_dss__Device_GetValueResponse(soap, tag, id, (const struct dss__Device_GetValueResponse *)ptr, "dss:Device-GetValueResponse");
	case SOAP_TYPE_dss__Device_SetValue:
		return soap_out_dss__Device_SetValue(soap, tag, id, (const struct dss__Device_SetValue *)ptr, "dss:Device-SetValue");
	case SOAP_TYPE_dss__Device_SetValueResponse:
		return soap_out_dss__Device_SetValueResponse(soap, tag, id, (const struct dss__Device_SetValueResponse *)ptr, "dss:Device-SetValueResponse");
	case SOAP_TYPE_dss__Device_EndDim:
		return soap_out_dss__Device_EndDim(soap, tag, id, (const struct dss__Device_EndDim *)ptr, "dss:Device-EndDim");
	case SOAP_TYPE_dss__Device_EndDimResponse:
		return soap_out_dss__Device_EndDimResponse(soap, tag, id, (const struct dss__Device_EndDimResponse *)ptr, "dss:Device-EndDimResponse");
	case SOAP_TYPE_dss__Device_StartDim:
		return soap_out_dss__Device_StartDim(soap, tag, id, (const struct dss__Device_StartDim *)ptr, "dss:Device-StartDim");
	case SOAP_TYPE_dss__Device_StartDimResponse:
		return soap_out_dss__Device_StartDimResponse(soap, tag, id, (const struct dss__Device_StartDimResponse *)ptr, "dss:Device-StartDimResponse");
	case SOAP_TYPE_dss__Device_Disable:
		return soap_out_dss__Device_Disable(soap, tag, id, (const struct dss__Device_Disable *)ptr, "dss:Device-Disable");
	case SOAP_TYPE_dss__Device_DisableResponse:
		return soap_out_dss__Device_DisableResponse(soap, tag, id, (const struct dss__Device_DisableResponse *)ptr, "dss:Device-DisableResponse");
	case SOAP_TYPE_dss__Device_Enable:
		return soap_out_dss__Device_Enable(soap, tag, id, (const struct dss__Device_Enable *)ptr, "dss:Device-Enable");
	case SOAP_TYPE_dss__Device_EnableResponse:
		return soap_out_dss__Device_EnableResponse(soap, tag, id, (const struct dss__Device_EnableResponse *)ptr, "dss:Device-EnableResponse");
	case SOAP_TYPE_dss__Device_DecreaseValue:
		return soap_out_dss__Device_DecreaseValue(soap, tag, id, (const struct dss__Device_DecreaseValue *)ptr, "dss:Device-DecreaseValue");
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		return soap_out_dss__Device_DecreaseValueResponse(soap, tag, id, (const struct dss__Device_DecreaseValueResponse *)ptr, "dss:Device-DecreaseValueResponse");
	case SOAP_TYPE_dss__Device_IncreaseValue:
		return soap_out_dss__Device_IncreaseValue(soap, tag, id, (const struct dss__Device_IncreaseValue *)ptr, "dss:Device-IncreaseValue");
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		return soap_out_dss__Device_IncreaseValueResponse(soap, tag, id, (const struct dss__Device_IncreaseValueResponse *)ptr, "dss:Device-IncreaseValueResponse");
	case SOAP_TYPE_dss__Device_TurnOff:
		return soap_out_dss__Device_TurnOff(soap, tag, id, (const struct dss__Device_TurnOff *)ptr, "dss:Device-TurnOff");
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		return soap_out_dss__Device_TurnOffResponse(soap, tag, id, (const struct dss__Device_TurnOffResponse *)ptr, "dss:Device-TurnOffResponse");
	case SOAP_TYPE_dss__Device_TurnOn:
		return soap_out_dss__Device_TurnOn(soap, tag, id, (const struct dss__Device_TurnOn *)ptr, "dss:Device-TurnOn");
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		return soap_out_dss__Device_TurnOnResponse(soap, tag, id, (const struct dss__Device_TurnOnResponse *)ptr, "dss:Device-TurnOnResponse");
	case SOAP_TYPE_dss__Set_SetValue:
		return soap_out_dss__Set_SetValue(soap, tag, id, (const struct dss__Set_SetValue *)ptr, "dss:Set-SetValue");
	case SOAP_TYPE_dss__Set_SetValueResponse:
		return soap_out_dss__Set_SetValueResponse(soap, tag, id, (const struct dss__Set_SetValueResponse *)ptr, "dss:Set-SetValueResponse");
	case SOAP_TYPE_dss__Set_EndDim:
		return soap_out_dss__Set_EndDim(soap, tag, id, (const struct dss__Set_EndDim *)ptr, "dss:Set-EndDim");
	case SOAP_TYPE_dss__Set_EndDimResponse:
		return soap_out_dss__Set_EndDimResponse(soap, tag, id, (const struct dss__Set_EndDimResponse *)ptr, "dss:Set-EndDimResponse");
	case SOAP_TYPE_dss__Set_StartDim:
		return soap_out_dss__Set_StartDim(soap, tag, id, (const struct dss__Set_StartDim *)ptr, "dss:Set-StartDim");
	case SOAP_TYPE_dss__Set_StartDimResponse:
		return soap_out_dss__Set_StartDimResponse(soap, tag, id, (const struct dss__Set_StartDimResponse *)ptr, "dss:Set-StartDimResponse");
	case SOAP_TYPE_dss__Set_Disable:
		return soap_out_dss__Set_Disable(soap, tag, id, (const struct dss__Set_Disable *)ptr, "dss:Set-Disable");
	case SOAP_TYPE_dss__Set_DisableResponse:
		return soap_out_dss__Set_DisableResponse(soap, tag, id, (const struct dss__Set_DisableResponse *)ptr, "dss:Set-DisableResponse");
	case SOAP_TYPE_dss__Set_Enable:
		return soap_out_dss__Set_Enable(soap, tag, id, (const struct dss__Set_Enable *)ptr, "dss:Set-Enable");
	case SOAP_TYPE_dss__Set_EnableResponse:
		return soap_out_dss__Set_EnableResponse(soap, tag, id, (const struct dss__Set_EnableResponse *)ptr, "dss:Set-EnableResponse");
	case SOAP_TYPE_dss__Set_DecreaseValue:
		return soap_out_dss__Set_DecreaseValue(soap, tag, id, (const struct dss__Set_DecreaseValue *)ptr, "dss:Set-DecreaseValue");
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		return soap_out_dss__Set_DecreaseValueResponse(soap, tag, id, (const struct dss__Set_DecreaseValueResponse *)ptr, "dss:Set-DecreaseValueResponse");
	case SOAP_TYPE_dss__Set_IncreaseValue:
		return soap_out_dss__Set_IncreaseValue(soap, tag, id, (const struct dss__Set_IncreaseValue *)ptr, "dss:Set-IncreaseValue");
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		return soap_out_dss__Set_IncreaseValueResponse(soap, tag, id, (const struct dss__Set_IncreaseValueResponse *)ptr, "dss:Set-IncreaseValueResponse");
	case SOAP_TYPE_dss__Set_TurnOff:
		return soap_out_dss__Set_TurnOff(soap, tag, id, (const struct dss__Set_TurnOff *)ptr, "dss:Set-TurnOff");
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		return soap_out_dss__Set_TurnOffResponse(soap, tag, id, (const struct dss__Set_TurnOffResponse *)ptr, "dss:Set-TurnOffResponse");
	case SOAP_TYPE_dss__Set_TurnOn:
		return soap_out_dss__Set_TurnOn(soap, tag, id, (const struct dss__Set_TurnOn *)ptr, "dss:Set-TurnOn");
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		return soap_out_dss__Set_TurnOnResponse(soap, tag, id, (const struct dss__Set_TurnOnResponse *)ptr, "dss:Set-TurnOnResponse");
	case SOAP_TYPE_dss__Apartment_GetRoomIDs:
		return soap_out_dss__Apartment_GetRoomIDs(soap, tag, id, (const struct dss__Apartment_GetRoomIDs *)ptr, "dss:Apartment-GetRoomIDs");
	case SOAP_TYPE_dss__Apartment_GetRoomIDsResponse:
		return soap_out_dss__Apartment_GetRoomIDsResponse(soap, tag, id, (const struct dss__Apartment_GetRoomIDsResponse *)ptr, "dss:Apartment-GetRoomIDsResponse");
	case SOAP_TYPE_dss__Apartment_GetRoomByName:
		return soap_out_dss__Apartment_GetRoomByName(soap, tag, id, (const struct dss__Apartment_GetRoomByName *)ptr, "dss:Apartment-GetRoomByName");
	case SOAP_TYPE_dss__Apartment_GetRoomByNameResponse:
		return soap_out_dss__Apartment_GetRoomByNameResponse(soap, tag, id, (const struct dss__Apartment_GetRoomByNameResponse *)ptr, "dss:Apartment-GetRoomByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		return soap_out_dss__Apartment_GetGroupByName(soap, tag, id, (const struct dss__Apartment_GetGroupByName *)ptr, "dss:Apartment-GetGroupByName");
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		return soap_out_dss__Apartment_GetGroupByNameResponse(soap, tag, id, (const struct dss__Apartment_GetGroupByNameResponse *)ptr, "dss:Apartment-GetGroupByNameResponse");
	case SOAP_TYPE_dss__Set_ByGroup:
		return soap_out_dss__Set_ByGroup(soap, tag, id, (const struct dss__Set_ByGroup *)ptr, "dss:Set-ByGroup");
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		return soap_out_dss__Set_ByGroupResponse(soap, tag, id, (const struct dss__Set_ByGroupResponse *)ptr, "dss:Set-ByGroupResponse");
	case SOAP_TYPE_dss__Set_Remove:
		return soap_out_dss__Set_Remove(soap, tag, id, (const struct dss__Set_Remove *)ptr, "dss:Set-Remove");
	case SOAP_TYPE_dss__Set_RemoveResponse:
		return soap_out_dss__Set_RemoveResponse(soap, tag, id, (const struct dss__Set_RemoveResponse *)ptr, "dss:Set-RemoveResponse");
	case SOAP_TYPE_dss__Set_Combine:
		return soap_out_dss__Set_Combine(soap, tag, id, (const struct dss__Set_Combine *)ptr, "dss:Set-Combine");
	case SOAP_TYPE_dss__Set_CombineResponse:
		return soap_out_dss__Set_CombineResponse(soap, tag, id, (const struct dss__Set_CombineResponse *)ptr, "dss:Set-CombineResponse");
	case SOAP_TYPE_dss__Set_RemoveDevice:
		return soap_out_dss__Set_RemoveDevice(soap, tag, id, (const struct dss__Set_RemoveDevice *)ptr, "dss:Set-RemoveDevice");
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		return soap_out_dss__Set_RemoveDeviceResponse(soap, tag, id, (const struct dss__Set_RemoveDeviceResponse *)ptr, "dss:Set-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		return soap_out_dss__Set_AddDeviceByID(soap, tag, id, (const struct dss__Set_AddDeviceByID *)ptr, "dss:Set-AddDeviceByID");
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		return soap_out_dss__Set_AddDeviceByIDResponse(soap, tag, id, (const struct dss__Set_AddDeviceByIDResponse *)ptr, "dss:Set-AddDeviceByIDResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		return soap_out_dss__Set_AddDeviceByName(soap, tag, id, (const struct dss__Set_AddDeviceByName *)ptr, "dss:Set-AddDeviceByName");
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		return soap_out_dss__Set_AddDeviceByNameResponse(soap, tag, id, (const struct dss__Set_AddDeviceByNameResponse *)ptr, "dss:Set-AddDeviceByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		return soap_out_dss__Apartment_GetDeviceIDByName(soap, tag, id, (const struct dss__Apartment_GetDeviceIDByName *)ptr, "dss:Apartment-GetDeviceIDByName");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		return soap_out_dss__Apartment_GetDeviceIDByNameResponse(soap, tag, id, (const struct dss__Apartment_GetDeviceIDByNameResponse *)ptr, "dss:Apartment-GetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDevices:
		return soap_out_dss__Apartment_GetDevices(soap, tag, id, (const struct dss__Apartment_GetDevices *)ptr, "dss:Apartment-GetDevices");
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		return soap_out_dss__Apartment_GetDevicesResponse(soap, tag, id, (const struct dss__Apartment_GetDevicesResponse *)ptr, "dss:Apartment-GetDevicesResponse");
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		return soap_out_dss__Apartment_CreateEmptySet(soap, tag, id, (const struct dss__Apartment_CreateEmptySet *)ptr, "dss:Apartment-CreateEmptySet");
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		return soap_out_dss__Apartment_CreateEmptySetResponse(soap, tag, id, (const struct dss__Apartment_CreateEmptySetResponse *)ptr, "dss:Apartment-CreateEmptySetResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		return soap_out_dss__Apartment_CreateSetFromDeviceNames(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceNames *)ptr, "dss:Apartment-CreateSetFromDeviceNames");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		return soap_out_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceNamesResponse *)ptr, "dss:Apartment-CreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		return soap_out_dss__Apartment_CreateSetFromDeviceIDs(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceIDs *)ptr, "dss:Apartment-CreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		return soap_out_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceIDsResponse *)ptr, "dss:Apartment-CreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		return soap_out_dss__Apartment_CreateSetFromGroup(soap, tag, id, (const struct dss__Apartment_CreateSetFromGroup *)ptr, "dss:Apartment-CreateSetFromGroup");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		return soap_out_dss__Apartment_CreateSetFromGroupResponse(soap, tag, id, (const struct dss__Apartment_CreateSetFromGroupResponse *)ptr, "dss:Apartment-CreateSetFromGroupResponse");
	case SOAP_TYPE_dss__FreeSet:
		return soap_out_dss__FreeSet(soap, tag, id, (const struct dss__FreeSet *)ptr, "dss:FreeSet");
	case SOAP_TYPE_dss__FreeSetResponse:
		return soap_out_dss__FreeSetResponse(soap, tag, id, (const struct dss__FreeSetResponse *)ptr, "dss:FreeSetResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_out_dss__SignOff(soap, tag, id, (const struct dss__SignOff *)ptr, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_out_dss__SignOffResponse(soap, tag, id, (const struct dss__SignOffResponse *)ptr, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_out_dss__Authenticate(soap, tag, id, (const struct dss__Authenticate *)ptr, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_out_dss__AuthenticateResponse(soap, tag, id, (const struct dss__AuthenticateResponse *)ptr, "dss:AuthenticateResponse");
	case SOAP_TYPE_PointerToStringArray:
		return soap_out_PointerToStringArray(soap, tag, id, (StringArray *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_dss__outParameter:
		((dss__outParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_dss__inParameter:
		((dss__inParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_StringArray:
		((StringArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_IntArray:
		((IntArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		soap_serialize_dss__Event_DeleteSchedule(soap, (const struct dss__Event_DeleteSchedule *)ptr);
		break;
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		soap_serialize_dss__Event_DeleteScheduleResponse(soap, (const struct dss__Event_DeleteScheduleResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Schedule:
		soap_serialize_dss__Event_Schedule(soap, (const struct dss__Event_Schedule *)ptr);
		break;
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		soap_serialize_dss__Event_ScheduleResponse(soap, (const struct dss__Event_ScheduleResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Unsubscribe:
		soap_serialize_dss__Event_Unsubscribe(soap, (const struct dss__Event_Unsubscribe *)ptr);
		break;
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		soap_serialize_dss__Event_UnsubscribeResponse(soap, (const struct dss__Event_UnsubscribeResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Subscribe:
		soap_serialize_dss__Event_Subscribe(soap, (const struct dss__Event_Subscribe *)ptr);
		break;
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		soap_serialize_dss__Event_SubscribeResponse(soap, (const struct dss__Event_SubscribeResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		soap_serialize_dss__Event_GetActionParamsTemplate(soap, (const struct dss__Event_GetActionParamsTemplate *)ptr);
		break;
	case SOAP_TYPE_dss__Event_GetActionNames:
		soap_serialize_dss__Event_GetActionNames(soap, (const struct dss__Event_GetActionNames *)ptr);
		break;
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		soap_serialize_dss__Event_GetActionNamesResponse(soap, (const struct dss__Event_GetActionNamesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Raise:
		soap_serialize_dss__Event_Raise(soap, (const struct dss__Event_Raise *)ptr);
		break;
	case SOAP_TYPE_dss__Event_RaiseResponse:
		soap_serialize_dss__Event_RaiseResponse(soap, (const struct dss__Event_RaiseResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveDevice:
		soap_serialize_dss__Group_RemoveDevice(soap, (const struct dss__Group_RemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		soap_serialize_dss__Group_RemoveDeviceResponse(soap, (const struct dss__Group_RemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_AddDevice:
		soap_serialize_dss__Group_AddDevice(soap, (const struct dss__Group_AddDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		soap_serialize_dss__Group_AddDeviceResponse(soap, (const struct dss__Group_AddDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		soap_serialize_dss__Group_RemoveUserGroup(soap, (const struct dss__Group_RemoveUserGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		soap_serialize_dss__Group_RemoveUserGroupResponse(soap, (const struct dss__Group_RemoveUserGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		soap_serialize_dss__Apartment_AllocateUserGroup(soap, (const struct dss__Apartment_AllocateUserGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		soap_serialize_dss__Apartment_AllocateUserGroupResponse(soap, (const struct dss__Apartment_AllocateUserGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Room_SetName:
		soap_serialize_dss__Room_SetName(soap, (const struct dss__Room_SetName *)ptr);
		break;
	case SOAP_TYPE_dss__Room_SetNameResponse:
		soap_serialize_dss__Room_SetNameResponse(soap, (const struct dss__Room_SetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Room_RemoveDevice:
		soap_serialize_dss__Room_RemoveDevice(soap, (const struct dss__Room_RemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Room_RemoveDeviceResponse:
		soap_serialize_dss__Room_RemoveDeviceResponse(soap, (const struct dss__Room_RemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Room_AddDevice:
		soap_serialize_dss__Room_AddDevice(soap, (const struct dss__Room_AddDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Room_AddDeviceResponse:
		soap_serialize_dss__Room_AddDeviceResponse(soap, (const struct dss__Room_AddDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_DeleteRoom:
		soap_serialize_dss__Apartment_DeleteRoom(soap, (const struct dss__Apartment_DeleteRoom *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_DeleteRoomResponse:
		soap_serialize_dss__Apartment_DeleteRoomResponse(soap, (const struct dss__Apartment_DeleteRoomResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateRoom:
		soap_serialize_dss__Apartment_AllocateRoom(soap, (const struct dss__Apartment_AllocateRoom *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateRoomResponse:
		soap_serialize_dss__Apartment_AllocateRoomResponse(soap, (const struct dss__Apartment_AllocateRoomResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetName:
		soap_serialize_dss__Modulator_GetName(soap, (const struct dss__Modulator_GetName *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		soap_serialize_dss__Modulator_GetNameResponse(soap, (const struct dss__Modulator_GetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetDSID:
		soap_serialize_dss__Modulator_GetDSID(soap, (const struct dss__Modulator_GetDSID *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		soap_serialize_dss__Modulator_GetDSIDResponse(soap, (const struct dss__Modulator_GetDSIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		soap_serialize_dss__Apartment_GetModulatorIDs(soap, (const struct dss__Apartment_GetModulatorIDs *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		soap_serialize_dss__Apartment_GetModulatorIDsResponse(soap, (const struct dss__Apartment_GetModulatorIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetDSID:
		soap_serialize_dss__Device_GetDSID(soap, (const struct dss__Device_GetDSID *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		soap_serialize_dss__Device_GetDSIDResponse(soap, (const struct dss__Device_GetDSIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetValue:
		soap_serialize_dss__Device_GetValue(soap, (const struct dss__Device_GetValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetValueResponse:
		soap_serialize_dss__Device_GetValueResponse(soap, (const struct dss__Device_GetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_SetValue:
		soap_serialize_dss__Device_SetValue(soap, (const struct dss__Device_SetValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_SetValueResponse:
		soap_serialize_dss__Device_SetValueResponse(soap, (const struct dss__Device_SetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_EndDim:
		soap_serialize_dss__Device_EndDim(soap, (const struct dss__Device_EndDim *)ptr);
		break;
	case SOAP_TYPE_dss__Device_EndDimResponse:
		soap_serialize_dss__Device_EndDimResponse(soap, (const struct dss__Device_EndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_StartDim:
		soap_serialize_dss__Device_StartDim(soap, (const struct dss__Device_StartDim *)ptr);
		break;
	case SOAP_TYPE_dss__Device_StartDimResponse:
		soap_serialize_dss__Device_StartDimResponse(soap, (const struct dss__Device_StartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_Disable:
		soap_serialize_dss__Device_Disable(soap, (const struct dss__Device_Disable *)ptr);
		break;
	case SOAP_TYPE_dss__Device_DisableResponse:
		soap_serialize_dss__Device_DisableResponse(soap, (const struct dss__Device_DisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_Enable:
		soap_serialize_dss__Device_Enable(soap, (const struct dss__Device_Enable *)ptr);
		break;
	case SOAP_TYPE_dss__Device_EnableResponse:
		soap_serialize_dss__Device_EnableResponse(soap, (const struct dss__Device_EnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_DecreaseValue:
		soap_serialize_dss__Device_DecreaseValue(soap, (const struct dss__Device_DecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		soap_serialize_dss__Device_DecreaseValueResponse(soap, (const struct dss__Device_DecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_IncreaseValue:
		soap_serialize_dss__Device_IncreaseValue(soap, (const struct dss__Device_IncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		soap_serialize_dss__Device_IncreaseValueResponse(soap, (const struct dss__Device_IncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOff:
		soap_serialize_dss__Device_TurnOff(soap, (const struct dss__Device_TurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		soap_serialize_dss__Device_TurnOffResponse(soap, (const struct dss__Device_TurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOn:
		soap_serialize_dss__Device_TurnOn(soap, (const struct dss__Device_TurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		soap_serialize_dss__Device_TurnOnResponse(soap, (const struct dss__Device_TurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_SetValue:
		soap_serialize_dss__Set_SetValue(soap, (const struct dss__Set_SetValue *)ptr);
		break;
	case SOAP_TYPE_dss__Set_SetValueResponse:
		soap_serialize_dss__Set_SetValueResponse(soap, (const struct dss__Set_SetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_EndDim:
		soap_serialize_dss__Set_EndDim(soap, (const struct dss__Set_EndDim *)ptr);
		break;
	case SOAP_TYPE_dss__Set_EndDimResponse:
		soap_serialize_dss__Set_EndDimResponse(soap, (const struct dss__Set_EndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_StartDim:
		soap_serialize_dss__Set_StartDim(soap, (const struct dss__Set_StartDim *)ptr);
		break;
	case SOAP_TYPE_dss__Set_StartDimResponse:
		soap_serialize_dss__Set_StartDimResponse(soap, (const struct dss__Set_StartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Disable:
		soap_serialize_dss__Set_Disable(soap, (const struct dss__Set_Disable *)ptr);
		break;
	case SOAP_TYPE_dss__Set_DisableResponse:
		soap_serialize_dss__Set_DisableResponse(soap, (const struct dss__Set_DisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Enable:
		soap_serialize_dss__Set_Enable(soap, (const struct dss__Set_Enable *)ptr);
		break;
	case SOAP_TYPE_dss__Set_EnableResponse:
		soap_serialize_dss__Set_EnableResponse(soap, (const struct dss__Set_EnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_DecreaseValue:
		soap_serialize_dss__Set_DecreaseValue(soap, (const struct dss__Set_DecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		soap_serialize_dss__Set_DecreaseValueResponse(soap, (const struct dss__Set_DecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_IncreaseValue:
		soap_serialize_dss__Set_IncreaseValue(soap, (const struct dss__Set_IncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		soap_serialize_dss__Set_IncreaseValueResponse(soap, (const struct dss__Set_IncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOff:
		soap_serialize_dss__Set_TurnOff(soap, (const struct dss__Set_TurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		soap_serialize_dss__Set_TurnOffResponse(soap, (const struct dss__Set_TurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOn:
		soap_serialize_dss__Set_TurnOn(soap, (const struct dss__Set_TurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		soap_serialize_dss__Set_TurnOnResponse(soap, (const struct dss__Set_TurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomIDs:
		soap_serialize_dss__Apartment_GetRoomIDs(soap, (const struct dss__Apartment_GetRoomIDs *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomIDsResponse:
		soap_serialize_dss__Apartment_GetRoomIDsResponse(soap, (const struct dss__Apartment_GetRoomIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomByName:
		soap_serialize_dss__Apartment_GetRoomByName(soap, (const struct dss__Apartment_GetRoomByName *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomByNameResponse:
		soap_serialize_dss__Apartment_GetRoomByNameResponse(soap, (const struct dss__Apartment_GetRoomByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		soap_serialize_dss__Apartment_GetGroupByName(soap, (const struct dss__Apartment_GetGroupByName *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		soap_serialize_dss__Apartment_GetGroupByNameResponse(soap, (const struct dss__Apartment_GetGroupByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_ByGroup:
		soap_serialize_dss__Set_ByGroup(soap, (const struct dss__Set_ByGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		soap_serialize_dss__Set_ByGroupResponse(soap, (const struct dss__Set_ByGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Remove:
		soap_serialize_dss__Set_Remove(soap, (const struct dss__Set_Remove *)ptr);
		break;
	case SOAP_TYPE_dss__Set_RemoveResponse:
		soap_serialize_dss__Set_RemoveResponse(soap, (const struct dss__Set_RemoveResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Combine:
		soap_serialize_dss__Set_Combine(soap, (const struct dss__Set_Combine *)ptr);
		break;
	case SOAP_TYPE_dss__Set_CombineResponse:
		soap_serialize_dss__Set_CombineResponse(soap, (const struct dss__Set_CombineResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_RemoveDevice:
		soap_serialize_dss__Set_RemoveDevice(soap, (const struct dss__Set_RemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		soap_serialize_dss__Set_RemoveDeviceResponse(soap, (const struct dss__Set_RemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		soap_serialize_dss__Set_AddDeviceByID(soap, (const struct dss__Set_AddDeviceByID *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		soap_serialize_dss__Set_AddDeviceByIDResponse(soap, (const struct dss__Set_AddDeviceByIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		soap_serialize_dss__Set_AddDeviceByName(soap, (const struct dss__Set_AddDeviceByName *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		soap_serialize_dss__Set_AddDeviceByNameResponse(soap, (const struct dss__Set_AddDeviceByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		soap_serialize_dss__Apartment_GetDeviceIDByName(soap, (const struct dss__Apartment_GetDeviceIDByName *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		soap_serialize_dss__Apartment_GetDeviceIDByNameResponse(soap, (const struct dss__Apartment_GetDeviceIDByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDevices:
		soap_serialize_dss__Apartment_GetDevices(soap, (const struct dss__Apartment_GetDevices *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		soap_serialize_dss__Apartment_GetDevicesResponse(soap, (const struct dss__Apartment_GetDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		soap_serialize_dss__Apartment_CreateEmptySet(soap, (const struct dss__Apartment_CreateEmptySet *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		soap_serialize_dss__Apartment_CreateEmptySetResponse(soap, (const struct dss__Apartment_CreateEmptySetResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		soap_serialize_dss__Apartment_CreateSetFromDeviceNames(soap, (const struct dss__Apartment_CreateSetFromDeviceNames *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		soap_serialize_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, (const struct dss__Apartment_CreateSetFromDeviceNamesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		soap_serialize_dss__Apartment_CreateSetFromDeviceIDs(soap, (const struct dss__Apartment_CreateSetFromDeviceIDs *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		soap_serialize_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, (const struct dss__Apartment_CreateSetFromDeviceIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		soap_serialize_dss__Apartment_CreateSetFromGroup(soap, (const struct dss__Apartment_CreateSetFromGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		soap_serialize_dss__Apartment_CreateSetFromGroupResponse(soap, (const struct dss__Apartment_CreateSetFromGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__FreeSet:
		soap_serialize_dss__FreeSet(soap, (const struct dss__FreeSet *)ptr);
		break;
	case SOAP_TYPE_dss__FreeSetResponse:
		soap_serialize_dss__FreeSetResponse(soap, (const struct dss__FreeSetResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SignOff:
		soap_serialize_dss__SignOff(soap, (const struct dss__SignOff *)ptr);
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		soap_serialize_dss__SignOffResponse(soap, (const struct dss__SignOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Authenticate:
		soap_serialize_dss__Authenticate(soap, (const struct dss__Authenticate *)ptr);
		break;
	case SOAP_TYPE_dss__AuthenticateResponse:
		soap_serialize_dss__AuthenticateResponse(soap, (const struct dss__AuthenticateResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToStringArray:
		soap_serialize_PointerToStringArray(soap, (StringArray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_IntArray:
		return (void*)soap_instantiate_IntArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_StringArray:
		return (void*)soap_instantiate_StringArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__AuthenticateResponse:
		return (void*)soap_instantiate_dss__AuthenticateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Authenticate:
		return (void*)soap_instantiate_dss__Authenticate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOffResponse:
		return (void*)soap_instantiate_dss__SignOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOff:
		return (void*)soap_instantiate_dss__SignOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__FreeSetResponse:
		return (void*)soap_instantiate_dss__FreeSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__FreeSet:
		return (void*)soap_instantiate_dss__FreeSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateEmptySetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		return (void*)soap_instantiate_dss__Apartment_CreateEmptySet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		return (void*)soap_instantiate_dss__Apartment_GetDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDevices:
		return (void*)soap_instantiate_dss__Apartment_GetDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		return (void*)soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		return (void*)soap_instantiate_dss__Apartment_GetDeviceIDByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		return (void*)soap_instantiate_dss__Set_AddDeviceByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		return (void*)soap_instantiate_dss__Set_AddDeviceByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		return (void*)soap_instantiate_dss__Set_AddDeviceByIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		return (void*)soap_instantiate_dss__Set_AddDeviceByID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		return (void*)soap_instantiate_dss__Set_RemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_RemoveDevice:
		return (void*)soap_instantiate_dss__Set_RemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_CombineResponse:
		return (void*)soap_instantiate_dss__Set_CombineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Combine:
		return (void*)soap_instantiate_dss__Set_Combine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_RemoveResponse:
		return (void*)soap_instantiate_dss__Set_RemoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Remove:
		return (void*)soap_instantiate_dss__Set_Remove(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		return (void*)soap_instantiate_dss__Set_ByGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_ByGroup:
		return (void*)soap_instantiate_dss__Set_ByGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		return (void*)soap_instantiate_dss__Apartment_GetGroupByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		return (void*)soap_instantiate_dss__Apartment_GetGroupByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetRoomByNameResponse:
		return (void*)soap_instantiate_dss__Apartment_GetRoomByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetRoomByName:
		return (void*)soap_instantiate_dss__Apartment_GetRoomByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetRoomIDsResponse:
		return (void*)soap_instantiate_dss__Apartment_GetRoomIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetRoomIDs:
		return (void*)soap_instantiate_dss__Apartment_GetRoomIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		return (void*)soap_instantiate_dss__Set_TurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOn:
		return (void*)soap_instantiate_dss__Set_TurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		return (void*)soap_instantiate_dss__Set_TurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOff:
		return (void*)soap_instantiate_dss__Set_TurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		return (void*)soap_instantiate_dss__Set_IncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_IncreaseValue:
		return (void*)soap_instantiate_dss__Set_IncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		return (void*)soap_instantiate_dss__Set_DecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_DecreaseValue:
		return (void*)soap_instantiate_dss__Set_DecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_EnableResponse:
		return (void*)soap_instantiate_dss__Set_EnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Enable:
		return (void*)soap_instantiate_dss__Set_Enable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_DisableResponse:
		return (void*)soap_instantiate_dss__Set_DisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Disable:
		return (void*)soap_instantiate_dss__Set_Disable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_StartDimResponse:
		return (void*)soap_instantiate_dss__Set_StartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_StartDim:
		return (void*)soap_instantiate_dss__Set_StartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_EndDimResponse:
		return (void*)soap_instantiate_dss__Set_EndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_EndDim:
		return (void*)soap_instantiate_dss__Set_EndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_SetValueResponse:
		return (void*)soap_instantiate_dss__Set_SetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_SetValue:
		return (void*)soap_instantiate_dss__Set_SetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		return (void*)soap_instantiate_dss__Device_TurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOn:
		return (void*)soap_instantiate_dss__Device_TurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		return (void*)soap_instantiate_dss__Device_TurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOff:
		return (void*)soap_instantiate_dss__Device_TurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		return (void*)soap_instantiate_dss__Device_IncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_IncreaseValue:
		return (void*)soap_instantiate_dss__Device_IncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		return (void*)soap_instantiate_dss__Device_DecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_DecreaseValue:
		return (void*)soap_instantiate_dss__Device_DecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_EnableResponse:
		return (void*)soap_instantiate_dss__Device_EnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_Enable:
		return (void*)soap_instantiate_dss__Device_Enable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_DisableResponse:
		return (void*)soap_instantiate_dss__Device_DisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_Disable:
		return (void*)soap_instantiate_dss__Device_Disable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_StartDimResponse:
		return (void*)soap_instantiate_dss__Device_StartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_StartDim:
		return (void*)soap_instantiate_dss__Device_StartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_EndDimResponse:
		return (void*)soap_instantiate_dss__Device_EndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_EndDim:
		return (void*)soap_instantiate_dss__Device_EndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_SetValueResponse:
		return (void*)soap_instantiate_dss__Device_SetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_SetValue:
		return (void*)soap_instantiate_dss__Device_SetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetValueResponse:
		return (void*)soap_instantiate_dss__Device_GetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetValue:
		return (void*)soap_instantiate_dss__Device_GetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		return (void*)soap_instantiate_dss__Device_GetDSIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetDSID:
		return (void*)soap_instantiate_dss__Device_GetDSID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		return (void*)soap_instantiate_dss__Apartment_GetModulatorIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		return (void*)soap_instantiate_dss__Apartment_GetModulatorIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		return (void*)soap_instantiate_dss__Modulator_GetDSIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetDSID:
		return (void*)soap_instantiate_dss__Modulator_GetDSID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		return (void*)soap_instantiate_dss__Modulator_GetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetName:
		return (void*)soap_instantiate_dss__Modulator_GetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateRoomResponse:
		return (void*)soap_instantiate_dss__Apartment_AllocateRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateRoom:
		return (void*)soap_instantiate_dss__Apartment_AllocateRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_DeleteRoomResponse:
		return (void*)soap_instantiate_dss__Apartment_DeleteRoomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_DeleteRoom:
		return (void*)soap_instantiate_dss__Apartment_DeleteRoom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Room_AddDeviceResponse:
		return (void*)soap_instantiate_dss__Room_AddDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Room_AddDevice:
		return (void*)soap_instantiate_dss__Room_AddDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Room_RemoveDeviceResponse:
		return (void*)soap_instantiate_dss__Room_RemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Room_RemoveDevice:
		return (void*)soap_instantiate_dss__Room_RemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Room_SetNameResponse:
		return (void*)soap_instantiate_dss__Room_SetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Room_SetName:
		return (void*)soap_instantiate_dss__Room_SetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		return (void*)soap_instantiate_dss__Apartment_AllocateUserGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		return (void*)soap_instantiate_dss__Apartment_AllocateUserGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		return (void*)soap_instantiate_dss__Group_RemoveUserGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		return (void*)soap_instantiate_dss__Group_RemoveUserGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		return (void*)soap_instantiate_dss__Group_AddDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_AddDevice:
		return (void*)soap_instantiate_dss__Group_AddDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		return (void*)soap_instantiate_dss__Group_RemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveDevice:
		return (void*)soap_instantiate_dss__Group_RemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__inParameter:
		return (void*)soap_instantiate_dss__inParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__outParameter:
		return (void*)soap_instantiate_dss__outParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_RaiseResponse:
		return (void*)soap_instantiate_dss__Event_RaiseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Raise:
		return (void*)soap_instantiate_dss__Event_Raise(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		return (void*)soap_instantiate_dss__Event_GetActionNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_GetActionNames:
		return (void*)soap_instantiate_dss__Event_GetActionNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		return (void*)soap_instantiate_dss__Event_GetActionParamsTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		return (void*)soap_instantiate_dss__Event_SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Subscribe:
		return (void*)soap_instantiate_dss__Event_Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		return (void*)soap_instantiate_dss__Event_UnsubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Unsubscribe:
		return (void*)soap_instantiate_dss__Event_Unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		return (void*)soap_instantiate_dss__Event_ScheduleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Schedule:
		return (void*)soap_instantiate_dss__Event_Schedule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		return (void*)soap_instantiate_dss__Event_DeleteScheduleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		return (void*)soap_instantiate_dss__Event_DeleteSchedule(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_IntArray:
		if (p->size < 0)
			delete (IntArray*)p->ptr;
		else
			delete[] (IntArray*)p->ptr;
		break;
	case SOAP_TYPE_StringArray:
		if (p->size < 0)
			delete (StringArray*)p->ptr;
		else
			delete[] (StringArray*)p->ptr;
		break;
	case SOAP_TYPE_dss__AuthenticateResponse:
		if (p->size < 0)
			delete (struct dss__AuthenticateResponse*)p->ptr;
		else
			delete[] (struct dss__AuthenticateResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Authenticate:
		if (p->size < 0)
			delete (struct dss__Authenticate*)p->ptr;
		else
			delete[] (struct dss__Authenticate*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		if (p->size < 0)
			delete (struct dss__SignOffResponse*)p->ptr;
		else
			delete[] (struct dss__SignOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOff:
		if (p->size < 0)
			delete (struct dss__SignOff*)p->ptr;
		else
			delete[] (struct dss__SignOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__FreeSetResponse:
		if (p->size < 0)
			delete (struct dss__FreeSetResponse*)p->ptr;
		else
			delete[] (struct dss__FreeSetResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__FreeSet:
		if (p->size < 0)
			delete (struct dss__FreeSet*)p->ptr;
		else
			delete[] (struct dss__FreeSet*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromGroup*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceIDsResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceIDs*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceNamesResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceNamesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceNames*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceNames*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateEmptySetResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateEmptySetResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateEmptySet*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateEmptySet*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDevicesResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDevicesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDevices:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDevices*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDevices*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDeviceIDByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDeviceIDByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDeviceIDByName*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDeviceIDByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByName*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByIDResponse*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByID*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Set_RemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Set_RemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_RemoveDevice:
		if (p->size < 0)
			delete (struct dss__Set_RemoveDevice*)p->ptr;
		else
			delete[] (struct dss__Set_RemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_CombineResponse:
		if (p->size < 0)
			delete (struct dss__Set_CombineResponse*)p->ptr;
		else
			delete[] (struct dss__Set_CombineResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Combine:
		if (p->size < 0)
			delete (struct dss__Set_Combine*)p->ptr;
		else
			delete[] (struct dss__Set_Combine*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_RemoveResponse:
		if (p->size < 0)
			delete (struct dss__Set_RemoveResponse*)p->ptr;
		else
			delete[] (struct dss__Set_RemoveResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Remove:
		if (p->size < 0)
			delete (struct dss__Set_Remove*)p->ptr;
		else
			delete[] (struct dss__Set_Remove*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		if (p->size < 0)
			delete (struct dss__Set_ByGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Set_ByGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_ByGroup:
		if (p->size < 0)
			delete (struct dss__Set_ByGroup*)p->ptr;
		else
			delete[] (struct dss__Set_ByGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetGroupByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetGroupByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		if (p->size < 0)
			delete (struct dss__Apartment_GetGroupByName*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetGroupByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomByNameResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetRoomByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetRoomByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomByName:
		if (p->size < 0)
			delete (struct dss__Apartment_GetRoomByName*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetRoomByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomIDsResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetRoomIDsResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetRoomIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetRoomIDs:
		if (p->size < 0)
			delete (struct dss__Apartment_GetRoomIDs*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetRoomIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		if (p->size < 0)
			delete (struct dss__Set_TurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOn:
		if (p->size < 0)
			delete (struct dss__Set_TurnOn*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		if (p->size < 0)
			delete (struct dss__Set_TurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOff:
		if (p->size < 0)
			delete (struct dss__Set_TurnOff*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Set_IncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Set_IncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_IncreaseValue:
		if (p->size < 0)
			delete (struct dss__Set_IncreaseValue*)p->ptr;
		else
			delete[] (struct dss__Set_IncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Set_DecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Set_DecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_DecreaseValue:
		if (p->size < 0)
			delete (struct dss__Set_DecreaseValue*)p->ptr;
		else
			delete[] (struct dss__Set_DecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_EnableResponse:
		if (p->size < 0)
			delete (struct dss__Set_EnableResponse*)p->ptr;
		else
			delete[] (struct dss__Set_EnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Enable:
		if (p->size < 0)
			delete (struct dss__Set_Enable*)p->ptr;
		else
			delete[] (struct dss__Set_Enable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_DisableResponse:
		if (p->size < 0)
			delete (struct dss__Set_DisableResponse*)p->ptr;
		else
			delete[] (struct dss__Set_DisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Disable:
		if (p->size < 0)
			delete (struct dss__Set_Disable*)p->ptr;
		else
			delete[] (struct dss__Set_Disable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_StartDimResponse:
		if (p->size < 0)
			delete (struct dss__Set_StartDimResponse*)p->ptr;
		else
			delete[] (struct dss__Set_StartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_StartDim:
		if (p->size < 0)
			delete (struct dss__Set_StartDim*)p->ptr;
		else
			delete[] (struct dss__Set_StartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_EndDimResponse:
		if (p->size < 0)
			delete (struct dss__Set_EndDimResponse*)p->ptr;
		else
			delete[] (struct dss__Set_EndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_EndDim:
		if (p->size < 0)
			delete (struct dss__Set_EndDim*)p->ptr;
		else
			delete[] (struct dss__Set_EndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_SetValueResponse:
		if (p->size < 0)
			delete (struct dss__Set_SetValueResponse*)p->ptr;
		else
			delete[] (struct dss__Set_SetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_SetValue:
		if (p->size < 0)
			delete (struct dss__Set_SetValue*)p->ptr;
		else
			delete[] (struct dss__Set_SetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		if (p->size < 0)
			delete (struct dss__Device_TurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOn:
		if (p->size < 0)
			delete (struct dss__Device_TurnOn*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		if (p->size < 0)
			delete (struct dss__Device_TurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOff:
		if (p->size < 0)
			delete (struct dss__Device_TurnOff*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_IncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_IncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_IncreaseValue:
		if (p->size < 0)
			delete (struct dss__Device_IncreaseValue*)p->ptr;
		else
			delete[] (struct dss__Device_IncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_DecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_DecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_DecreaseValue:
		if (p->size < 0)
			delete (struct dss__Device_DecreaseValue*)p->ptr;
		else
			delete[] (struct dss__Device_DecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_EnableResponse:
		if (p->size < 0)
			delete (struct dss__Device_EnableResponse*)p->ptr;
		else
			delete[] (struct dss__Device_EnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_Enable:
		if (p->size < 0)
			delete (struct dss__Device_Enable*)p->ptr;
		else
			delete[] (struct dss__Device_Enable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_DisableResponse:
		if (p->size < 0)
			delete (struct dss__Device_DisableResponse*)p->ptr;
		else
			delete[] (struct dss__Device_DisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_Disable:
		if (p->size < 0)
			delete (struct dss__Device_Disable*)p->ptr;
		else
			delete[] (struct dss__Device_Disable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_StartDimResponse:
		if (p->size < 0)
			delete (struct dss__Device_StartDimResponse*)p->ptr;
		else
			delete[] (struct dss__Device_StartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_StartDim:
		if (p->size < 0)
			delete (struct dss__Device_StartDim*)p->ptr;
		else
			delete[] (struct dss__Device_StartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_EndDimResponse:
		if (p->size < 0)
			delete (struct dss__Device_EndDimResponse*)p->ptr;
		else
			delete[] (struct dss__Device_EndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_EndDim:
		if (p->size < 0)
			delete (struct dss__Device_EndDim*)p->ptr;
		else
			delete[] (struct dss__Device_EndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_SetValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_SetValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_SetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_SetValue:
		if (p->size < 0)
			delete (struct dss__Device_SetValue*)p->ptr;
		else
			delete[] (struct dss__Device_SetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_GetValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_GetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetValue:
		if (p->size < 0)
			delete (struct dss__Device_GetValue*)p->ptr;
		else
			delete[] (struct dss__Device_GetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		if (p->size < 0)
			delete (struct dss__Device_GetDSIDResponse*)p->ptr;
		else
			delete[] (struct dss__Device_GetDSIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetDSID:
		if (p->size < 0)
			delete (struct dss__Device_GetDSID*)p->ptr;
		else
			delete[] (struct dss__Device_GetDSID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetModulatorIDsResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetModulatorIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		if (p->size < 0)
			delete (struct dss__Apartment_GetModulatorIDs*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetModulatorIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		if (p->size < 0)
			delete (struct dss__Modulator_GetDSIDResponse*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetDSIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetDSID:
		if (p->size < 0)
			delete (struct dss__Modulator_GetDSID*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetDSID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		if (p->size < 0)
			delete (struct dss__Modulator_GetNameResponse*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetName:
		if (p->size < 0)
			delete (struct dss__Modulator_GetName*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateRoomResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateRoomResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateRoomResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateRoom:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateRoom*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateRoom*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_DeleteRoomResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_DeleteRoomResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_DeleteRoomResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_DeleteRoom:
		if (p->size < 0)
			delete (struct dss__Apartment_DeleteRoom*)p->ptr;
		else
			delete[] (struct dss__Apartment_DeleteRoom*)p->ptr;
		break;
	case SOAP_TYPE_dss__Room_AddDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Room_AddDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Room_AddDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Room_AddDevice:
		if (p->size < 0)
			delete (struct dss__Room_AddDevice*)p->ptr;
		else
			delete[] (struct dss__Room_AddDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Room_RemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Room_RemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Room_RemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Room_RemoveDevice:
		if (p->size < 0)
			delete (struct dss__Room_RemoveDevice*)p->ptr;
		else
			delete[] (struct dss__Room_RemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Room_SetNameResponse:
		if (p->size < 0)
			delete (struct dss__Room_SetNameResponse*)p->ptr;
		else
			delete[] (struct dss__Room_SetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Room_SetName:
		if (p->size < 0)
			delete (struct dss__Room_SetName*)p->ptr;
		else
			delete[] (struct dss__Room_SetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateUserGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateUserGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateUserGroup*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateUserGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		if (p->size < 0)
			delete (struct dss__Group_RemoveUserGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveUserGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		if (p->size < 0)
			delete (struct dss__Group_RemoveUserGroup*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveUserGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Group_AddDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Group_AddDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_AddDevice:
		if (p->size < 0)
			delete (struct dss__Group_AddDevice*)p->ptr;
		else
			delete[] (struct dss__Group_AddDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Group_RemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveDevice:
		if (p->size < 0)
			delete (struct dss__Group_RemoveDevice*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__inParameter:
		if (p->size < 0)
			delete (dss__inParameter*)p->ptr;
		else
			delete[] (dss__inParameter*)p->ptr;
		break;
	case SOAP_TYPE_dss__outParameter:
		if (p->size < 0)
			delete (dss__outParameter*)p->ptr;
		else
			delete[] (dss__outParameter*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_RaiseResponse:
		if (p->size < 0)
			delete (struct dss__Event_RaiseResponse*)p->ptr;
		else
			delete[] (struct dss__Event_RaiseResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Raise:
		if (p->size < 0)
			delete (struct dss__Event_Raise*)p->ptr;
		else
			delete[] (struct dss__Event_Raise*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		if (p->size < 0)
			delete (struct dss__Event_GetActionNamesResponse*)p->ptr;
		else
			delete[] (struct dss__Event_GetActionNamesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_GetActionNames:
		if (p->size < 0)
			delete (struct dss__Event_GetActionNames*)p->ptr;
		else
			delete[] (struct dss__Event_GetActionNames*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		if (p->size < 0)
			delete (struct dss__Event_GetActionParamsTemplate*)p->ptr;
		else
			delete[] (struct dss__Event_GetActionParamsTemplate*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		if (p->size < 0)
			delete (struct dss__Event_SubscribeResponse*)p->ptr;
		else
			delete[] (struct dss__Event_SubscribeResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Subscribe:
		if (p->size < 0)
			delete (struct dss__Event_Subscribe*)p->ptr;
		else
			delete[] (struct dss__Event_Subscribe*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		if (p->size < 0)
			delete (struct dss__Event_UnsubscribeResponse*)p->ptr;
		else
			delete[] (struct dss__Event_UnsubscribeResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Unsubscribe:
		if (p->size < 0)
			delete (struct dss__Event_Unsubscribe*)p->ptr;
		else
			delete[] (struct dss__Event_Unsubscribe*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		if (p->size < 0)
			delete (struct dss__Event_ScheduleResponse*)p->ptr;
		else
			delete[] (struct dss__Event_ScheduleResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Schedule:
		if (p->size < 0)
			delete (struct dss__Event_Schedule*)p->ptr;
		else
			delete[] (struct dss__Event_Schedule*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		if (p->size < 0)
			delete (struct dss__Event_DeleteScheduleResponse*)p->ptr;
		else
			delete[] (struct dss__Event_DeleteScheduleResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		if (p->size < 0)
			delete (struct dss__Event_DeleteSchedule*)p->ptr;
		else
			delete[] (struct dss__Event_DeleteSchedule*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedInt(struct soap *soap, unsigned long *a)
{	soap_default_unsignedLong(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedInt(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (soap_out_xsd__unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void dss__outParameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->dss__outParameter::values = NULL;
	this->dss__outParameter::names = NULL;
}

void dss__outParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToStringArray(soap, &this->dss__outParameter::values);
	soap_serialize_PointerToStringArray(soap, &this->dss__outParameter::names);
}

int dss__outParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dss__outParameter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int dss__outParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dss__outParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__outParameter(struct soap *soap, const char *tag, int id, const dss__outParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__outParameter), type))
		return soap->error;
	if (soap_out_PointerToStringArray(soap, "values", -1, &(a->dss__outParameter::values), ""))
		return soap->error;
	if (soap_out_PointerToStringArray(soap, "names", -1, &(a->dss__outParameter::names), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dss__outParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dss__outParameter(soap, this, tag, type);
}

SOAP_FMAC3 dss__outParameter * SOAP_FMAC4 soap_get_dss__outParameter(struct soap *soap, dss__outParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__outParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *dss__outParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_dss__outParameter(soap, tag, this, type);
}

SOAP_FMAC3 dss__outParameter * SOAP_FMAC4 soap_in_dss__outParameter(struct soap *soap, const char *tag, dss__outParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dss__outParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__outParameter, sizeof(dss__outParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_dss__outParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (dss__outParameter *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_values1 = 1, soap_flag_names1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToStringArray(soap, "values", &(a->dss__outParameter::values), "xsd:string"))
				{	soap_flag_values1--;
					continue;
				}
			if (soap_flag_names1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToStringArray(soap, "names", &(a->dss__outParameter::names), "xsd:string"))
				{	soap_flag_names1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (dss__outParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__outParameter, 0, sizeof(dss__outParameter), 0, soap_copy_dss__outParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 dss__outParameter * SOAP_FMAC6 soap_new_dss__outParameter(struct soap *soap, int n)
{	return soap_instantiate_dss__outParameter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__outParameter(struct soap *soap, dss__outParameter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 dss__outParameter * SOAP_FMAC4 soap_instantiate_dss__outParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__outParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__outParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new dss__outParameter;
		if (size)
			*size = sizeof(dss__outParameter);
	}
	else
	{	cp->ptr = (void*)new dss__outParameter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(dss__outParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dss__outParameter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__outParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dss__outParameter %p -> %p\n", q, p));
	*(dss__outParameter*)p = *(dss__outParameter*)q;
}

void dss__inParameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->dss__inParameter::values = NULL;
	this->dss__inParameter::names = NULL;
}

void dss__inParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToStringArray(soap, &this->dss__inParameter::values);
	soap_serialize_PointerToStringArray(soap, &this->dss__inParameter::names);
}

int dss__inParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dss__inParameter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int dss__inParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dss__inParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__inParameter(struct soap *soap, const char *tag, int id, const dss__inParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__inParameter), type))
		return soap->error;
	if (soap_out_PointerToStringArray(soap, "values", -1, &(a->dss__inParameter::values), ""))
		return soap->error;
	if (soap_out_PointerToStringArray(soap, "names", -1, &(a->dss__inParameter::names), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dss__inParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dss__inParameter(soap, this, tag, type);
}

SOAP_FMAC3 dss__inParameter * SOAP_FMAC4 soap_get_dss__inParameter(struct soap *soap, dss__inParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__inParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *dss__inParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_dss__inParameter(soap, tag, this, type);
}

SOAP_FMAC3 dss__inParameter * SOAP_FMAC4 soap_in_dss__inParameter(struct soap *soap, const char *tag, dss__inParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dss__inParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__inParameter, sizeof(dss__inParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_dss__inParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (dss__inParameter *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_values1 = 1, soap_flag_names1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToStringArray(soap, "values", &(a->dss__inParameter::values), "xsd:string"))
				{	soap_flag_values1--;
					continue;
				}
			if (soap_flag_names1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToStringArray(soap, "names", &(a->dss__inParameter::names), "xsd:string"))
				{	soap_flag_names1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (dss__inParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__inParameter, 0, sizeof(dss__inParameter), 0, soap_copy_dss__inParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 dss__inParameter * SOAP_FMAC6 soap_new_dss__inParameter(struct soap *soap, int n)
{	return soap_instantiate_dss__inParameter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__inParameter(struct soap *soap, dss__inParameter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 dss__inParameter * SOAP_FMAC4 soap_instantiate_dss__inParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__inParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__inParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new dss__inParameter;
		if (size)
			*size = sizeof(dss__inParameter);
	}
	else
	{	cp->ptr = (void*)new dss__inParameter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(dss__inParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dss__inParameter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__inParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dss__inParameter %p -> %p\n", q, p));
	*(dss__inParameter*)p = *(dss__inParameter*)q;
}

void StringArray::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void StringArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_StringArray))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_string(soap, this->__ptr + i);
		}
}

int StringArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_StringArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int StringArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_StringArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_StringArray(struct soap *soap, const char *tag, int id, const StringArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_StringArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *StringArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_StringArray(soap, this, tag, type);
}

SOAP_FMAC3 StringArray * SOAP_FMAC4 soap_get_StringArray(struct soap *soap, StringArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_StringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *StringArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_StringArray(soap, tag, this, type);
}

SOAP_FMAC3 StringArray * SOAP_FMAC4 soap_in_StringArray(struct soap *soap, const char *tag, StringArray *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (StringArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_StringArray, sizeof(StringArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (StringArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_StringArray, 0, sizeof(StringArray), 0, soap_copy_StringArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 StringArray * SOAP_FMAC6 soap_new_StringArray(struct soap *soap, int n)
{	return soap_instantiate_StringArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_StringArray(struct soap *soap, StringArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 StringArray * SOAP_FMAC4 soap_instantiate_StringArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_StringArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_StringArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new StringArray;
		if (size)
			*size = sizeof(StringArray);
	}
	else
	{	cp->ptr = (void*)new StringArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(StringArray);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (StringArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_StringArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying StringArray %p -> %p\n", q, p));
	*(StringArray*)p = *(StringArray*)q;
}

void IntArray::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

void IntArray::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_IntArray))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_int);
		}
}

int IntArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_IntArray);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int IntArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_IntArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_IntArray(struct soap *soap, const char *tag, int id, const IntArray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:int", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_IntArray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_int(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *IntArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_IntArray(soap, this, tag, type);
}

SOAP_FMAC3 IntArray * SOAP_FMAC4 soap_get_IntArray(struct soap *soap, IntArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_IntArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *IntArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_IntArray(soap, tag, this, type);
}

SOAP_FMAC3 IntArray * SOAP_FMAC4 soap_in_IntArray(struct soap *soap, const char *tag, IntArray *a, const char *type)
{	int i, j;
	int *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (IntArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_IntArray, sizeof(IntArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (int *)soap_malloc(soap, sizeof(int) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_int(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_int(soap, NULL, a->__ptr + i, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (int *)soap_push_block(soap, sizeof(int));
				if (!p)
					return NULL;
				soap_default_int(soap, p);
				if (!soap_in_int(soap, NULL, p, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (int *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (IntArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_IntArray, 0, sizeof(IntArray), 0, soap_copy_IntArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 IntArray * SOAP_FMAC6 soap_new_IntArray(struct soap *soap, int n)
{	return soap_instantiate_IntArray(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_IntArray(struct soap *soap, IntArray *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 IntArray * SOAP_FMAC4 soap_instantiate_IntArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_IntArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_IntArray, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new IntArray;
		if (size)
			*size = sizeof(IntArray);
	}
	else
	{	cp->ptr = (void*)new IntArray[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(IntArray);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (IntArray*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_IntArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying IntArray %p -> %p\n", q, p));
	*(IntArray*)p = *(IntArray*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_DeleteSchedule(struct soap *soap, struct dss__Event_DeleteSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_scheduleEventID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_DeleteSchedule(struct soap *soap, const struct dss__Event_DeleteSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_scheduleEventID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_DeleteSchedule(struct soap *soap, const struct dss__Event_DeleteSchedule *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_DeleteSchedule);
	if (soap_out_dss__Event_DeleteSchedule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_DeleteSchedule(struct soap *soap, const char *tag, int id, const struct dss__Event_DeleteSchedule *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_DeleteSchedule), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "scheduleEventID", -1, &a->_scheduleEventID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_DeleteSchedule * SOAP_FMAC4 soap_get_dss__Event_DeleteSchedule(struct soap *soap, struct dss__Event_DeleteSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_DeleteSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_DeleteSchedule * SOAP_FMAC4 soap_in_dss__Event_DeleteSchedule(struct soap *soap, const char *tag, struct dss__Event_DeleteSchedule *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__scheduleEventID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_DeleteSchedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_DeleteSchedule, sizeof(struct dss__Event_DeleteSchedule), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_DeleteSchedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__scheduleEventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_scheduleEventID, "xsd:int"))
				{	soap_flag__scheduleEventID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_DeleteSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_DeleteSchedule, 0, sizeof(struct dss__Event_DeleteSchedule), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__scheduleEventID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_DeleteSchedule * SOAP_FMAC6 soap_new_dss__Event_DeleteSchedule(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_DeleteSchedule(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_DeleteSchedule(struct soap *soap, struct dss__Event_DeleteSchedule *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_DeleteSchedule * SOAP_FMAC4 soap_instantiate_dss__Event_DeleteSchedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_DeleteSchedule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_DeleteSchedule, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_DeleteSchedule;
		if (size)
			*size = sizeof(struct dss__Event_DeleteSchedule);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_DeleteSchedule[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_DeleteSchedule);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_DeleteSchedule*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_DeleteSchedule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_DeleteSchedule %p -> %p\n", q, p));
	*(struct dss__Event_DeleteSchedule*)p = *(struct dss__Event_DeleteSchedule*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_DeleteScheduleResponse(struct soap *soap, struct dss__Event_DeleteScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_DeleteScheduleResponse(struct soap *soap, const struct dss__Event_DeleteScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_DeleteScheduleResponse(struct soap *soap, const struct dss__Event_DeleteScheduleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_DeleteScheduleResponse);
	if (soap_out_dss__Event_DeleteScheduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_DeleteScheduleResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_DeleteScheduleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_DeleteScheduleResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC4 soap_get_dss__Event_DeleteScheduleResponse(struct soap *soap, struct dss__Event_DeleteScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_DeleteScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC4 soap_in_dss__Event_DeleteScheduleResponse(struct soap *soap, const char *tag, struct dss__Event_DeleteScheduleResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_DeleteScheduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_DeleteScheduleResponse, sizeof(struct dss__Event_DeleteScheduleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_DeleteScheduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_DeleteScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_DeleteScheduleResponse, 0, sizeof(struct dss__Event_DeleteScheduleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC6 soap_new_dss__Event_DeleteScheduleResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_DeleteScheduleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_DeleteScheduleResponse(struct soap *soap, struct dss__Event_DeleteScheduleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC4 soap_instantiate_dss__Event_DeleteScheduleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_DeleteScheduleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_DeleteScheduleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_DeleteScheduleResponse;
		if (size)
			*size = sizeof(struct dss__Event_DeleteScheduleResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_DeleteScheduleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_DeleteScheduleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_DeleteScheduleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_DeleteScheduleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_DeleteScheduleResponse %p -> %p\n", q, p));
	*(struct dss__Event_DeleteScheduleResponse*)p = *(struct dss__Event_DeleteScheduleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Schedule(struct soap *soap, struct dss__Event_Schedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_icalString);
	soap_default_int(soap, &a->_eventID);
	a->_params.dss__inParameter::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Schedule(struct soap *soap, const struct dss__Event_Schedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_icalString);
	soap_embedded(soap, &a->_eventID, SOAP_TYPE_int);
	a->_params.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Schedule(struct soap *soap, const struct dss__Event_Schedule *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Schedule);
	if (soap_out_dss__Event_Schedule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Schedule(struct soap *soap, const char *tag, int id, const struct dss__Event_Schedule *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Schedule), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "icalString", -1, &a->_icalString, ""))
		return soap->error;
	if (soap_out_int(soap, "eventID", -1, &a->_eventID, ""))
		return soap->error;
	if (a->_params.soap_out(soap, "params", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Schedule * SOAP_FMAC4 soap_get_dss__Event_Schedule(struct soap *soap, struct dss__Event_Schedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Schedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Schedule * SOAP_FMAC4 soap_in_dss__Event_Schedule(struct soap *soap, const char *tag, struct dss__Event_Schedule *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__icalString = 1, soap_flag__eventID = 1, soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Schedule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Schedule, sizeof(struct dss__Event_Schedule), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_Schedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__icalString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_icalString, "xsd:string"))
				{	soap_flag__icalString--;
					continue;
				}
			if (soap_flag__eventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_eventID, "xsd:int"))
				{	soap_flag__eventID--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (a->_params.soap_in(soap, NULL, "dss:inParameter"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Schedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Schedule, 0, sizeof(struct dss__Event_Schedule), 0, soap_copy_dss__Event_Schedule);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__eventID > 0 || soap_flag__params > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Schedule * SOAP_FMAC6 soap_new_dss__Event_Schedule(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Schedule(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Schedule(struct soap *soap, struct dss__Event_Schedule *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Schedule * SOAP_FMAC4 soap_instantiate_dss__Event_Schedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Schedule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Schedule, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Schedule;
		if (size)
			*size = sizeof(struct dss__Event_Schedule);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Schedule[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Schedule);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Schedule*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Schedule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Schedule %p -> %p\n", q, p));
	*(struct dss__Event_Schedule*)p = *(struct dss__Event_Schedule*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_ScheduleResponse(struct soap *soap, struct dss__Event_ScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->scheduledEventID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_ScheduleResponse(struct soap *soap, const struct dss__Event_ScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->scheduledEventID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_ScheduleResponse(struct soap *soap, const struct dss__Event_ScheduleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_ScheduleResponse);
	if (soap_out_dss__Event_ScheduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_ScheduleResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_ScheduleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_ScheduleResponse), type))
		return soap->error;
	if (soap_out_int(soap, "scheduledEventID", -1, &a->scheduledEventID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_ScheduleResponse * SOAP_FMAC4 soap_get_dss__Event_ScheduleResponse(struct soap *soap, struct dss__Event_ScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_ScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_ScheduleResponse * SOAP_FMAC4 soap_in_dss__Event_ScheduleResponse(struct soap *soap, const char *tag, struct dss__Event_ScheduleResponse *a, const char *type)
{
	short soap_flag_scheduledEventID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_ScheduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_ScheduleResponse, sizeof(struct dss__Event_ScheduleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_ScheduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_scheduledEventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scheduledEventID", &a->scheduledEventID, "xsd:int"))
				{	soap_flag_scheduledEventID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_ScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_ScheduleResponse, 0, sizeof(struct dss__Event_ScheduleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_scheduledEventID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_ScheduleResponse * SOAP_FMAC6 soap_new_dss__Event_ScheduleResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_ScheduleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_ScheduleResponse(struct soap *soap, struct dss__Event_ScheduleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_ScheduleResponse * SOAP_FMAC4 soap_instantiate_dss__Event_ScheduleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_ScheduleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_ScheduleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_ScheduleResponse;
		if (size)
			*size = sizeof(struct dss__Event_ScheduleResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_ScheduleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_ScheduleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_ScheduleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_ScheduleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_ScheduleResponse %p -> %p\n", q, p));
	*(struct dss__Event_ScheduleResponse*)p = *(struct dss__Event_ScheduleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Unsubscribe(struct soap *soap, struct dss__Event_Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_subscriptionID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Unsubscribe(struct soap *soap, const struct dss__Event_Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_subscriptionID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Unsubscribe(struct soap *soap, const struct dss__Event_Unsubscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Unsubscribe);
	if (soap_out_dss__Event_Unsubscribe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Unsubscribe(struct soap *soap, const char *tag, int id, const struct dss__Event_Unsubscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Unsubscribe), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "subscriptionID", -1, &a->_subscriptionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Unsubscribe * SOAP_FMAC4 soap_get_dss__Event_Unsubscribe(struct soap *soap, struct dss__Event_Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Unsubscribe * SOAP_FMAC4 soap_in_dss__Event_Unsubscribe(struct soap *soap, const char *tag, struct dss__Event_Unsubscribe *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__subscriptionID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Unsubscribe, sizeof(struct dss__Event_Unsubscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_Unsubscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__subscriptionID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_subscriptionID, "xsd:int"))
				{	soap_flag__subscriptionID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Unsubscribe, 0, sizeof(struct dss__Event_Unsubscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__subscriptionID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Unsubscribe * SOAP_FMAC6 soap_new_dss__Event_Unsubscribe(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Unsubscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Unsubscribe(struct soap *soap, struct dss__Event_Unsubscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Unsubscribe * SOAP_FMAC4 soap_instantiate_dss__Event_Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Unsubscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Unsubscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Unsubscribe;
		if (size)
			*size = sizeof(struct dss__Event_Unsubscribe);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Unsubscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Unsubscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Unsubscribe*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Unsubscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Unsubscribe %p -> %p\n", q, p));
	*(struct dss__Event_Unsubscribe*)p = *(struct dss__Event_Unsubscribe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_UnsubscribeResponse(struct soap *soap, struct dss__Event_UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_UnsubscribeResponse(struct soap *soap, const struct dss__Event_UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_UnsubscribeResponse(struct soap *soap, const struct dss__Event_UnsubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_UnsubscribeResponse);
	if (soap_out_dss__Event_UnsubscribeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_UnsubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_UnsubscribeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_UnsubscribeResponse * SOAP_FMAC4 soap_get_dss__Event_UnsubscribeResponse(struct soap *soap, struct dss__Event_UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_UnsubscribeResponse * SOAP_FMAC4 soap_in_dss__Event_UnsubscribeResponse(struct soap *soap, const char *tag, struct dss__Event_UnsubscribeResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_UnsubscribeResponse, sizeof(struct dss__Event_UnsubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_UnsubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_UnsubscribeResponse, 0, sizeof(struct dss__Event_UnsubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_UnsubscribeResponse * SOAP_FMAC6 soap_new_dss__Event_UnsubscribeResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_UnsubscribeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_UnsubscribeResponse(struct soap *soap, struct dss__Event_UnsubscribeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_UnsubscribeResponse * SOAP_FMAC4 soap_instantiate_dss__Event_UnsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_UnsubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_UnsubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_UnsubscribeResponse;
		if (size)
			*size = sizeof(struct dss__Event_UnsubscribeResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_UnsubscribeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_UnsubscribeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_UnsubscribeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_UnsubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_UnsubscribeResponse %p -> %p\n", q, p));
	*(struct dss__Event_UnsubscribeResponse*)p = *(struct dss__Event_UnsubscribeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Subscribe(struct soap *soap, struct dss__Event_Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	a->_eventIDs.IntArray::soap_default(soap);
	a->_sourceIDs.IntArray::soap_default(soap);
	soap_default_string(soap, &a->_actionName);
	a->_params.dss__inParameter::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Subscribe(struct soap *soap, const struct dss__Event_Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	a->_eventIDs.soap_serialize(soap);
	a->_sourceIDs.soap_serialize(soap);
	soap_serialize_string(soap, &a->_actionName);
	a->_params.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Subscribe(struct soap *soap, const struct dss__Event_Subscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Subscribe);
	if (soap_out_dss__Event_Subscribe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Subscribe(struct soap *soap, const char *tag, int id, const struct dss__Event_Subscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Subscribe), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (a->_eventIDs.soap_out(soap, "eventIDs", -1, ""))
		return soap->error;
	if (a->_sourceIDs.soap_out(soap, "sourceIDs", -1, ""))
		return soap->error;
	if (soap_out_string(soap, "actionName", -1, &a->_actionName, ""))
		return soap->error;
	if (a->_params.soap_out(soap, "params", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Subscribe * SOAP_FMAC4 soap_get_dss__Event_Subscribe(struct soap *soap, struct dss__Event_Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Subscribe * SOAP_FMAC4 soap_in_dss__Event_Subscribe(struct soap *soap, const char *tag, struct dss__Event_Subscribe *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__eventIDs = 1, soap_flag__sourceIDs = 1, soap_flag__actionName = 1, soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Subscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Subscribe, sizeof(struct dss__Event_Subscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_Subscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__eventIDs && soap->error == SOAP_TAG_MISMATCH)
				if (a->_eventIDs.soap_in(soap, NULL, "xsd:int"))
				{	soap_flag__eventIDs--;
					continue;
				}
			if (soap_flag__sourceIDs && soap->error == SOAP_TAG_MISMATCH)
				if (a->_sourceIDs.soap_in(soap, NULL, "xsd:int"))
				{	soap_flag__sourceIDs--;
					continue;
				}
			if (soap_flag__actionName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_actionName, "xsd:string"))
				{	soap_flag__actionName--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (a->_params.soap_in(soap, NULL, "dss:inParameter"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Subscribe, 0, sizeof(struct dss__Event_Subscribe), 0, soap_copy_dss__Event_Subscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__eventIDs > 0 || soap_flag__sourceIDs > 0 || soap_flag__params > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Subscribe * SOAP_FMAC6 soap_new_dss__Event_Subscribe(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Subscribe(struct soap *soap, struct dss__Event_Subscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Subscribe * SOAP_FMAC4 soap_instantiate_dss__Event_Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Subscribe;
		if (size)
			*size = sizeof(struct dss__Event_Subscribe);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Subscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Subscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Subscribe*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Subscribe %p -> %p\n", q, p));
	*(struct dss__Event_Subscribe*)p = *(struct dss__Event_Subscribe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_SubscribeResponse(struct soap *soap, struct dss__Event_SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->subscriptionID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_SubscribeResponse(struct soap *soap, const struct dss__Event_SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->subscriptionID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_SubscribeResponse(struct soap *soap, const struct dss__Event_SubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_SubscribeResponse);
	if (soap_out_dss__Event_SubscribeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_SubscribeResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_SubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_SubscribeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "subscriptionID", -1, &a->subscriptionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_SubscribeResponse * SOAP_FMAC4 soap_get_dss__Event_SubscribeResponse(struct soap *soap, struct dss__Event_SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_SubscribeResponse * SOAP_FMAC4 soap_in_dss__Event_SubscribeResponse(struct soap *soap, const char *tag, struct dss__Event_SubscribeResponse *a, const char *type)
{
	short soap_flag_subscriptionID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_SubscribeResponse, sizeof(struct dss__Event_SubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_SubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_subscriptionID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "subscriptionID", &a->subscriptionID, "xsd:int"))
				{	soap_flag_subscriptionID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_SubscribeResponse, 0, sizeof(struct dss__Event_SubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subscriptionID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_SubscribeResponse * SOAP_FMAC6 soap_new_dss__Event_SubscribeResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_SubscribeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_SubscribeResponse(struct soap *soap, struct dss__Event_SubscribeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_SubscribeResponse * SOAP_FMAC4 soap_instantiate_dss__Event_SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_SubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_SubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_SubscribeResponse;
		if (size)
			*size = sizeof(struct dss__Event_SubscribeResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_SubscribeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_SubscribeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_SubscribeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_SubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_SubscribeResponse %p -> %p\n", q, p));
	*(struct dss__Event_SubscribeResponse*)p = *(struct dss__Event_SubscribeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_GetActionParamsTemplate(struct soap *soap, struct dss__Event_GetActionParamsTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_GetActionParamsTemplate(struct soap *soap, const struct dss__Event_GetActionParamsTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_GetActionParamsTemplate(struct soap *soap, const struct dss__Event_GetActionParamsTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_GetActionParamsTemplate);
	if (soap_out_dss__Event_GetActionParamsTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_GetActionParamsTemplate(struct soap *soap, const char *tag, int id, const struct dss__Event_GetActionParamsTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_GetActionParamsTemplate), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC4 soap_get_dss__Event_GetActionParamsTemplate(struct soap *soap, struct dss__Event_GetActionParamsTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_GetActionParamsTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC4 soap_in_dss__Event_GetActionParamsTemplate(struct soap *soap, const char *tag, struct dss__Event_GetActionParamsTemplate *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_GetActionParamsTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_GetActionParamsTemplate, sizeof(struct dss__Event_GetActionParamsTemplate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_GetActionParamsTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_GetActionParamsTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_GetActionParamsTemplate, 0, sizeof(struct dss__Event_GetActionParamsTemplate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC6 soap_new_dss__Event_GetActionParamsTemplate(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_GetActionParamsTemplate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_GetActionParamsTemplate(struct soap *soap, struct dss__Event_GetActionParamsTemplate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC4 soap_instantiate_dss__Event_GetActionParamsTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_GetActionParamsTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_GetActionParamsTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_GetActionParamsTemplate;
		if (size)
			*size = sizeof(struct dss__Event_GetActionParamsTemplate);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_GetActionParamsTemplate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_GetActionParamsTemplate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_GetActionParamsTemplate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_GetActionParamsTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_GetActionParamsTemplate %p -> %p\n", q, p));
	*(struct dss__Event_GetActionParamsTemplate*)p = *(struct dss__Event_GetActionParamsTemplate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_GetActionNames(struct soap *soap, struct dss__Event_GetActionNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_GetActionNames(struct soap *soap, const struct dss__Event_GetActionNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_GetActionNames(struct soap *soap, const struct dss__Event_GetActionNames *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_GetActionNames);
	if (soap_out_dss__Event_GetActionNames(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_GetActionNames(struct soap *soap, const char *tag, int id, const struct dss__Event_GetActionNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_GetActionNames), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_GetActionNames * SOAP_FMAC4 soap_get_dss__Event_GetActionNames(struct soap *soap, struct dss__Event_GetActionNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_GetActionNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_GetActionNames * SOAP_FMAC4 soap_in_dss__Event_GetActionNames(struct soap *soap, const char *tag, struct dss__Event_GetActionNames *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_GetActionNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_GetActionNames, sizeof(struct dss__Event_GetActionNames), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_GetActionNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_GetActionNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_GetActionNames, 0, sizeof(struct dss__Event_GetActionNames), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_GetActionNames * SOAP_FMAC6 soap_new_dss__Event_GetActionNames(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_GetActionNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_GetActionNames(struct soap *soap, struct dss__Event_GetActionNames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_GetActionNames * SOAP_FMAC4 soap_instantiate_dss__Event_GetActionNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_GetActionNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_GetActionNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_GetActionNames;
		if (size)
			*size = sizeof(struct dss__Event_GetActionNames);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_GetActionNames[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_GetActionNames);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_GetActionNames*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_GetActionNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_GetActionNames %p -> %p\n", q, p));
	*(struct dss__Event_GetActionNames*)p = *(struct dss__Event_GetActionNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_GetActionNamesResponse(struct soap *soap, struct dss__Event_GetActionNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->names.StringArray::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_GetActionNamesResponse(struct soap *soap, const struct dss__Event_GetActionNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->names, SOAP_TYPE_StringArray);
	a->names.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_GetActionNamesResponse(struct soap *soap, const struct dss__Event_GetActionNamesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_GetActionNamesResponse);
	if (soap_out_dss__Event_GetActionNamesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_GetActionNamesResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_GetActionNamesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_GetActionNamesResponse), type))
		return soap->error;
	if (a->names.soap_out(soap, "names", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_GetActionNamesResponse * SOAP_FMAC4 soap_get_dss__Event_GetActionNamesResponse(struct soap *soap, struct dss__Event_GetActionNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_GetActionNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_GetActionNamesResponse * SOAP_FMAC4 soap_in_dss__Event_GetActionNamesResponse(struct soap *soap, const char *tag, struct dss__Event_GetActionNamesResponse *a, const char *type)
{
	short soap_flag_names = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_GetActionNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_GetActionNamesResponse, sizeof(struct dss__Event_GetActionNamesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_GetActionNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_names && soap->error == SOAP_TAG_MISMATCH)
				if (a->names.soap_in(soap, "names", "xsd:string"))
				{	soap_flag_names--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_GetActionNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_GetActionNamesResponse, 0, sizeof(struct dss__Event_GetActionNamesResponse), 0, soap_copy_dss__Event_GetActionNamesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_names > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_GetActionNamesResponse * SOAP_FMAC6 soap_new_dss__Event_GetActionNamesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_GetActionNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_GetActionNamesResponse(struct soap *soap, struct dss__Event_GetActionNamesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_GetActionNamesResponse * SOAP_FMAC4 soap_instantiate_dss__Event_GetActionNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_GetActionNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_GetActionNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_GetActionNamesResponse;
		if (size)
			*size = sizeof(struct dss__Event_GetActionNamesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_GetActionNamesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_GetActionNamesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_GetActionNamesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_GetActionNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_GetActionNamesResponse %p -> %p\n", q, p));
	*(struct dss__Event_GetActionNamesResponse*)p = *(struct dss__Event_GetActionNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Raise(struct soap *soap, struct dss__Event_Raise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_eventID);
	soap_default_int(soap, &a->_sourceID);
	a->_params.dss__inParameter::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Raise(struct soap *soap, const struct dss__Event_Raise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_eventID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_sourceID, SOAP_TYPE_int);
	a->_params.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Raise(struct soap *soap, const struct dss__Event_Raise *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Raise);
	if (soap_out_dss__Event_Raise(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Raise(struct soap *soap, const char *tag, int id, const struct dss__Event_Raise *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Raise), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "eventID", -1, &a->_eventID, ""))
		return soap->error;
	if (soap_out_int(soap, "sourceID", -1, &a->_sourceID, ""))
		return soap->error;
	if (a->_params.soap_out(soap, "params", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Raise * SOAP_FMAC4 soap_get_dss__Event_Raise(struct soap *soap, struct dss__Event_Raise *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Raise(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Raise * SOAP_FMAC4 soap_in_dss__Event_Raise(struct soap *soap, const char *tag, struct dss__Event_Raise *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__eventID = 1, soap_flag__sourceID = 1, soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Raise *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Raise, sizeof(struct dss__Event_Raise), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_Raise(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__eventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_eventID, "xsd:int"))
				{	soap_flag__eventID--;
					continue;
				}
			if (soap_flag__sourceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sourceID, "xsd:int"))
				{	soap_flag__sourceID--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (a->_params.soap_in(soap, NULL, "dss:inParameter"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Raise *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Raise, 0, sizeof(struct dss__Event_Raise), 0, soap_copy_dss__Event_Raise);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__eventID > 0 || soap_flag__sourceID > 0 || soap_flag__params > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Raise * SOAP_FMAC6 soap_new_dss__Event_Raise(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Raise(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Raise(struct soap *soap, struct dss__Event_Raise *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Raise * SOAP_FMAC4 soap_instantiate_dss__Event_Raise(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Raise(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Raise, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Raise;
		if (size)
			*size = sizeof(struct dss__Event_Raise);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Raise[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Raise);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Raise*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Raise(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Raise %p -> %p\n", q, p));
	*(struct dss__Event_Raise*)p = *(struct dss__Event_Raise*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_RaiseResponse(struct soap *soap, struct dss__Event_RaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_RaiseResponse(struct soap *soap, const struct dss__Event_RaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_RaiseResponse(struct soap *soap, const struct dss__Event_RaiseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_RaiseResponse);
	if (soap_out_dss__Event_RaiseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_RaiseResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_RaiseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_RaiseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_RaiseResponse * SOAP_FMAC4 soap_get_dss__Event_RaiseResponse(struct soap *soap, struct dss__Event_RaiseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_RaiseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_RaiseResponse * SOAP_FMAC4 soap_in_dss__Event_RaiseResponse(struct soap *soap, const char *tag, struct dss__Event_RaiseResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_RaiseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_RaiseResponse, sizeof(struct dss__Event_RaiseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_RaiseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_RaiseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_RaiseResponse, 0, sizeof(struct dss__Event_RaiseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_RaiseResponse * SOAP_FMAC6 soap_new_dss__Event_RaiseResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_RaiseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_RaiseResponse(struct soap *soap, struct dss__Event_RaiseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_RaiseResponse * SOAP_FMAC4 soap_instantiate_dss__Event_RaiseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_RaiseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_RaiseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_RaiseResponse;
		if (size)
			*size = sizeof(struct dss__Event_RaiseResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_RaiseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_RaiseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_RaiseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_RaiseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_RaiseResponse %p -> %p\n", q, p));
	*(struct dss__Event_RaiseResponse*)p = *(struct dss__Event_RaiseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveDevice(struct soap *soap, struct dss__Group_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveDevice(struct soap *soap, const struct dss__Group_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_groupID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveDevice(struct soap *soap, const struct dss__Group_RemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveDevice);
	if (soap_out_dss__Group_RemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveDevice * SOAP_FMAC4 soap_get_dss__Group_RemoveDevice(struct soap *soap, struct dss__Group_RemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveDevice * SOAP_FMAC4 soap_in_dss__Group_RemoveDevice(struct soap *soap, const char *tag, struct dss__Group_RemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveDevice, sizeof(struct dss__Group_RemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveDevice, 0, sizeof(struct dss__Group_RemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveDevice * SOAP_FMAC6 soap_new_dss__Group_RemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveDevice(struct soap *soap, struct dss__Group_RemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveDevice * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveDevice;
		if (size)
			*size = sizeof(struct dss__Group_RemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveDevice %p -> %p\n", q, p));
	*(struct dss__Group_RemoveDevice*)p = *(struct dss__Group_RemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveDeviceResponse(struct soap *soap, struct dss__Group_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveDeviceResponse(struct soap *soap, const struct dss__Group_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveDeviceResponse(struct soap *soap, const struct dss__Group_RemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveDeviceResponse);
	if (soap_out_dss__Group_RemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__Group_RemoveDeviceResponse(struct soap *soap, struct dss__Group_RemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__Group_RemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__Group_RemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveDeviceResponse, sizeof(struct dss__Group_RemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveDeviceResponse, 0, sizeof(struct dss__Group_RemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__Group_RemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveDeviceResponse(struct soap *soap, struct dss__Group_RemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Group_RemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Group_RemoveDeviceResponse*)p = *(struct dss__Group_RemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_AddDevice(struct soap *soap, struct dss__Group_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_AddDevice(struct soap *soap, const struct dss__Group_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_groupID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_AddDevice(struct soap *soap, const struct dss__Group_AddDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_AddDevice);
	if (soap_out_dss__Group_AddDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_AddDevice(struct soap *soap, const char *tag, int id, const struct dss__Group_AddDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_AddDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_AddDevice * SOAP_FMAC4 soap_get_dss__Group_AddDevice(struct soap *soap, struct dss__Group_AddDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_AddDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_AddDevice * SOAP_FMAC4 soap_in_dss__Group_AddDevice(struct soap *soap, const char *tag, struct dss__Group_AddDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_AddDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_AddDevice, sizeof(struct dss__Group_AddDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_AddDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_AddDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_AddDevice, 0, sizeof(struct dss__Group_AddDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_AddDevice * SOAP_FMAC6 soap_new_dss__Group_AddDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_AddDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_AddDevice(struct soap *soap, struct dss__Group_AddDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_AddDevice * SOAP_FMAC4 soap_instantiate_dss__Group_AddDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_AddDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_AddDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_AddDevice;
		if (size)
			*size = sizeof(struct dss__Group_AddDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_AddDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_AddDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_AddDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_AddDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_AddDevice %p -> %p\n", q, p));
	*(struct dss__Group_AddDevice*)p = *(struct dss__Group_AddDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_AddDeviceResponse(struct soap *soap, struct dss__Group_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_AddDeviceResponse(struct soap *soap, const struct dss__Group_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_AddDeviceResponse(struct soap *soap, const struct dss__Group_AddDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_AddDeviceResponse);
	if (soap_out_dss__Group_AddDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_AddDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_AddDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_AddDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_AddDeviceResponse * SOAP_FMAC4 soap_get_dss__Group_AddDeviceResponse(struct soap *soap, struct dss__Group_AddDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_AddDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_AddDeviceResponse * SOAP_FMAC4 soap_in_dss__Group_AddDeviceResponse(struct soap *soap, const char *tag, struct dss__Group_AddDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_AddDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_AddDeviceResponse, sizeof(struct dss__Group_AddDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_AddDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_AddDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_AddDeviceResponse, 0, sizeof(struct dss__Group_AddDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_AddDeviceResponse * SOAP_FMAC6 soap_new_dss__Group_AddDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_AddDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_AddDeviceResponse(struct soap *soap, struct dss__Group_AddDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_AddDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Group_AddDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_AddDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_AddDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_AddDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Group_AddDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_AddDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_AddDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_AddDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_AddDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_AddDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Group_AddDeviceResponse*)p = *(struct dss__Group_AddDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveUserGroup(struct soap *soap, struct dss__Group_RemoveUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveUserGroup(struct soap *soap, const struct dss__Group_RemoveUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_groupID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveUserGroup(struct soap *soap, const struct dss__Group_RemoveUserGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveUserGroup);
	if (soap_out_dss__Group_RemoveUserGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveUserGroup(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveUserGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveUserGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroup * SOAP_FMAC4 soap_get_dss__Group_RemoveUserGroup(struct soap *soap, struct dss__Group_RemoveUserGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveUserGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroup * SOAP_FMAC4 soap_in_dss__Group_RemoveUserGroup(struct soap *soap, const char *tag, struct dss__Group_RemoveUserGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveUserGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveUserGroup, sizeof(struct dss__Group_RemoveUserGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveUserGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveUserGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveUserGroup, 0, sizeof(struct dss__Group_RemoveUserGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveUserGroup * SOAP_FMAC6 soap_new_dss__Group_RemoveUserGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveUserGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveUserGroup(struct soap *soap, struct dss__Group_RemoveUserGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroup * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveUserGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveUserGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveUserGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroup;
		if (size)
			*size = sizeof(struct dss__Group_RemoveUserGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveUserGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveUserGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveUserGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveUserGroup %p -> %p\n", q, p));
	*(struct dss__Group_RemoveUserGroup*)p = *(struct dss__Group_RemoveUserGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveUserGroupResponse(struct soap *soap, struct dss__Group_RemoveUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveUserGroupResponse(struct soap *soap, const struct dss__Group_RemoveUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveUserGroupResponse(struct soap *soap, const struct dss__Group_RemoveUserGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveUserGroupResponse);
	if (soap_out_dss__Group_RemoveUserGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveUserGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveUserGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveUserGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC4 soap_get_dss__Group_RemoveUserGroupResponse(struct soap *soap, struct dss__Group_RemoveUserGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveUserGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC4 soap_in_dss__Group_RemoveUserGroupResponse(struct soap *soap, const char *tag, struct dss__Group_RemoveUserGroupResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveUserGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveUserGroupResponse, sizeof(struct dss__Group_RemoveUserGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveUserGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveUserGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveUserGroupResponse, 0, sizeof(struct dss__Group_RemoveUserGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC6 soap_new_dss__Group_RemoveUserGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveUserGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveUserGroupResponse(struct soap *soap, struct dss__Group_RemoveUserGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveUserGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveUserGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveUserGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroupResponse;
		if (size)
			*size = sizeof(struct dss__Group_RemoveUserGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveUserGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveUserGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveUserGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveUserGroupResponse %p -> %p\n", q, p));
	*(struct dss__Group_RemoveUserGroupResponse*)p = *(struct dss__Group_RemoveUserGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateUserGroup(struct soap *soap, struct dss__Apartment_AllocateUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateUserGroup(struct soap *soap, const struct dss__Apartment_AllocateUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateUserGroup(struct soap *soap, const struct dss__Apartment_AllocateUserGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateUserGroup);
	if (soap_out_dss__Apartment_AllocateUserGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateUserGroup(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateUserGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC4 soap_get_dss__Apartment_AllocateUserGroup(struct soap *soap, struct dss__Apartment_AllocateUserGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateUserGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC4 soap_in_dss__Apartment_AllocateUserGroup(struct soap *soap, const char *tag, struct dss__Apartment_AllocateUserGroup *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateUserGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroup, sizeof(struct dss__Apartment_AllocateUserGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateUserGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateUserGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateUserGroup, 0, sizeof(struct dss__Apartment_AllocateUserGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC6 soap_new_dss__Apartment_AllocateUserGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateUserGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateUserGroup(struct soap *soap, struct dss__Apartment_AllocateUserGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateUserGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateUserGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateUserGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroup;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateUserGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateUserGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateUserGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateUserGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateUserGroup %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateUserGroup*)p = *(struct dss__Apartment_AllocateUserGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, struct dss__Apartment_AllocateUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const struct dss__Apartment_AllocateUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->groupID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const struct dss__Apartment_AllocateUserGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse);
	if (soap_out_dss__Apartment_AllocateUserGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateUserGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC4 soap_get_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, struct dss__Apartment_AllocateUserGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateUserGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC4 soap_in_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const char *tag, struct dss__Apartment_AllocateUserGroupResponse *a, const char *type)
{
	short soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateUserGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse, sizeof(struct dss__Apartment_AllocateUserGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateUserGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupID", &a->groupID, "xsd:int"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateUserGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse, 0, sizeof(struct dss__Apartment_AllocateUserGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC6 soap_new_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateUserGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, struct dss__Apartment_AllocateUserGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateUserGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroupResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateUserGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateUserGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateUserGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateUserGroupResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateUserGroupResponse*)p = *(struct dss__Apartment_AllocateUserGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Room_SetName(struct soap *soap, struct dss__Room_SetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_roomID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Room_SetName(struct soap *soap, const struct dss__Room_SetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_roomID, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Room_SetName(struct soap *soap, const struct dss__Room_SetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Room_SetName);
	if (soap_out_dss__Room_SetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Room_SetName(struct soap *soap, const char *tag, int id, const struct dss__Room_SetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Room_SetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "roomID", -1, &a->_roomID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Room_SetName * SOAP_FMAC4 soap_get_dss__Room_SetName(struct soap *soap, struct dss__Room_SetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Room_SetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Room_SetName * SOAP_FMAC4 soap_in_dss__Room_SetName(struct soap *soap, const char *tag, struct dss__Room_SetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__roomID = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Room_SetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Room_SetName, sizeof(struct dss__Room_SetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Room_SetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__roomID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_roomID, "xsd:int"))
				{	soap_flag__roomID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Room_SetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Room_SetName, 0, sizeof(struct dss__Room_SetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__roomID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Room_SetName * SOAP_FMAC6 soap_new_dss__Room_SetName(struct soap *soap, int n)
{	return soap_instantiate_dss__Room_SetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Room_SetName(struct soap *soap, struct dss__Room_SetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Room_SetName * SOAP_FMAC4 soap_instantiate_dss__Room_SetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Room_SetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Room_SetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Room_SetName;
		if (size)
			*size = sizeof(struct dss__Room_SetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Room_SetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Room_SetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Room_SetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Room_SetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Room_SetName %p -> %p\n", q, p));
	*(struct dss__Room_SetName*)p = *(struct dss__Room_SetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Room_SetNameResponse(struct soap *soap, struct dss__Room_SetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Room_SetNameResponse(struct soap *soap, const struct dss__Room_SetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Room_SetNameResponse(struct soap *soap, const struct dss__Room_SetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Room_SetNameResponse);
	if (soap_out_dss__Room_SetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Room_SetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Room_SetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Room_SetNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Room_SetNameResponse * SOAP_FMAC4 soap_get_dss__Room_SetNameResponse(struct soap *soap, struct dss__Room_SetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Room_SetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Room_SetNameResponse * SOAP_FMAC4 soap_in_dss__Room_SetNameResponse(struct soap *soap, const char *tag, struct dss__Room_SetNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Room_SetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Room_SetNameResponse, sizeof(struct dss__Room_SetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Room_SetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Room_SetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Room_SetNameResponse, 0, sizeof(struct dss__Room_SetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Room_SetNameResponse * SOAP_FMAC6 soap_new_dss__Room_SetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Room_SetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Room_SetNameResponse(struct soap *soap, struct dss__Room_SetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Room_SetNameResponse * SOAP_FMAC4 soap_instantiate_dss__Room_SetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Room_SetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Room_SetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Room_SetNameResponse;
		if (size)
			*size = sizeof(struct dss__Room_SetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Room_SetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Room_SetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Room_SetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Room_SetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Room_SetNameResponse %p -> %p\n", q, p));
	*(struct dss__Room_SetNameResponse*)p = *(struct dss__Room_SetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Room_RemoveDevice(struct soap *soap, struct dss__Room_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_roomID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Room_RemoveDevice(struct soap *soap, const struct dss__Room_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_roomID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Room_RemoveDevice(struct soap *soap, const struct dss__Room_RemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Room_RemoveDevice);
	if (soap_out_dss__Room_RemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Room_RemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__Room_RemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Room_RemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "roomID", -1, &a->_roomID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Room_RemoveDevice * SOAP_FMAC4 soap_get_dss__Room_RemoveDevice(struct soap *soap, struct dss__Room_RemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Room_RemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Room_RemoveDevice * SOAP_FMAC4 soap_in_dss__Room_RemoveDevice(struct soap *soap, const char *tag, struct dss__Room_RemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__roomID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Room_RemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Room_RemoveDevice, sizeof(struct dss__Room_RemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Room_RemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__roomID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_roomID, "xsd:int"))
				{	soap_flag__roomID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Room_RemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Room_RemoveDevice, 0, sizeof(struct dss__Room_RemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__roomID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Room_RemoveDevice * SOAP_FMAC6 soap_new_dss__Room_RemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Room_RemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Room_RemoveDevice(struct soap *soap, struct dss__Room_RemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Room_RemoveDevice * SOAP_FMAC4 soap_instantiate_dss__Room_RemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Room_RemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Room_RemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Room_RemoveDevice;
		if (size)
			*size = sizeof(struct dss__Room_RemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Room_RemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Room_RemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Room_RemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Room_RemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Room_RemoveDevice %p -> %p\n", q, p));
	*(struct dss__Room_RemoveDevice*)p = *(struct dss__Room_RemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Room_RemoveDeviceResponse(struct soap *soap, struct dss__Room_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Room_RemoveDeviceResponse(struct soap *soap, const struct dss__Room_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Room_RemoveDeviceResponse(struct soap *soap, const struct dss__Room_RemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Room_RemoveDeviceResponse);
	if (soap_out_dss__Room_RemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Room_RemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Room_RemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Room_RemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Room_RemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__Room_RemoveDeviceResponse(struct soap *soap, struct dss__Room_RemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Room_RemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Room_RemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__Room_RemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__Room_RemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Room_RemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Room_RemoveDeviceResponse, sizeof(struct dss__Room_RemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Room_RemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Room_RemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Room_RemoveDeviceResponse, 0, sizeof(struct dss__Room_RemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Room_RemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__Room_RemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Room_RemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Room_RemoveDeviceResponse(struct soap *soap, struct dss__Room_RemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Room_RemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Room_RemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Room_RemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Room_RemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Room_RemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Room_RemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Room_RemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Room_RemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Room_RemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Room_RemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Room_RemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Room_RemoveDeviceResponse*)p = *(struct dss__Room_RemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Room_AddDevice(struct soap *soap, struct dss__Room_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_roomID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Room_AddDevice(struct soap *soap, const struct dss__Room_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_roomID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Room_AddDevice(struct soap *soap, const struct dss__Room_AddDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Room_AddDevice);
	if (soap_out_dss__Room_AddDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Room_AddDevice(struct soap *soap, const char *tag, int id, const struct dss__Room_AddDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Room_AddDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "roomID", -1, &a->_roomID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Room_AddDevice * SOAP_FMAC4 soap_get_dss__Room_AddDevice(struct soap *soap, struct dss__Room_AddDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Room_AddDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Room_AddDevice * SOAP_FMAC4 soap_in_dss__Room_AddDevice(struct soap *soap, const char *tag, struct dss__Room_AddDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__roomID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Room_AddDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Room_AddDevice, sizeof(struct dss__Room_AddDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Room_AddDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__roomID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_roomID, "xsd:int"))
				{	soap_flag__roomID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Room_AddDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Room_AddDevice, 0, sizeof(struct dss__Room_AddDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__roomID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Room_AddDevice * SOAP_FMAC6 soap_new_dss__Room_AddDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Room_AddDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Room_AddDevice(struct soap *soap, struct dss__Room_AddDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Room_AddDevice * SOAP_FMAC4 soap_instantiate_dss__Room_AddDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Room_AddDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Room_AddDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Room_AddDevice;
		if (size)
			*size = sizeof(struct dss__Room_AddDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Room_AddDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Room_AddDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Room_AddDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Room_AddDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Room_AddDevice %p -> %p\n", q, p));
	*(struct dss__Room_AddDevice*)p = *(struct dss__Room_AddDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Room_AddDeviceResponse(struct soap *soap, struct dss__Room_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Room_AddDeviceResponse(struct soap *soap, const struct dss__Room_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Room_AddDeviceResponse(struct soap *soap, const struct dss__Room_AddDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Room_AddDeviceResponse);
	if (soap_out_dss__Room_AddDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Room_AddDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Room_AddDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Room_AddDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Room_AddDeviceResponse * SOAP_FMAC4 soap_get_dss__Room_AddDeviceResponse(struct soap *soap, struct dss__Room_AddDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Room_AddDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Room_AddDeviceResponse * SOAP_FMAC4 soap_in_dss__Room_AddDeviceResponse(struct soap *soap, const char *tag, struct dss__Room_AddDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Room_AddDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Room_AddDeviceResponse, sizeof(struct dss__Room_AddDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Room_AddDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Room_AddDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Room_AddDeviceResponse, 0, sizeof(struct dss__Room_AddDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Room_AddDeviceResponse * SOAP_FMAC6 soap_new_dss__Room_AddDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Room_AddDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Room_AddDeviceResponse(struct soap *soap, struct dss__Room_AddDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Room_AddDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Room_AddDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Room_AddDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Room_AddDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Room_AddDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Room_AddDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Room_AddDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Room_AddDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Room_AddDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Room_AddDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Room_AddDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Room_AddDeviceResponse*)p = *(struct dss__Room_AddDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_DeleteRoom(struct soap *soap, struct dss__Apartment_DeleteRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_roomID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_DeleteRoom(struct soap *soap, const struct dss__Apartment_DeleteRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_roomID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_DeleteRoom(struct soap *soap, const struct dss__Apartment_DeleteRoom *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_DeleteRoom);
	if (soap_out_dss__Apartment_DeleteRoom(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_DeleteRoom(struct soap *soap, const char *tag, int id, const struct dss__Apartment_DeleteRoom *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_DeleteRoom), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "roomID", -1, &a->_roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_DeleteRoom * SOAP_FMAC4 soap_get_dss__Apartment_DeleteRoom(struct soap *soap, struct dss__Apartment_DeleteRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_DeleteRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_DeleteRoom * SOAP_FMAC4 soap_in_dss__Apartment_DeleteRoom(struct soap *soap, const char *tag, struct dss__Apartment_DeleteRoom *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__roomID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_DeleteRoom *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_DeleteRoom, sizeof(struct dss__Apartment_DeleteRoom), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_DeleteRoom(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__roomID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_roomID, "xsd:int"))
				{	soap_flag__roomID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_DeleteRoom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_DeleteRoom, 0, sizeof(struct dss__Apartment_DeleteRoom), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__roomID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_DeleteRoom * SOAP_FMAC6 soap_new_dss__Apartment_DeleteRoom(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_DeleteRoom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_DeleteRoom(struct soap *soap, struct dss__Apartment_DeleteRoom *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_DeleteRoom * SOAP_FMAC4 soap_instantiate_dss__Apartment_DeleteRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_DeleteRoom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_DeleteRoom, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteRoom;
		if (size)
			*size = sizeof(struct dss__Apartment_DeleteRoom);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteRoom[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_DeleteRoom);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_DeleteRoom*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_DeleteRoom(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_DeleteRoom %p -> %p\n", q, p));
	*(struct dss__Apartment_DeleteRoom*)p = *(struct dss__Apartment_DeleteRoom*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_DeleteRoomResponse(struct soap *soap, struct dss__Apartment_DeleteRoomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_DeleteRoomResponse(struct soap *soap, const struct dss__Apartment_DeleteRoomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_DeleteRoomResponse(struct soap *soap, const struct dss__Apartment_DeleteRoomResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_DeleteRoomResponse);
	if (soap_out_dss__Apartment_DeleteRoomResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_DeleteRoomResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_DeleteRoomResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_DeleteRoomResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_DeleteRoomResponse * SOAP_FMAC4 soap_get_dss__Apartment_DeleteRoomResponse(struct soap *soap, struct dss__Apartment_DeleteRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_DeleteRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_DeleteRoomResponse * SOAP_FMAC4 soap_in_dss__Apartment_DeleteRoomResponse(struct soap *soap, const char *tag, struct dss__Apartment_DeleteRoomResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_DeleteRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_DeleteRoomResponse, sizeof(struct dss__Apartment_DeleteRoomResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_DeleteRoomResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_DeleteRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_DeleteRoomResponse, 0, sizeof(struct dss__Apartment_DeleteRoomResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_DeleteRoomResponse * SOAP_FMAC6 soap_new_dss__Apartment_DeleteRoomResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_DeleteRoomResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_DeleteRoomResponse(struct soap *soap, struct dss__Apartment_DeleteRoomResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_DeleteRoomResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_DeleteRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_DeleteRoomResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_DeleteRoomResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteRoomResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_DeleteRoomResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteRoomResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_DeleteRoomResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_DeleteRoomResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_DeleteRoomResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_DeleteRoomResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_DeleteRoomResponse*)p = *(struct dss__Apartment_DeleteRoomResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateRoom(struct soap *soap, struct dss__Apartment_AllocateRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateRoom(struct soap *soap, const struct dss__Apartment_AllocateRoom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateRoom(struct soap *soap, const struct dss__Apartment_AllocateRoom *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateRoom);
	if (soap_out_dss__Apartment_AllocateRoom(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateRoom(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateRoom *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateRoom), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateRoom * SOAP_FMAC4 soap_get_dss__Apartment_AllocateRoom(struct soap *soap, struct dss__Apartment_AllocateRoom *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateRoom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateRoom * SOAP_FMAC4 soap_in_dss__Apartment_AllocateRoom(struct soap *soap, const char *tag, struct dss__Apartment_AllocateRoom *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateRoom *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateRoom, sizeof(struct dss__Apartment_AllocateRoom), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateRoom(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateRoom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateRoom, 0, sizeof(struct dss__Apartment_AllocateRoom), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateRoom * SOAP_FMAC6 soap_new_dss__Apartment_AllocateRoom(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateRoom(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateRoom(struct soap *soap, struct dss__Apartment_AllocateRoom *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateRoom * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateRoom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateRoom(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateRoom, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateRoom;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateRoom);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateRoom[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateRoom);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateRoom*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateRoom(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateRoom %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateRoom*)p = *(struct dss__Apartment_AllocateRoom*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateRoomResponse(struct soap *soap, struct dss__Apartment_AllocateRoomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->roomID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateRoomResponse(struct soap *soap, const struct dss__Apartment_AllocateRoomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->roomID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateRoomResponse(struct soap *soap, const struct dss__Apartment_AllocateRoomResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateRoomResponse);
	if (soap_out_dss__Apartment_AllocateRoomResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateRoomResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateRoomResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateRoomResponse), type))
		return soap->error;
	if (soap_out_int(soap, "roomID", -1, &a->roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateRoomResponse * SOAP_FMAC4 soap_get_dss__Apartment_AllocateRoomResponse(struct soap *soap, struct dss__Apartment_AllocateRoomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateRoomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateRoomResponse * SOAP_FMAC4 soap_in_dss__Apartment_AllocateRoomResponse(struct soap *soap, const char *tag, struct dss__Apartment_AllocateRoomResponse *a, const char *type)
{
	short soap_flag_roomID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateRoomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateRoomResponse, sizeof(struct dss__Apartment_AllocateRoomResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateRoomResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "roomID", &a->roomID, "xsd:int"))
				{	soap_flag_roomID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateRoomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateRoomResponse, 0, sizeof(struct dss__Apartment_AllocateRoomResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateRoomResponse * SOAP_FMAC6 soap_new_dss__Apartment_AllocateRoomResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateRoomResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateRoomResponse(struct soap *soap, struct dss__Apartment_AllocateRoomResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateRoomResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateRoomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateRoomResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateRoomResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateRoomResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateRoomResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateRoomResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateRoomResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateRoomResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateRoomResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateRoomResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateRoomResponse*)p = *(struct dss__Apartment_AllocateRoomResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetName(struct soap *soap, struct dss__Modulator_GetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_modulatorID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetName(struct soap *soap, const struct dss__Modulator_GetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_modulatorID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetName(struct soap *soap, const struct dss__Modulator_GetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetName);
	if (soap_out_dss__Modulator_GetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetName(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "modulatorID", -1, &a->_modulatorID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetName * SOAP_FMAC4 soap_get_dss__Modulator_GetName(struct soap *soap, struct dss__Modulator_GetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetName * SOAP_FMAC4 soap_in_dss__Modulator_GetName(struct soap *soap, const char *tag, struct dss__Modulator_GetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__modulatorID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetName, sizeof(struct dss__Modulator_GetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__modulatorID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_modulatorID, "xsd:int"))
				{	soap_flag__modulatorID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetName, 0, sizeof(struct dss__Modulator_GetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__modulatorID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetName * SOAP_FMAC6 soap_new_dss__Modulator_GetName(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetName(struct soap *soap, struct dss__Modulator_GetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetName * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetName;
		if (size)
			*size = sizeof(struct dss__Modulator_GetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetName %p -> %p\n", q, p));
	*(struct dss__Modulator_GetName*)p = *(struct dss__Modulator_GetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetNameResponse(struct soap *soap, struct dss__Modulator_GetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetNameResponse(struct soap *soap, const struct dss__Modulator_GetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetNameResponse(struct soap *soap, const struct dss__Modulator_GetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetNameResponse);
	if (soap_out_dss__Modulator_GetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetNameResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetNameResponse * SOAP_FMAC4 soap_get_dss__Modulator_GetNameResponse(struct soap *soap, struct dss__Modulator_GetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetNameResponse * SOAP_FMAC4 soap_in_dss__Modulator_GetNameResponse(struct soap *soap, const char *tag, struct dss__Modulator_GetNameResponse *a, const char *type)
{
	short soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetNameResponse, sizeof(struct dss__Modulator_GetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetNameResponse, 0, sizeof(struct dss__Modulator_GetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetNameResponse * SOAP_FMAC6 soap_new_dss__Modulator_GetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetNameResponse(struct soap *soap, struct dss__Modulator_GetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetNameResponse * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetNameResponse;
		if (size)
			*size = sizeof(struct dss__Modulator_GetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetNameResponse %p -> %p\n", q, p));
	*(struct dss__Modulator_GetNameResponse*)p = *(struct dss__Modulator_GetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetDSID(struct soap *soap, struct dss__Modulator_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_modulatorID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetDSID(struct soap *soap, const struct dss__Modulator_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_modulatorID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetDSID(struct soap *soap, const struct dss__Modulator_GetDSID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetDSID);
	if (soap_out_dss__Modulator_GetDSID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetDSID(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetDSID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetDSID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "modulatorID", -1, &a->_modulatorID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetDSID * SOAP_FMAC4 soap_get_dss__Modulator_GetDSID(struct soap *soap, struct dss__Modulator_GetDSID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetDSID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetDSID * SOAP_FMAC4 soap_in_dss__Modulator_GetDSID(struct soap *soap, const char *tag, struct dss__Modulator_GetDSID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__modulatorID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetDSID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetDSID, sizeof(struct dss__Modulator_GetDSID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetDSID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__modulatorID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_modulatorID, "xsd:int"))
				{	soap_flag__modulatorID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetDSID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetDSID, 0, sizeof(struct dss__Modulator_GetDSID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__modulatorID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetDSID * SOAP_FMAC6 soap_new_dss__Modulator_GetDSID(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetDSID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetDSID(struct soap *soap, struct dss__Modulator_GetDSID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetDSID * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetDSID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetDSID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetDSID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSID;
		if (size)
			*size = sizeof(struct dss__Modulator_GetDSID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetDSID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetDSID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetDSID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetDSID %p -> %p\n", q, p));
	*(struct dss__Modulator_GetDSID*)p = *(struct dss__Modulator_GetDSID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetDSIDResponse(struct soap *soap, struct dss__Modulator_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__unsignedInt(soap, &a->dsid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetDSIDResponse(struct soap *soap, const struct dss__Modulator_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetDSIDResponse(struct soap *soap, const struct dss__Modulator_GetDSIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetDSIDResponse);
	if (soap_out_dss__Modulator_GetDSIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetDSIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetDSIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetDSIDResponse), type))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "dsid", -1, &a->dsid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC4 soap_get_dss__Modulator_GetDSIDResponse(struct soap *soap, struct dss__Modulator_GetDSIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetDSIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC4 soap_in_dss__Modulator_GetDSIDResponse(struct soap *soap, const char *tag, struct dss__Modulator_GetDSIDResponse *a, const char *type)
{
	short soap_flag_dsid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetDSIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetDSIDResponse, sizeof(struct dss__Modulator_GetDSIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetDSIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dsid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, "dsid", &a->dsid, "xsd:unsignedInt"))
				{	soap_flag_dsid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetDSIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetDSIDResponse, 0, sizeof(struct dss__Modulator_GetDSIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dsid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC6 soap_new_dss__Modulator_GetDSIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetDSIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetDSIDResponse(struct soap *soap, struct dss__Modulator_GetDSIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetDSIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetDSIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetDSIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSIDResponse;
		if (size)
			*size = sizeof(struct dss__Modulator_GetDSIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetDSIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetDSIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetDSIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetDSIDResponse %p -> %p\n", q, p));
	*(struct dss__Modulator_GetDSIDResponse*)p = *(struct dss__Modulator_GetDSIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetModulatorIDs(struct soap *soap, struct dss__Apartment_GetModulatorIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetModulatorIDs(struct soap *soap, const struct dss__Apartment_GetModulatorIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetModulatorIDs(struct soap *soap, const struct dss__Apartment_GetModulatorIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetModulatorIDs);
	if (soap_out_dss__Apartment_GetModulatorIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetModulatorIDs(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetModulatorIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC4 soap_get_dss__Apartment_GetModulatorIDs(struct soap *soap, struct dss__Apartment_GetModulatorIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetModulatorIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC4 soap_in_dss__Apartment_GetModulatorIDs(struct soap *soap, const char *tag, struct dss__Apartment_GetModulatorIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetModulatorIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDs, sizeof(struct dss__Apartment_GetModulatorIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetModulatorIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetModulatorIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetModulatorIDs, 0, sizeof(struct dss__Apartment_GetModulatorIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC6 soap_new_dss__Apartment_GetModulatorIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetModulatorIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetModulatorIDs(struct soap *soap, struct dss__Apartment_GetModulatorIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetModulatorIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetModulatorIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetModulatorIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDs;
		if (size)
			*size = sizeof(struct dss__Apartment_GetModulatorIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetModulatorIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetModulatorIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetModulatorIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetModulatorIDs %p -> %p\n", q, p));
	*(struct dss__Apartment_GetModulatorIDs*)p = *(struct dss__Apartment_GetModulatorIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, struct dss__Apartment_GetModulatorIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids.IntArray::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const struct dss__Apartment_GetModulatorIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const struct dss__Apartment_GetModulatorIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse);
	if (soap_out_dss__Apartment_GetModulatorIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetModulatorIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse), type))
		return soap->error;
	if (a->ids.soap_out(soap, "ids", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, struct dss__Apartment_GetModulatorIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetModulatorIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetModulatorIDsResponse *a, const char *type)
{
	short soap_flag_ids = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetModulatorIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse, sizeof(struct dss__Apartment_GetModulatorIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetModulatorIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (a->ids.soap_in(soap, "ids", "xsd:int"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetModulatorIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse, 0, sizeof(struct dss__Apartment_GetModulatorIDsResponse), 0, soap_copy_dss__Apartment_GetModulatorIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ids > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetModulatorIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, struct dss__Apartment_GetModulatorIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetModulatorIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDsResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetModulatorIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetModulatorIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetModulatorIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetModulatorIDsResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetModulatorIDsResponse*)p = *(struct dss__Apartment_GetModulatorIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetDSID(struct soap *soap, struct dss__Device_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetDSID(struct soap *soap, const struct dss__Device_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetDSID(struct soap *soap, const struct dss__Device_GetDSID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetDSID);
	if (soap_out_dss__Device_GetDSID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetDSID(struct soap *soap, const char *tag, int id, const struct dss__Device_GetDSID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetDSID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetDSID * SOAP_FMAC4 soap_get_dss__Device_GetDSID(struct soap *soap, struct dss__Device_GetDSID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetDSID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetDSID * SOAP_FMAC4 soap_in_dss__Device_GetDSID(struct soap *soap, const char *tag, struct dss__Device_GetDSID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetDSID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetDSID, sizeof(struct dss__Device_GetDSID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetDSID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetDSID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetDSID, 0, sizeof(struct dss__Device_GetDSID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetDSID * SOAP_FMAC6 soap_new_dss__Device_GetDSID(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetDSID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetDSID(struct soap *soap, struct dss__Device_GetDSID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetDSID * SOAP_FMAC4 soap_instantiate_dss__Device_GetDSID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetDSID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetDSID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetDSID;
		if (size)
			*size = sizeof(struct dss__Device_GetDSID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetDSID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetDSID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetDSID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetDSID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetDSID %p -> %p\n", q, p));
	*(struct dss__Device_GetDSID*)p = *(struct dss__Device_GetDSID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetDSIDResponse(struct soap *soap, struct dss__Device_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__unsignedInt(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetDSIDResponse(struct soap *soap, const struct dss__Device_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetDSIDResponse(struct soap *soap, const struct dss__Device_GetDSIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetDSIDResponse);
	if (soap_out_dss__Device_GetDSIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetDSIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_GetDSIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetDSIDResponse), type))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetDSIDResponse * SOAP_FMAC4 soap_get_dss__Device_GetDSIDResponse(struct soap *soap, struct dss__Device_GetDSIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetDSIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetDSIDResponse * SOAP_FMAC4 soap_in_dss__Device_GetDSIDResponse(struct soap *soap, const char *tag, struct dss__Device_GetDSIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetDSIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetDSIDResponse, sizeof(struct dss__Device_GetDSIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetDSIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, "result", &a->result, "xsd:unsignedInt"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetDSIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetDSIDResponse, 0, sizeof(struct dss__Device_GetDSIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetDSIDResponse * SOAP_FMAC6 soap_new_dss__Device_GetDSIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetDSIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetDSIDResponse(struct soap *soap, struct dss__Device_GetDSIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetDSIDResponse * SOAP_FMAC4 soap_instantiate_dss__Device_GetDSIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetDSIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetDSIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetDSIDResponse;
		if (size)
			*size = sizeof(struct dss__Device_GetDSIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetDSIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetDSIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetDSIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetDSIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetDSIDResponse %p -> %p\n", q, p));
	*(struct dss__Device_GetDSIDResponse*)p = *(struct dss__Device_GetDSIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetValue(struct soap *soap, struct dss__Device_GetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetValue(struct soap *soap, const struct dss__Device_GetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetValue(struct soap *soap, const struct dss__Device_GetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetValue);
	if (soap_out_dss__Device_GetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetValue(struct soap *soap, const char *tag, int id, const struct dss__Device_GetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetValue * SOAP_FMAC4 soap_get_dss__Device_GetValue(struct soap *soap, struct dss__Device_GetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetValue * SOAP_FMAC4 soap_in_dss__Device_GetValue(struct soap *soap, const char *tag, struct dss__Device_GetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetValue, sizeof(struct dss__Device_GetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetValue, 0, sizeof(struct dss__Device_GetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetValue * SOAP_FMAC6 soap_new_dss__Device_GetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetValue(struct soap *soap, struct dss__Device_GetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetValue * SOAP_FMAC4 soap_instantiate_dss__Device_GetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetValue;
		if (size)
			*size = sizeof(struct dss__Device_GetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetValue %p -> %p\n", q, p));
	*(struct dss__Device_GetValue*)p = *(struct dss__Device_GetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetValueResponse(struct soap *soap, struct dss__Device_GetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetValueResponse(struct soap *soap, const struct dss__Device_GetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetValueResponse(struct soap *soap, const struct dss__Device_GetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetValueResponse);
	if (soap_out_dss__Device_GetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_GetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetValueResponse), type))
		return soap->error;
	if (soap_out_double(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetValueResponse * SOAP_FMAC4 soap_get_dss__Device_GetValueResponse(struct soap *soap, struct dss__Device_GetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetValueResponse * SOAP_FMAC4 soap_in_dss__Device_GetValueResponse(struct soap *soap, const char *tag, struct dss__Device_GetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetValueResponse, sizeof(struct dss__Device_GetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "result", &a->result, "xsd:double"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetValueResponse, 0, sizeof(struct dss__Device_GetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetValueResponse * SOAP_FMAC6 soap_new_dss__Device_GetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetValueResponse(struct soap *soap, struct dss__Device_GetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_GetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_GetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_GetValueResponse*)p = *(struct dss__Device_GetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_SetValue(struct soap *soap, struct dss__Device_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_SetValue(struct soap *soap, const struct dss__Device_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_SetValue(struct soap *soap, const struct dss__Device_SetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_SetValue);
	if (soap_out_dss__Device_SetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_SetValue(struct soap *soap, const char *tag, int id, const struct dss__Device_SetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_SetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_SetValue * SOAP_FMAC4 soap_get_dss__Device_SetValue(struct soap *soap, struct dss__Device_SetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_SetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_SetValue * SOAP_FMAC4 soap_in_dss__Device_SetValue(struct soap *soap, const char *tag, struct dss__Device_SetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_SetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_SetValue, sizeof(struct dss__Device_SetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_SetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_SetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_SetValue, 0, sizeof(struct dss__Device_SetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_SetValue * SOAP_FMAC6 soap_new_dss__Device_SetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_SetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_SetValue(struct soap *soap, struct dss__Device_SetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_SetValue * SOAP_FMAC4 soap_instantiate_dss__Device_SetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_SetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_SetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_SetValue;
		if (size)
			*size = sizeof(struct dss__Device_SetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_SetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_SetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_SetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_SetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_SetValue %p -> %p\n", q, p));
	*(struct dss__Device_SetValue*)p = *(struct dss__Device_SetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_SetValueResponse(struct soap *soap, struct dss__Device_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_SetValueResponse(struct soap *soap, const struct dss__Device_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_SetValueResponse(struct soap *soap, const struct dss__Device_SetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_SetValueResponse);
	if (soap_out_dss__Device_SetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_SetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_SetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_SetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_SetValueResponse * SOAP_FMAC4 soap_get_dss__Device_SetValueResponse(struct soap *soap, struct dss__Device_SetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_SetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_SetValueResponse * SOAP_FMAC4 soap_in_dss__Device_SetValueResponse(struct soap *soap, const char *tag, struct dss__Device_SetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_SetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_SetValueResponse, sizeof(struct dss__Device_SetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_SetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_SetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_SetValueResponse, 0, sizeof(struct dss__Device_SetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_SetValueResponse * SOAP_FMAC6 soap_new_dss__Device_SetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_SetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_SetValueResponse(struct soap *soap, struct dss__Device_SetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_SetValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_SetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_SetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_SetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_SetValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_SetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_SetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_SetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_SetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_SetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_SetValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_SetValueResponse*)p = *(struct dss__Device_SetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_EndDim(struct soap *soap, struct dss__Device_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_EndDim(struct soap *soap, const struct dss__Device_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_EndDim(struct soap *soap, const struct dss__Device_EndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_EndDim);
	if (soap_out_dss__Device_EndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_EndDim(struct soap *soap, const char *tag, int id, const struct dss__Device_EndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_EndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_EndDim * SOAP_FMAC4 soap_get_dss__Device_EndDim(struct soap *soap, struct dss__Device_EndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_EndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_EndDim * SOAP_FMAC4 soap_in_dss__Device_EndDim(struct soap *soap, const char *tag, struct dss__Device_EndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_EndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_EndDim, sizeof(struct dss__Device_EndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_EndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_EndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_EndDim, 0, sizeof(struct dss__Device_EndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_EndDim * SOAP_FMAC6 soap_new_dss__Device_EndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_EndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_EndDim(struct soap *soap, struct dss__Device_EndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_EndDim * SOAP_FMAC4 soap_instantiate_dss__Device_EndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_EndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_EndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_EndDim;
		if (size)
			*size = sizeof(struct dss__Device_EndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_EndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_EndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_EndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_EndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_EndDim %p -> %p\n", q, p));
	*(struct dss__Device_EndDim*)p = *(struct dss__Device_EndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_EndDimResponse(struct soap *soap, struct dss__Device_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_EndDimResponse(struct soap *soap, const struct dss__Device_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_EndDimResponse(struct soap *soap, const struct dss__Device_EndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_EndDimResponse);
	if (soap_out_dss__Device_EndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_EndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_EndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_EndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_EndDimResponse * SOAP_FMAC4 soap_get_dss__Device_EndDimResponse(struct soap *soap, struct dss__Device_EndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_EndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_EndDimResponse * SOAP_FMAC4 soap_in_dss__Device_EndDimResponse(struct soap *soap, const char *tag, struct dss__Device_EndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_EndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_EndDimResponse, sizeof(struct dss__Device_EndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_EndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_EndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_EndDimResponse, 0, sizeof(struct dss__Device_EndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_EndDimResponse * SOAP_FMAC6 soap_new_dss__Device_EndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_EndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_EndDimResponse(struct soap *soap, struct dss__Device_EndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_EndDimResponse * SOAP_FMAC4 soap_instantiate_dss__Device_EndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_EndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_EndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_EndDimResponse;
		if (size)
			*size = sizeof(struct dss__Device_EndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_EndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_EndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_EndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_EndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_EndDimResponse %p -> %p\n", q, p));
	*(struct dss__Device_EndDimResponse*)p = *(struct dss__Device_EndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_StartDim(struct soap *soap, struct dss__Device_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_StartDim(struct soap *soap, const struct dss__Device_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_StartDim(struct soap *soap, const struct dss__Device_StartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_StartDim);
	if (soap_out_dss__Device_StartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_StartDim(struct soap *soap, const char *tag, int id, const struct dss__Device_StartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_StartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_StartDim * SOAP_FMAC4 soap_get_dss__Device_StartDim(struct soap *soap, struct dss__Device_StartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_StartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_StartDim * SOAP_FMAC4 soap_in_dss__Device_StartDim(struct soap *soap, const char *tag, struct dss__Device_StartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_StartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_StartDim, sizeof(struct dss__Device_StartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_StartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_StartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_StartDim, 0, sizeof(struct dss__Device_StartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_StartDim * SOAP_FMAC6 soap_new_dss__Device_StartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_StartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_StartDim(struct soap *soap, struct dss__Device_StartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_StartDim * SOAP_FMAC4 soap_instantiate_dss__Device_StartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_StartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_StartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_StartDim;
		if (size)
			*size = sizeof(struct dss__Device_StartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_StartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_StartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_StartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_StartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_StartDim %p -> %p\n", q, p));
	*(struct dss__Device_StartDim*)p = *(struct dss__Device_StartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_StartDimResponse(struct soap *soap, struct dss__Device_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_StartDimResponse(struct soap *soap, const struct dss__Device_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_StartDimResponse(struct soap *soap, const struct dss__Device_StartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_StartDimResponse);
	if (soap_out_dss__Device_StartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_StartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_StartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_StartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_StartDimResponse * SOAP_FMAC4 soap_get_dss__Device_StartDimResponse(struct soap *soap, struct dss__Device_StartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_StartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_StartDimResponse * SOAP_FMAC4 soap_in_dss__Device_StartDimResponse(struct soap *soap, const char *tag, struct dss__Device_StartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_StartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_StartDimResponse, sizeof(struct dss__Device_StartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_StartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_StartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_StartDimResponse, 0, sizeof(struct dss__Device_StartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_StartDimResponse * SOAP_FMAC6 soap_new_dss__Device_StartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_StartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_StartDimResponse(struct soap *soap, struct dss__Device_StartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_StartDimResponse * SOAP_FMAC4 soap_instantiate_dss__Device_StartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_StartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_StartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_StartDimResponse;
		if (size)
			*size = sizeof(struct dss__Device_StartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_StartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_StartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_StartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_StartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_StartDimResponse %p -> %p\n", q, p));
	*(struct dss__Device_StartDimResponse*)p = *(struct dss__Device_StartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_Disable(struct soap *soap, struct dss__Device_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_Disable(struct soap *soap, const struct dss__Device_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_Disable(struct soap *soap, const struct dss__Device_Disable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_Disable);
	if (soap_out_dss__Device_Disable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_Disable(struct soap *soap, const char *tag, int id, const struct dss__Device_Disable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_Disable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_Disable * SOAP_FMAC4 soap_get_dss__Device_Disable(struct soap *soap, struct dss__Device_Disable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_Disable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_Disable * SOAP_FMAC4 soap_in_dss__Device_Disable(struct soap *soap, const char *tag, struct dss__Device_Disable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_Disable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_Disable, sizeof(struct dss__Device_Disable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_Disable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_Disable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_Disable, 0, sizeof(struct dss__Device_Disable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_Disable * SOAP_FMAC6 soap_new_dss__Device_Disable(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_Disable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_Disable(struct soap *soap, struct dss__Device_Disable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_Disable * SOAP_FMAC4 soap_instantiate_dss__Device_Disable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_Disable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_Disable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_Disable;
		if (size)
			*size = sizeof(struct dss__Device_Disable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_Disable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_Disable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_Disable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_Disable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_Disable %p -> %p\n", q, p));
	*(struct dss__Device_Disable*)p = *(struct dss__Device_Disable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_DisableResponse(struct soap *soap, struct dss__Device_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_DisableResponse(struct soap *soap, const struct dss__Device_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_DisableResponse(struct soap *soap, const struct dss__Device_DisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_DisableResponse);
	if (soap_out_dss__Device_DisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_DisableResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_DisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_DisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_DisableResponse * SOAP_FMAC4 soap_get_dss__Device_DisableResponse(struct soap *soap, struct dss__Device_DisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_DisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_DisableResponse * SOAP_FMAC4 soap_in_dss__Device_DisableResponse(struct soap *soap, const char *tag, struct dss__Device_DisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_DisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_DisableResponse, sizeof(struct dss__Device_DisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_DisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_DisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_DisableResponse, 0, sizeof(struct dss__Device_DisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_DisableResponse * SOAP_FMAC6 soap_new_dss__Device_DisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_DisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_DisableResponse(struct soap *soap, struct dss__Device_DisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_DisableResponse * SOAP_FMAC4 soap_instantiate_dss__Device_DisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_DisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_DisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_DisableResponse;
		if (size)
			*size = sizeof(struct dss__Device_DisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_DisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_DisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_DisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_DisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_DisableResponse %p -> %p\n", q, p));
	*(struct dss__Device_DisableResponse*)p = *(struct dss__Device_DisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_Enable(struct soap *soap, struct dss__Device_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_Enable(struct soap *soap, const struct dss__Device_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_Enable(struct soap *soap, const struct dss__Device_Enable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_Enable);
	if (soap_out_dss__Device_Enable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_Enable(struct soap *soap, const char *tag, int id, const struct dss__Device_Enable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_Enable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_Enable * SOAP_FMAC4 soap_get_dss__Device_Enable(struct soap *soap, struct dss__Device_Enable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_Enable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_Enable * SOAP_FMAC4 soap_in_dss__Device_Enable(struct soap *soap, const char *tag, struct dss__Device_Enable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_Enable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_Enable, sizeof(struct dss__Device_Enable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_Enable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_Enable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_Enable, 0, sizeof(struct dss__Device_Enable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_Enable * SOAP_FMAC6 soap_new_dss__Device_Enable(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_Enable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_Enable(struct soap *soap, struct dss__Device_Enable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_Enable * SOAP_FMAC4 soap_instantiate_dss__Device_Enable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_Enable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_Enable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_Enable;
		if (size)
			*size = sizeof(struct dss__Device_Enable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_Enable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_Enable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_Enable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_Enable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_Enable %p -> %p\n", q, p));
	*(struct dss__Device_Enable*)p = *(struct dss__Device_Enable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_EnableResponse(struct soap *soap, struct dss__Device_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_EnableResponse(struct soap *soap, const struct dss__Device_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_EnableResponse(struct soap *soap, const struct dss__Device_EnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_EnableResponse);
	if (soap_out_dss__Device_EnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_EnableResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_EnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_EnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_EnableResponse * SOAP_FMAC4 soap_get_dss__Device_EnableResponse(struct soap *soap, struct dss__Device_EnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_EnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_EnableResponse * SOAP_FMAC4 soap_in_dss__Device_EnableResponse(struct soap *soap, const char *tag, struct dss__Device_EnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_EnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_EnableResponse, sizeof(struct dss__Device_EnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_EnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_EnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_EnableResponse, 0, sizeof(struct dss__Device_EnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_EnableResponse * SOAP_FMAC6 soap_new_dss__Device_EnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_EnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_EnableResponse(struct soap *soap, struct dss__Device_EnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_EnableResponse * SOAP_FMAC4 soap_instantiate_dss__Device_EnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_EnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_EnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_EnableResponse;
		if (size)
			*size = sizeof(struct dss__Device_EnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_EnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_EnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_EnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_EnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_EnableResponse %p -> %p\n", q, p));
	*(struct dss__Device_EnableResponse*)p = *(struct dss__Device_EnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_DecreaseValue(struct soap *soap, struct dss__Device_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_DecreaseValue(struct soap *soap, const struct dss__Device_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_DecreaseValue(struct soap *soap, const struct dss__Device_DecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_DecreaseValue);
	if (soap_out_dss__Device_DecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_DecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Device_DecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_DecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_DecreaseValue * SOAP_FMAC4 soap_get_dss__Device_DecreaseValue(struct soap *soap, struct dss__Device_DecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_DecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_DecreaseValue * SOAP_FMAC4 soap_in_dss__Device_DecreaseValue(struct soap *soap, const char *tag, struct dss__Device_DecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_DecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_DecreaseValue, sizeof(struct dss__Device_DecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_DecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_DecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_DecreaseValue, 0, sizeof(struct dss__Device_DecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_DecreaseValue * SOAP_FMAC6 soap_new_dss__Device_DecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_DecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_DecreaseValue(struct soap *soap, struct dss__Device_DecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_DecreaseValue * SOAP_FMAC4 soap_instantiate_dss__Device_DecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_DecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_DecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValue;
		if (size)
			*size = sizeof(struct dss__Device_DecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_DecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_DecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_DecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_DecreaseValue %p -> %p\n", q, p));
	*(struct dss__Device_DecreaseValue*)p = *(struct dss__Device_DecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_DecreaseValueResponse(struct soap *soap, struct dss__Device_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_DecreaseValueResponse(struct soap *soap, const struct dss__Device_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_DecreaseValueResponse(struct soap *soap, const struct dss__Device_DecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_DecreaseValueResponse);
	if (soap_out_dss__Device_DecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_DecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_DecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_DecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_DecreaseValueResponse * SOAP_FMAC4 soap_get_dss__Device_DecreaseValueResponse(struct soap *soap, struct dss__Device_DecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_DecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_DecreaseValueResponse * SOAP_FMAC4 soap_in_dss__Device_DecreaseValueResponse(struct soap *soap, const char *tag, struct dss__Device_DecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_DecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_DecreaseValueResponse, sizeof(struct dss__Device_DecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_DecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_DecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_DecreaseValueResponse, 0, sizeof(struct dss__Device_DecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_DecreaseValueResponse * SOAP_FMAC6 soap_new_dss__Device_DecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_DecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_DecreaseValueResponse(struct soap *soap, struct dss__Device_DecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_DecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_DecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_DecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_DecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_DecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_DecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_DecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_DecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_DecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_DecreaseValueResponse*)p = *(struct dss__Device_DecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_IncreaseValue(struct soap *soap, struct dss__Device_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_IncreaseValue(struct soap *soap, const struct dss__Device_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_IncreaseValue(struct soap *soap, const struct dss__Device_IncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_IncreaseValue);
	if (soap_out_dss__Device_IncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_IncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Device_IncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_IncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_IncreaseValue * SOAP_FMAC4 soap_get_dss__Device_IncreaseValue(struct soap *soap, struct dss__Device_IncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_IncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_IncreaseValue * SOAP_FMAC4 soap_in_dss__Device_IncreaseValue(struct soap *soap, const char *tag, struct dss__Device_IncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_IncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_IncreaseValue, sizeof(struct dss__Device_IncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_IncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_IncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_IncreaseValue, 0, sizeof(struct dss__Device_IncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_IncreaseValue * SOAP_FMAC6 soap_new_dss__Device_IncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_IncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_IncreaseValue(struct soap *soap, struct dss__Device_IncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_IncreaseValue * SOAP_FMAC4 soap_instantiate_dss__Device_IncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_IncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_IncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValue;
		if (size)
			*size = sizeof(struct dss__Device_IncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_IncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_IncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_IncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_IncreaseValue %p -> %p\n", q, p));
	*(struct dss__Device_IncreaseValue*)p = *(struct dss__Device_IncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_IncreaseValueResponse(struct soap *soap, struct dss__Device_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_IncreaseValueResponse(struct soap *soap, const struct dss__Device_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_IncreaseValueResponse(struct soap *soap, const struct dss__Device_IncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_IncreaseValueResponse);
	if (soap_out_dss__Device_IncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_IncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_IncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_IncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_IncreaseValueResponse * SOAP_FMAC4 soap_get_dss__Device_IncreaseValueResponse(struct soap *soap, struct dss__Device_IncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_IncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_IncreaseValueResponse * SOAP_FMAC4 soap_in_dss__Device_IncreaseValueResponse(struct soap *soap, const char *tag, struct dss__Device_IncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_IncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_IncreaseValueResponse, sizeof(struct dss__Device_IncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_IncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_IncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_IncreaseValueResponse, 0, sizeof(struct dss__Device_IncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_IncreaseValueResponse * SOAP_FMAC6 soap_new_dss__Device_IncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_IncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_IncreaseValueResponse(struct soap *soap, struct dss__Device_IncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_IncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_IncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_IncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_IncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_IncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_IncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_IncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_IncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_IncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_IncreaseValueResponse*)p = *(struct dss__Device_IncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOff(struct soap *soap, struct dss__Device_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOff(struct soap *soap, const struct dss__Device_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOff(struct soap *soap, const struct dss__Device_TurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOff);
	if (soap_out_dss__Device_TurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOff(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOff * SOAP_FMAC4 soap_get_dss__Device_TurnOff(struct soap *soap, struct dss__Device_TurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOff * SOAP_FMAC4 soap_in_dss__Device_TurnOff(struct soap *soap, const char *tag, struct dss__Device_TurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOff, sizeof(struct dss__Device_TurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOff, 0, sizeof(struct dss__Device_TurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOff * SOAP_FMAC6 soap_new_dss__Device_TurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOff(struct soap *soap, struct dss__Device_TurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOff * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOff;
		if (size)
			*size = sizeof(struct dss__Device_TurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOff %p -> %p\n", q, p));
	*(struct dss__Device_TurnOff*)p = *(struct dss__Device_TurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOffResponse(struct soap *soap, struct dss__Device_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOffResponse(struct soap *soap, const struct dss__Device_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOffResponse(struct soap *soap, const struct dss__Device_TurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOffResponse);
	if (soap_out_dss__Device_TurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOffResponse * SOAP_FMAC4 soap_get_dss__Device_TurnOffResponse(struct soap *soap, struct dss__Device_TurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOffResponse * SOAP_FMAC4 soap_in_dss__Device_TurnOffResponse(struct soap *soap, const char *tag, struct dss__Device_TurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOffResponse, sizeof(struct dss__Device_TurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOffResponse, 0, sizeof(struct dss__Device_TurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOffResponse * SOAP_FMAC6 soap_new_dss__Device_TurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOffResponse(struct soap *soap, struct dss__Device_TurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOffResponse;
		if (size)
			*size = sizeof(struct dss__Device_TurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOffResponse %p -> %p\n", q, p));
	*(struct dss__Device_TurnOffResponse*)p = *(struct dss__Device_TurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOn(struct soap *soap, struct dss__Device_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOn(struct soap *soap, const struct dss__Device_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOn(struct soap *soap, const struct dss__Device_TurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOn);
	if (soap_out_dss__Device_TurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOn(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOn * SOAP_FMAC4 soap_get_dss__Device_TurnOn(struct soap *soap, struct dss__Device_TurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOn * SOAP_FMAC4 soap_in_dss__Device_TurnOn(struct soap *soap, const char *tag, struct dss__Device_TurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOn, sizeof(struct dss__Device_TurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOn, 0, sizeof(struct dss__Device_TurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOn * SOAP_FMAC6 soap_new_dss__Device_TurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOn(struct soap *soap, struct dss__Device_TurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOn * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOn;
		if (size)
			*size = sizeof(struct dss__Device_TurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOn %p -> %p\n", q, p));
	*(struct dss__Device_TurnOn*)p = *(struct dss__Device_TurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOnResponse(struct soap *soap, struct dss__Device_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOnResponse(struct soap *soap, const struct dss__Device_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOnResponse(struct soap *soap, const struct dss__Device_TurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOnResponse);
	if (soap_out_dss__Device_TurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOnResponse * SOAP_FMAC4 soap_get_dss__Device_TurnOnResponse(struct soap *soap, struct dss__Device_TurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOnResponse * SOAP_FMAC4 soap_in_dss__Device_TurnOnResponse(struct soap *soap, const char *tag, struct dss__Device_TurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOnResponse, sizeof(struct dss__Device_TurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOnResponse, 0, sizeof(struct dss__Device_TurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOnResponse * SOAP_FMAC6 soap_new_dss__Device_TurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOnResponse(struct soap *soap, struct dss__Device_TurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOnResponse;
		if (size)
			*size = sizeof(struct dss__Device_TurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOnResponse %p -> %p\n", q, p));
	*(struct dss__Device_TurnOnResponse*)p = *(struct dss__Device_TurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_SetValue(struct soap *soap, struct dss__Set_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_SetValue(struct soap *soap, const struct dss__Set_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_SetValue(struct soap *soap, const struct dss__Set_SetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_SetValue);
	if (soap_out_dss__Set_SetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_SetValue(struct soap *soap, const char *tag, int id, const struct dss__Set_SetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_SetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_SetValue * SOAP_FMAC4 soap_get_dss__Set_SetValue(struct soap *soap, struct dss__Set_SetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_SetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_SetValue * SOAP_FMAC4 soap_in_dss__Set_SetValue(struct soap *soap, const char *tag, struct dss__Set_SetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_SetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_SetValue, sizeof(struct dss__Set_SetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_SetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_SetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_SetValue, 0, sizeof(struct dss__Set_SetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_SetValue * SOAP_FMAC6 soap_new_dss__Set_SetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_SetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_SetValue(struct soap *soap, struct dss__Set_SetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_SetValue * SOAP_FMAC4 soap_instantiate_dss__Set_SetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_SetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_SetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_SetValue;
		if (size)
			*size = sizeof(struct dss__Set_SetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_SetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_SetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_SetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_SetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_SetValue %p -> %p\n", q, p));
	*(struct dss__Set_SetValue*)p = *(struct dss__Set_SetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_SetValueResponse(struct soap *soap, struct dss__Set_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_SetValueResponse(struct soap *soap, const struct dss__Set_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_SetValueResponse(struct soap *soap, const struct dss__Set_SetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_SetValueResponse);
	if (soap_out_dss__Set_SetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_SetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_SetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_SetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_SetValueResponse * SOAP_FMAC4 soap_get_dss__Set_SetValueResponse(struct soap *soap, struct dss__Set_SetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_SetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_SetValueResponse * SOAP_FMAC4 soap_in_dss__Set_SetValueResponse(struct soap *soap, const char *tag, struct dss__Set_SetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_SetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_SetValueResponse, sizeof(struct dss__Set_SetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_SetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_SetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_SetValueResponse, 0, sizeof(struct dss__Set_SetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_SetValueResponse * SOAP_FMAC6 soap_new_dss__Set_SetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_SetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_SetValueResponse(struct soap *soap, struct dss__Set_SetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_SetValueResponse * SOAP_FMAC4 soap_instantiate_dss__Set_SetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_SetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_SetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_SetValueResponse;
		if (size)
			*size = sizeof(struct dss__Set_SetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_SetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_SetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_SetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_SetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_SetValueResponse %p -> %p\n", q, p));
	*(struct dss__Set_SetValueResponse*)p = *(struct dss__Set_SetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_EndDim(struct soap *soap, struct dss__Set_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_EndDim(struct soap *soap, const struct dss__Set_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_EndDim(struct soap *soap, const struct dss__Set_EndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_EndDim);
	if (soap_out_dss__Set_EndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_EndDim(struct soap *soap, const char *tag, int id, const struct dss__Set_EndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_EndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_EndDim * SOAP_FMAC4 soap_get_dss__Set_EndDim(struct soap *soap, struct dss__Set_EndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_EndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_EndDim * SOAP_FMAC4 soap_in_dss__Set_EndDim(struct soap *soap, const char *tag, struct dss__Set_EndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_EndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_EndDim, sizeof(struct dss__Set_EndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_EndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_EndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_EndDim, 0, sizeof(struct dss__Set_EndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_EndDim * SOAP_FMAC6 soap_new_dss__Set_EndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_EndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_EndDim(struct soap *soap, struct dss__Set_EndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_EndDim * SOAP_FMAC4 soap_instantiate_dss__Set_EndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_EndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_EndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_EndDim;
		if (size)
			*size = sizeof(struct dss__Set_EndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_EndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_EndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_EndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_EndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_EndDim %p -> %p\n", q, p));
	*(struct dss__Set_EndDim*)p = *(struct dss__Set_EndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_EndDimResponse(struct soap *soap, struct dss__Set_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_EndDimResponse(struct soap *soap, const struct dss__Set_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_EndDimResponse(struct soap *soap, const struct dss__Set_EndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_EndDimResponse);
	if (soap_out_dss__Set_EndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_EndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_EndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_EndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_EndDimResponse * SOAP_FMAC4 soap_get_dss__Set_EndDimResponse(struct soap *soap, struct dss__Set_EndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_EndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_EndDimResponse * SOAP_FMAC4 soap_in_dss__Set_EndDimResponse(struct soap *soap, const char *tag, struct dss__Set_EndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_EndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_EndDimResponse, sizeof(struct dss__Set_EndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_EndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_EndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_EndDimResponse, 0, sizeof(struct dss__Set_EndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_EndDimResponse * SOAP_FMAC6 soap_new_dss__Set_EndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_EndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_EndDimResponse(struct soap *soap, struct dss__Set_EndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_EndDimResponse * SOAP_FMAC4 soap_instantiate_dss__Set_EndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_EndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_EndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_EndDimResponse;
		if (size)
			*size = sizeof(struct dss__Set_EndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_EndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_EndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_EndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_EndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_EndDimResponse %p -> %p\n", q, p));
	*(struct dss__Set_EndDimResponse*)p = *(struct dss__Set_EndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_StartDim(struct soap *soap, struct dss__Set_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_StartDim(struct soap *soap, const struct dss__Set_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_StartDim(struct soap *soap, const struct dss__Set_StartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_StartDim);
	if (soap_out_dss__Set_StartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_StartDim(struct soap *soap, const char *tag, int id, const struct dss__Set_StartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_StartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_StartDim * SOAP_FMAC4 soap_get_dss__Set_StartDim(struct soap *soap, struct dss__Set_StartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_StartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_StartDim * SOAP_FMAC4 soap_in_dss__Set_StartDim(struct soap *soap, const char *tag, struct dss__Set_StartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_StartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_StartDim, sizeof(struct dss__Set_StartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_StartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_StartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_StartDim, 0, sizeof(struct dss__Set_StartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_StartDim * SOAP_FMAC6 soap_new_dss__Set_StartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_StartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_StartDim(struct soap *soap, struct dss__Set_StartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_StartDim * SOAP_FMAC4 soap_instantiate_dss__Set_StartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_StartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_StartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_StartDim;
		if (size)
			*size = sizeof(struct dss__Set_StartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_StartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_StartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_StartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_StartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_StartDim %p -> %p\n", q, p));
	*(struct dss__Set_StartDim*)p = *(struct dss__Set_StartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_StartDimResponse(struct soap *soap, struct dss__Set_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_StartDimResponse(struct soap *soap, const struct dss__Set_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_StartDimResponse(struct soap *soap, const struct dss__Set_StartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_StartDimResponse);
	if (soap_out_dss__Set_StartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_StartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_StartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_StartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_StartDimResponse * SOAP_FMAC4 soap_get_dss__Set_StartDimResponse(struct soap *soap, struct dss__Set_StartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_StartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_StartDimResponse * SOAP_FMAC4 soap_in_dss__Set_StartDimResponse(struct soap *soap, const char *tag, struct dss__Set_StartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_StartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_StartDimResponse, sizeof(struct dss__Set_StartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_StartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_StartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_StartDimResponse, 0, sizeof(struct dss__Set_StartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_StartDimResponse * SOAP_FMAC6 soap_new_dss__Set_StartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_StartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_StartDimResponse(struct soap *soap, struct dss__Set_StartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_StartDimResponse * SOAP_FMAC4 soap_instantiate_dss__Set_StartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_StartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_StartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_StartDimResponse;
		if (size)
			*size = sizeof(struct dss__Set_StartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_StartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_StartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_StartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_StartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_StartDimResponse %p -> %p\n", q, p));
	*(struct dss__Set_StartDimResponse*)p = *(struct dss__Set_StartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Disable(struct soap *soap, struct dss__Set_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Disable(struct soap *soap, const struct dss__Set_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Disable(struct soap *soap, const struct dss__Set_Disable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Disable);
	if (soap_out_dss__Set_Disable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Disable(struct soap *soap, const char *tag, int id, const struct dss__Set_Disable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Disable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Disable * SOAP_FMAC4 soap_get_dss__Set_Disable(struct soap *soap, struct dss__Set_Disable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Disable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Disable * SOAP_FMAC4 soap_in_dss__Set_Disable(struct soap *soap, const char *tag, struct dss__Set_Disable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Disable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Disable, sizeof(struct dss__Set_Disable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Disable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Disable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Disable, 0, sizeof(struct dss__Set_Disable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Disable * SOAP_FMAC6 soap_new_dss__Set_Disable(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Disable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Disable(struct soap *soap, struct dss__Set_Disable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Disable * SOAP_FMAC4 soap_instantiate_dss__Set_Disable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Disable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Disable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Disable;
		if (size)
			*size = sizeof(struct dss__Set_Disable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Disable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Disable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Disable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Disable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Disable %p -> %p\n", q, p));
	*(struct dss__Set_Disable*)p = *(struct dss__Set_Disable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_DisableResponse(struct soap *soap, struct dss__Set_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_DisableResponse(struct soap *soap, const struct dss__Set_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_DisableResponse(struct soap *soap, const struct dss__Set_DisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_DisableResponse);
	if (soap_out_dss__Set_DisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_DisableResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_DisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_DisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_DisableResponse * SOAP_FMAC4 soap_get_dss__Set_DisableResponse(struct soap *soap, struct dss__Set_DisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_DisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_DisableResponse * SOAP_FMAC4 soap_in_dss__Set_DisableResponse(struct soap *soap, const char *tag, struct dss__Set_DisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_DisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_DisableResponse, sizeof(struct dss__Set_DisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_DisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_DisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_DisableResponse, 0, sizeof(struct dss__Set_DisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_DisableResponse * SOAP_FMAC6 soap_new_dss__Set_DisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_DisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_DisableResponse(struct soap *soap, struct dss__Set_DisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_DisableResponse * SOAP_FMAC4 soap_instantiate_dss__Set_DisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_DisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_DisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_DisableResponse;
		if (size)
			*size = sizeof(struct dss__Set_DisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_DisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_DisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_DisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_DisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_DisableResponse %p -> %p\n", q, p));
	*(struct dss__Set_DisableResponse*)p = *(struct dss__Set_DisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Enable(struct soap *soap, struct dss__Set_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Enable(struct soap *soap, const struct dss__Set_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Enable(struct soap *soap, const struct dss__Set_Enable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Enable);
	if (soap_out_dss__Set_Enable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Enable(struct soap *soap, const char *tag, int id, const struct dss__Set_Enable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Enable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Enable * SOAP_FMAC4 soap_get_dss__Set_Enable(struct soap *soap, struct dss__Set_Enable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Enable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Enable * SOAP_FMAC4 soap_in_dss__Set_Enable(struct soap *soap, const char *tag, struct dss__Set_Enable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Enable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Enable, sizeof(struct dss__Set_Enable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Enable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Enable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Enable, 0, sizeof(struct dss__Set_Enable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Enable * SOAP_FMAC6 soap_new_dss__Set_Enable(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Enable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Enable(struct soap *soap, struct dss__Set_Enable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Enable * SOAP_FMAC4 soap_instantiate_dss__Set_Enable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Enable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Enable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Enable;
		if (size)
			*size = sizeof(struct dss__Set_Enable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Enable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Enable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Enable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Enable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Enable %p -> %p\n", q, p));
	*(struct dss__Set_Enable*)p = *(struct dss__Set_Enable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_EnableResponse(struct soap *soap, struct dss__Set_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_EnableResponse(struct soap *soap, const struct dss__Set_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_EnableResponse(struct soap *soap, const struct dss__Set_EnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_EnableResponse);
	if (soap_out_dss__Set_EnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_EnableResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_EnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_EnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_EnableResponse * SOAP_FMAC4 soap_get_dss__Set_EnableResponse(struct soap *soap, struct dss__Set_EnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_EnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_EnableResponse * SOAP_FMAC4 soap_in_dss__Set_EnableResponse(struct soap *soap, const char *tag, struct dss__Set_EnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_EnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_EnableResponse, sizeof(struct dss__Set_EnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_EnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_EnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_EnableResponse, 0, sizeof(struct dss__Set_EnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_EnableResponse * SOAP_FMAC6 soap_new_dss__Set_EnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_EnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_EnableResponse(struct soap *soap, struct dss__Set_EnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_EnableResponse * SOAP_FMAC4 soap_instantiate_dss__Set_EnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_EnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_EnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_EnableResponse;
		if (size)
			*size = sizeof(struct dss__Set_EnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_EnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_EnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_EnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_EnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_EnableResponse %p -> %p\n", q, p));
	*(struct dss__Set_EnableResponse*)p = *(struct dss__Set_EnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_DecreaseValue(struct soap *soap, struct dss__Set_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_DecreaseValue(struct soap *soap, const struct dss__Set_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_DecreaseValue(struct soap *soap, const struct dss__Set_DecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_DecreaseValue);
	if (soap_out_dss__Set_DecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_DecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Set_DecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_DecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_DecreaseValue * SOAP_FMAC4 soap_get_dss__Set_DecreaseValue(struct soap *soap, struct dss__Set_DecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_DecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_DecreaseValue * SOAP_FMAC4 soap_in_dss__Set_DecreaseValue(struct soap *soap, const char *tag, struct dss__Set_DecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_DecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_DecreaseValue, sizeof(struct dss__Set_DecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_DecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_DecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_DecreaseValue, 0, sizeof(struct dss__Set_DecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_DecreaseValue * SOAP_FMAC6 soap_new_dss__Set_DecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_DecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_DecreaseValue(struct soap *soap, struct dss__Set_DecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_DecreaseValue * SOAP_FMAC4 soap_instantiate_dss__Set_DecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_DecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_DecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValue;
		if (size)
			*size = sizeof(struct dss__Set_DecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_DecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_DecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_DecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_DecreaseValue %p -> %p\n", q, p));
	*(struct dss__Set_DecreaseValue*)p = *(struct dss__Set_DecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_DecreaseValueResponse(struct soap *soap, struct dss__Set_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_DecreaseValueResponse(struct soap *soap, const struct dss__Set_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_DecreaseValueResponse(struct soap *soap, const struct dss__Set_DecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_DecreaseValueResponse);
	if (soap_out_dss__Set_DecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_DecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_DecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_DecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_DecreaseValueResponse * SOAP_FMAC4 soap_get_dss__Set_DecreaseValueResponse(struct soap *soap, struct dss__Set_DecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_DecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_DecreaseValueResponse * SOAP_FMAC4 soap_in_dss__Set_DecreaseValueResponse(struct soap *soap, const char *tag, struct dss__Set_DecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_DecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_DecreaseValueResponse, sizeof(struct dss__Set_DecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_DecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_DecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_DecreaseValueResponse, 0, sizeof(struct dss__Set_DecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_DecreaseValueResponse * SOAP_FMAC6 soap_new_dss__Set_DecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_DecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_DecreaseValueResponse(struct soap *soap, struct dss__Set_DecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_DecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Set_DecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_DecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_DecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Set_DecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_DecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_DecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_DecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_DecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Set_DecreaseValueResponse*)p = *(struct dss__Set_DecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_IncreaseValue(struct soap *soap, struct dss__Set_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_IncreaseValue(struct soap *soap, const struct dss__Set_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_paramID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_IncreaseValue(struct soap *soap, const struct dss__Set_IncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_IncreaseValue);
	if (soap_out_dss__Set_IncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_IncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Set_IncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_IncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_IncreaseValue * SOAP_FMAC4 soap_get_dss__Set_IncreaseValue(struct soap *soap, struct dss__Set_IncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_IncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_IncreaseValue * SOAP_FMAC4 soap_in_dss__Set_IncreaseValue(struct soap *soap, const char *tag, struct dss__Set_IncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_IncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_IncreaseValue, sizeof(struct dss__Set_IncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_IncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_IncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_IncreaseValue, 0, sizeof(struct dss__Set_IncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_IncreaseValue * SOAP_FMAC6 soap_new_dss__Set_IncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_IncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_IncreaseValue(struct soap *soap, struct dss__Set_IncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_IncreaseValue * SOAP_FMAC4 soap_instantiate_dss__Set_IncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_IncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_IncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValue;
		if (size)
			*size = sizeof(struct dss__Set_IncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_IncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_IncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_IncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_IncreaseValue %p -> %p\n", q, p));
	*(struct dss__Set_IncreaseValue*)p = *(struct dss__Set_IncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_IncreaseValueResponse(struct soap *soap, struct dss__Set_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_IncreaseValueResponse(struct soap *soap, const struct dss__Set_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_IncreaseValueResponse(struct soap *soap, const struct dss__Set_IncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_IncreaseValueResponse);
	if (soap_out_dss__Set_IncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_IncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_IncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_IncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_IncreaseValueResponse * SOAP_FMAC4 soap_get_dss__Set_IncreaseValueResponse(struct soap *soap, struct dss__Set_IncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_IncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_IncreaseValueResponse * SOAP_FMAC4 soap_in_dss__Set_IncreaseValueResponse(struct soap *soap, const char *tag, struct dss__Set_IncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_IncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_IncreaseValueResponse, sizeof(struct dss__Set_IncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_IncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_IncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_IncreaseValueResponse, 0, sizeof(struct dss__Set_IncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_IncreaseValueResponse * SOAP_FMAC6 soap_new_dss__Set_IncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_IncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_IncreaseValueResponse(struct soap *soap, struct dss__Set_IncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_IncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Set_IncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_IncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_IncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Set_IncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_IncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_IncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_IncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_IncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Set_IncreaseValueResponse*)p = *(struct dss__Set_IncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOff(struct soap *soap, struct dss__Set_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOff(struct soap *soap, const struct dss__Set_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOff(struct soap *soap, const struct dss__Set_TurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOff);
	if (soap_out_dss__Set_TurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOff(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOff * SOAP_FMAC4 soap_get_dss__Set_TurnOff(struct soap *soap, struct dss__Set_TurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOff * SOAP_FMAC4 soap_in_dss__Set_TurnOff(struct soap *soap, const char *tag, struct dss__Set_TurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOff, sizeof(struct dss__Set_TurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOff, 0, sizeof(struct dss__Set_TurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOff * SOAP_FMAC6 soap_new_dss__Set_TurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOff(struct soap *soap, struct dss__Set_TurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOff * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOff;
		if (size)
			*size = sizeof(struct dss__Set_TurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOff %p -> %p\n", q, p));
	*(struct dss__Set_TurnOff*)p = *(struct dss__Set_TurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOffResponse(struct soap *soap, struct dss__Set_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOffResponse(struct soap *soap, const struct dss__Set_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOffResponse(struct soap *soap, const struct dss__Set_TurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOffResponse);
	if (soap_out_dss__Set_TurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOffResponse * SOAP_FMAC4 soap_get_dss__Set_TurnOffResponse(struct soap *soap, struct dss__Set_TurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOffResponse * SOAP_FMAC4 soap_in_dss__Set_TurnOffResponse(struct soap *soap, const char *tag, struct dss__Set_TurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOffResponse, sizeof(struct dss__Set_TurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOffResponse, 0, sizeof(struct dss__Set_TurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOffResponse * SOAP_FMAC6 soap_new_dss__Set_TurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOffResponse(struct soap *soap, struct dss__Set_TurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOffResponse;
		if (size)
			*size = sizeof(struct dss__Set_TurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOffResponse %p -> %p\n", q, p));
	*(struct dss__Set_TurnOffResponse*)p = *(struct dss__Set_TurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOn(struct soap *soap, struct dss__Set_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOn(struct soap *soap, const struct dss__Set_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOn(struct soap *soap, const struct dss__Set_TurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOn);
	if (soap_out_dss__Set_TurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOn(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOn * SOAP_FMAC4 soap_get_dss__Set_TurnOn(struct soap *soap, struct dss__Set_TurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOn * SOAP_FMAC4 soap_in_dss__Set_TurnOn(struct soap *soap, const char *tag, struct dss__Set_TurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOn, sizeof(struct dss__Set_TurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOn, 0, sizeof(struct dss__Set_TurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOn * SOAP_FMAC6 soap_new_dss__Set_TurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOn(struct soap *soap, struct dss__Set_TurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOn * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOn;
		if (size)
			*size = sizeof(struct dss__Set_TurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOn %p -> %p\n", q, p));
	*(struct dss__Set_TurnOn*)p = *(struct dss__Set_TurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOnResponse(struct soap *soap, struct dss__Set_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOnResponse(struct soap *soap, const struct dss__Set_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOnResponse(struct soap *soap, const struct dss__Set_TurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOnResponse);
	if (soap_out_dss__Set_TurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOnResponse * SOAP_FMAC4 soap_get_dss__Set_TurnOnResponse(struct soap *soap, struct dss__Set_TurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOnResponse * SOAP_FMAC4 soap_in_dss__Set_TurnOnResponse(struct soap *soap, const char *tag, struct dss__Set_TurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOnResponse, sizeof(struct dss__Set_TurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOnResponse, 0, sizeof(struct dss__Set_TurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOnResponse * SOAP_FMAC6 soap_new_dss__Set_TurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOnResponse(struct soap *soap, struct dss__Set_TurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOnResponse;
		if (size)
			*size = sizeof(struct dss__Set_TurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOnResponse %p -> %p\n", q, p));
	*(struct dss__Set_TurnOnResponse*)p = *(struct dss__Set_TurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetRoomIDs(struct soap *soap, struct dss__Apartment_GetRoomIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetRoomIDs(struct soap *soap, const struct dss__Apartment_GetRoomIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetRoomIDs(struct soap *soap, const struct dss__Apartment_GetRoomIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetRoomIDs);
	if (soap_out_dss__Apartment_GetRoomIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetRoomIDs(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetRoomIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetRoomIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomIDs * SOAP_FMAC4 soap_get_dss__Apartment_GetRoomIDs(struct soap *soap, struct dss__Apartment_GetRoomIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetRoomIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetRoomIDs * SOAP_FMAC4 soap_in_dss__Apartment_GetRoomIDs(struct soap *soap, const char *tag, struct dss__Apartment_GetRoomIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetRoomIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetRoomIDs, sizeof(struct dss__Apartment_GetRoomIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetRoomIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetRoomIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetRoomIDs, 0, sizeof(struct dss__Apartment_GetRoomIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetRoomIDs * SOAP_FMAC6 soap_new_dss__Apartment_GetRoomIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetRoomIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetRoomIDs(struct soap *soap, struct dss__Apartment_GetRoomIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomIDs * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetRoomIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetRoomIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetRoomIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomIDs;
		if (size)
			*size = sizeof(struct dss__Apartment_GetRoomIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetRoomIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetRoomIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetRoomIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetRoomIDs %p -> %p\n", q, p));
	*(struct dss__Apartment_GetRoomIDs*)p = *(struct dss__Apartment_GetRoomIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetRoomIDsResponse(struct soap *soap, struct dss__Apartment_GetRoomIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->roomIDs.IntArray::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetRoomIDsResponse(struct soap *soap, const struct dss__Apartment_GetRoomIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->roomIDs.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetRoomIDsResponse(struct soap *soap, const struct dss__Apartment_GetRoomIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetRoomIDsResponse);
	if (soap_out_dss__Apartment_GetRoomIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetRoomIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetRoomIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetRoomIDsResponse), type))
		return soap->error;
	if (a->roomIDs.soap_out(soap, "roomIDs", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomIDsResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetRoomIDsResponse(struct soap *soap, struct dss__Apartment_GetRoomIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetRoomIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetRoomIDsResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetRoomIDsResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetRoomIDsResponse *a, const char *type)
{
	short soap_flag_roomIDs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetRoomIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetRoomIDsResponse, sizeof(struct dss__Apartment_GetRoomIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetRoomIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomIDs && soap->error == SOAP_TAG_MISMATCH)
				if (a->roomIDs.soap_in(soap, "roomIDs", "xsd:int"))
				{	soap_flag_roomIDs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetRoomIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetRoomIDsResponse, 0, sizeof(struct dss__Apartment_GetRoomIDsResponse), 0, soap_copy_dss__Apartment_GetRoomIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomIDs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetRoomIDsResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetRoomIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetRoomIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetRoomIDsResponse(struct soap *soap, struct dss__Apartment_GetRoomIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomIDsResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetRoomIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetRoomIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetRoomIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomIDsResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetRoomIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetRoomIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetRoomIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetRoomIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetRoomIDsResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetRoomIDsResponse*)p = *(struct dss__Apartment_GetRoomIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetRoomByName(struct soap *soap, struct dss__Apartment_GetRoomByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_roomName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetRoomByName(struct soap *soap, const struct dss__Apartment_GetRoomByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_roomName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetRoomByName(struct soap *soap, const struct dss__Apartment_GetRoomByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetRoomByName);
	if (soap_out_dss__Apartment_GetRoomByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetRoomByName(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetRoomByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetRoomByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "roomName", -1, &a->_roomName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomByName * SOAP_FMAC4 soap_get_dss__Apartment_GetRoomByName(struct soap *soap, struct dss__Apartment_GetRoomByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetRoomByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetRoomByName * SOAP_FMAC4 soap_in_dss__Apartment_GetRoomByName(struct soap *soap, const char *tag, struct dss__Apartment_GetRoomByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__roomName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetRoomByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetRoomByName, sizeof(struct dss__Apartment_GetRoomByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetRoomByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__roomName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_roomName, "xsd:string"))
				{	soap_flag__roomName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetRoomByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetRoomByName, 0, sizeof(struct dss__Apartment_GetRoomByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetRoomByName * SOAP_FMAC6 soap_new_dss__Apartment_GetRoomByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetRoomByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetRoomByName(struct soap *soap, struct dss__Apartment_GetRoomByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomByName * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetRoomByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetRoomByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetRoomByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomByName;
		if (size)
			*size = sizeof(struct dss__Apartment_GetRoomByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetRoomByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetRoomByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetRoomByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetRoomByName %p -> %p\n", q, p));
	*(struct dss__Apartment_GetRoomByName*)p = *(struct dss__Apartment_GetRoomByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetRoomByNameResponse(struct soap *soap, struct dss__Apartment_GetRoomByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->roomID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetRoomByNameResponse(struct soap *soap, const struct dss__Apartment_GetRoomByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->roomID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetRoomByNameResponse(struct soap *soap, const struct dss__Apartment_GetRoomByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetRoomByNameResponse);
	if (soap_out_dss__Apartment_GetRoomByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetRoomByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetRoomByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetRoomByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "roomID", -1, &a->roomID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomByNameResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetRoomByNameResponse(struct soap *soap, struct dss__Apartment_GetRoomByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetRoomByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetRoomByNameResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetRoomByNameResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetRoomByNameResponse *a, const char *type)
{
	short soap_flag_roomID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetRoomByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetRoomByNameResponse, sizeof(struct dss__Apartment_GetRoomByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetRoomByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roomID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "roomID", &a->roomID, "xsd:int"))
				{	soap_flag_roomID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetRoomByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetRoomByNameResponse, 0, sizeof(struct dss__Apartment_GetRoomByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roomID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetRoomByNameResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetRoomByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetRoomByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetRoomByNameResponse(struct soap *soap, struct dss__Apartment_GetRoomByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetRoomByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetRoomByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetRoomByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetRoomByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomByNameResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetRoomByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetRoomByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetRoomByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetRoomByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetRoomByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetRoomByNameResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetRoomByNameResponse*)p = *(struct dss__Apartment_GetRoomByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetGroupByName(struct soap *soap, struct dss__Apartment_GetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetGroupByName(struct soap *soap, const struct dss__Apartment_GetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetGroupByName(struct soap *soap, const struct dss__Apartment_GetGroupByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetGroupByName);
	if (soap_out_dss__Apartment_GetGroupByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetGroupByName(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetGroupByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetGroupByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByName * SOAP_FMAC4 soap_get_dss__Apartment_GetGroupByName(struct soap *soap, struct dss__Apartment_GetGroupByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetGroupByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByName * SOAP_FMAC4 soap_in_dss__Apartment_GetGroupByName(struct soap *soap, const char *tag, struct dss__Apartment_GetGroupByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetGroupByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetGroupByName, sizeof(struct dss__Apartment_GetGroupByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetGroupByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetGroupByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetGroupByName, 0, sizeof(struct dss__Apartment_GetGroupByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetGroupByName * SOAP_FMAC6 soap_new_dss__Apartment_GetGroupByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetGroupByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetGroupByName(struct soap *soap, struct dss__Apartment_GetGroupByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByName * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetGroupByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetGroupByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetGroupByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByName;
		if (size)
			*size = sizeof(struct dss__Apartment_GetGroupByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetGroupByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetGroupByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetGroupByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetGroupByName %p -> %p\n", q, p));
	*(struct dss__Apartment_GetGroupByName*)p = *(struct dss__Apartment_GetGroupByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetGroupByNameResponse(struct soap *soap, struct dss__Apartment_GetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const struct dss__Apartment_GetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->groupID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const struct dss__Apartment_GetGroupByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse);
	if (soap_out_dss__Apartment_GetGroupByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetGroupByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetGroupByNameResponse(struct soap *soap, struct dss__Apartment_GetGroupByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetGroupByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetGroupByNameResponse *a, const char *type)
{
	short soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetGroupByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse, sizeof(struct dss__Apartment_GetGroupByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetGroupByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupID", &a->groupID, "xsd:int"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetGroupByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse, 0, sizeof(struct dss__Apartment_GetGroupByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetGroupByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetGroupByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetGroupByNameResponse(struct soap *soap, struct dss__Apartment_GetGroupByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetGroupByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetGroupByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByNameResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetGroupByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetGroupByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetGroupByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetGroupByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetGroupByNameResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetGroupByNameResponse*)p = *(struct dss__Apartment_GetGroupByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_ByGroup(struct soap *soap, struct dss__Set_ByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_ByGroup(struct soap *soap, const struct dss__Set_ByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_groupID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_ByGroup(struct soap *soap, const struct dss__Set_ByGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_ByGroup);
	if (soap_out_dss__Set_ByGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_ByGroup(struct soap *soap, const char *tag, int id, const struct dss__Set_ByGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_ByGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_ByGroup * SOAP_FMAC4 soap_get_dss__Set_ByGroup(struct soap *soap, struct dss__Set_ByGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_ByGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_ByGroup * SOAP_FMAC4 soap_in_dss__Set_ByGroup(struct soap *soap, const char *tag, struct dss__Set_ByGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_ByGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_ByGroup, sizeof(struct dss__Set_ByGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_ByGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_ByGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_ByGroup, 0, sizeof(struct dss__Set_ByGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_ByGroup * SOAP_FMAC6 soap_new_dss__Set_ByGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_ByGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_ByGroup(struct soap *soap, struct dss__Set_ByGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_ByGroup * SOAP_FMAC4 soap_instantiate_dss__Set_ByGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_ByGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_ByGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_ByGroup;
		if (size)
			*size = sizeof(struct dss__Set_ByGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_ByGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_ByGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_ByGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_ByGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_ByGroup %p -> %p\n", q, p));
	*(struct dss__Set_ByGroup*)p = *(struct dss__Set_ByGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_ByGroupResponse(struct soap *soap, struct dss__Set_ByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_ByGroupResponse(struct soap *soap, const struct dss__Set_ByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_ByGroupResponse(struct soap *soap, const struct dss__Set_ByGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_ByGroupResponse);
	if (soap_out_dss__Set_ByGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_ByGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_ByGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_ByGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_ByGroupResponse * SOAP_FMAC4 soap_get_dss__Set_ByGroupResponse(struct soap *soap, struct dss__Set_ByGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_ByGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_ByGroupResponse * SOAP_FMAC4 soap_in_dss__Set_ByGroupResponse(struct soap *soap, const char *tag, struct dss__Set_ByGroupResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_ByGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_ByGroupResponse, sizeof(struct dss__Set_ByGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_ByGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_ByGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_ByGroupResponse, 0, sizeof(struct dss__Set_ByGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_ByGroupResponse * SOAP_FMAC6 soap_new_dss__Set_ByGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_ByGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_ByGroupResponse(struct soap *soap, struct dss__Set_ByGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_ByGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Set_ByGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_ByGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_ByGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_ByGroupResponse;
		if (size)
			*size = sizeof(struct dss__Set_ByGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_ByGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_ByGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_ByGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_ByGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_ByGroupResponse %p -> %p\n", q, p));
	*(struct dss__Set_ByGroupResponse*)p = *(struct dss__Set_ByGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Remove(struct soap *soap, struct dss__Set_Remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_setIDToRemove);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Remove(struct soap *soap, const struct dss__Set_Remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setIDToRemove, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Remove(struct soap *soap, const struct dss__Set_Remove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Remove);
	if (soap_out_dss__Set_Remove(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Remove(struct soap *soap, const char *tag, int id, const struct dss__Set_Remove *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Remove), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "setIDToRemove", -1, &a->_setIDToRemove, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Remove * SOAP_FMAC4 soap_get_dss__Set_Remove(struct soap *soap, struct dss__Set_Remove *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Remove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Remove * SOAP_FMAC4 soap_in_dss__Set_Remove(struct soap *soap, const char *tag, struct dss__Set_Remove *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__setIDToRemove = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Remove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Remove, sizeof(struct dss__Set_Remove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Remove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__setIDToRemove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setIDToRemove, "xsd:int"))
				{	soap_flag__setIDToRemove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Remove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Remove, 0, sizeof(struct dss__Set_Remove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__setIDToRemove > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Remove * SOAP_FMAC6 soap_new_dss__Set_Remove(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Remove(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Remove(struct soap *soap, struct dss__Set_Remove *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Remove * SOAP_FMAC4 soap_instantiate_dss__Set_Remove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Remove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Remove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Remove;
		if (size)
			*size = sizeof(struct dss__Set_Remove);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Remove[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Remove);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Remove*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Remove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Remove %p -> %p\n", q, p));
	*(struct dss__Set_Remove*)p = *(struct dss__Set_Remove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_RemoveResponse(struct soap *soap, struct dss__Set_RemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_RemoveResponse(struct soap *soap, const struct dss__Set_RemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_RemoveResponse(struct soap *soap, const struct dss__Set_RemoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_RemoveResponse);
	if (soap_out_dss__Set_RemoveResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_RemoveResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_RemoveResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_RemoveResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_RemoveResponse * SOAP_FMAC4 soap_get_dss__Set_RemoveResponse(struct soap *soap, struct dss__Set_RemoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_RemoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_RemoveResponse * SOAP_FMAC4 soap_in_dss__Set_RemoveResponse(struct soap *soap, const char *tag, struct dss__Set_RemoveResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_RemoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_RemoveResponse, sizeof(struct dss__Set_RemoveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_RemoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_RemoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_RemoveResponse, 0, sizeof(struct dss__Set_RemoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_RemoveResponse * SOAP_FMAC6 soap_new_dss__Set_RemoveResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_RemoveResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_RemoveResponse(struct soap *soap, struct dss__Set_RemoveResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_RemoveResponse * SOAP_FMAC4 soap_instantiate_dss__Set_RemoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_RemoveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_RemoveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_RemoveResponse;
		if (size)
			*size = sizeof(struct dss__Set_RemoveResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_RemoveResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_RemoveResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_RemoveResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_RemoveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_RemoveResponse %p -> %p\n", q, p));
	*(struct dss__Set_RemoveResponse*)p = *(struct dss__Set_RemoveResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Combine(struct soap *soap, struct dss__Set_Combine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID1);
	soap_default_int(soap, &a->_setID2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Combine(struct soap *soap, const struct dss__Set_Combine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID1, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID2, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Combine(struct soap *soap, const struct dss__Set_Combine *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Combine);
	if (soap_out_dss__Set_Combine(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Combine(struct soap *soap, const char *tag, int id, const struct dss__Set_Combine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Combine), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID1", -1, &a->_setID1, ""))
		return soap->error;
	if (soap_out_int(soap, "setID2", -1, &a->_setID2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Combine * SOAP_FMAC4 soap_get_dss__Set_Combine(struct soap *soap, struct dss__Set_Combine *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Combine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Combine * SOAP_FMAC4 soap_in_dss__Set_Combine(struct soap *soap, const char *tag, struct dss__Set_Combine *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID1 = 1, soap_flag__setID2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Combine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Combine, sizeof(struct dss__Set_Combine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Combine(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID1, "xsd:int"))
				{	soap_flag__setID1--;
					continue;
				}
			if (soap_flag__setID2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID2, "xsd:int"))
				{	soap_flag__setID2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Combine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Combine, 0, sizeof(struct dss__Set_Combine), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID1 > 0 || soap_flag__setID2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Combine * SOAP_FMAC6 soap_new_dss__Set_Combine(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Combine(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Combine(struct soap *soap, struct dss__Set_Combine *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Combine * SOAP_FMAC4 soap_instantiate_dss__Set_Combine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Combine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Combine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Combine;
		if (size)
			*size = sizeof(struct dss__Set_Combine);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Combine[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Combine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Combine*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Combine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Combine %p -> %p\n", q, p));
	*(struct dss__Set_Combine*)p = *(struct dss__Set_Combine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_CombineResponse(struct soap *soap, struct dss__Set_CombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_CombineResponse(struct soap *soap, const struct dss__Set_CombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_CombineResponse(struct soap *soap, const struct dss__Set_CombineResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_CombineResponse);
	if (soap_out_dss__Set_CombineResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_CombineResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_CombineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_CombineResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_CombineResponse * SOAP_FMAC4 soap_get_dss__Set_CombineResponse(struct soap *soap, struct dss__Set_CombineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_CombineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_CombineResponse * SOAP_FMAC4 soap_in_dss__Set_CombineResponse(struct soap *soap, const char *tag, struct dss__Set_CombineResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_CombineResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_CombineResponse, sizeof(struct dss__Set_CombineResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_CombineResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_CombineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_CombineResponse, 0, sizeof(struct dss__Set_CombineResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_CombineResponse * SOAP_FMAC6 soap_new_dss__Set_CombineResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_CombineResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_CombineResponse(struct soap *soap, struct dss__Set_CombineResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_CombineResponse * SOAP_FMAC4 soap_instantiate_dss__Set_CombineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_CombineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_CombineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_CombineResponse;
		if (size)
			*size = sizeof(struct dss__Set_CombineResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_CombineResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_CombineResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_CombineResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_CombineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_CombineResponse %p -> %p\n", q, p));
	*(struct dss__Set_CombineResponse*)p = *(struct dss__Set_CombineResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_RemoveDevice(struct soap *soap, struct dss__Set_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_RemoveDevice(struct soap *soap, const struct dss__Set_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_RemoveDevice(struct soap *soap, const struct dss__Set_RemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_RemoveDevice);
	if (soap_out_dss__Set_RemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_RemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__Set_RemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_RemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_RemoveDevice * SOAP_FMAC4 soap_get_dss__Set_RemoveDevice(struct soap *soap, struct dss__Set_RemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_RemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_RemoveDevice * SOAP_FMAC4 soap_in_dss__Set_RemoveDevice(struct soap *soap, const char *tag, struct dss__Set_RemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_RemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_RemoveDevice, sizeof(struct dss__Set_RemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_RemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_RemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_RemoveDevice, 0, sizeof(struct dss__Set_RemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_RemoveDevice * SOAP_FMAC6 soap_new_dss__Set_RemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_RemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_RemoveDevice(struct soap *soap, struct dss__Set_RemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_RemoveDevice * SOAP_FMAC4 soap_instantiate_dss__Set_RemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_RemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_RemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_RemoveDevice;
		if (size)
			*size = sizeof(struct dss__Set_RemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_RemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_RemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_RemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_RemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_RemoveDevice %p -> %p\n", q, p));
	*(struct dss__Set_RemoveDevice*)p = *(struct dss__Set_RemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_RemoveDeviceResponse(struct soap *soap, struct dss__Set_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_RemoveDeviceResponse(struct soap *soap, const struct dss__Set_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_RemoveDeviceResponse(struct soap *soap, const struct dss__Set_RemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_RemoveDeviceResponse);
	if (soap_out_dss__Set_RemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_RemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_RemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_RemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__Set_RemoveDeviceResponse(struct soap *soap, struct dss__Set_RemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_RemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__Set_RemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__Set_RemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_RemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_RemoveDeviceResponse, sizeof(struct dss__Set_RemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_RemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_RemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_RemoveDeviceResponse, 0, sizeof(struct dss__Set_RemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__Set_RemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_RemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_RemoveDeviceResponse(struct soap *soap, struct dss__Set_RemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Set_RemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_RemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_RemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_RemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Set_RemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_RemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_RemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_RemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_RemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_RemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Set_RemoveDeviceResponse*)p = *(struct dss__Set_RemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByID(struct soap *soap, struct dss__Set_AddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByID(struct soap *soap, const struct dss__Set_AddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_embedded(soap, &a->_deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByID(struct soap *soap, const struct dss__Set_AddDeviceByID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByID);
	if (soap_out_dss__Set_AddDeviceByID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByID(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByID * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByID(struct soap *soap, struct dss__Set_AddDeviceByID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByID * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByID(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByID, sizeof(struct dss__Set_AddDeviceByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByID, 0, sizeof(struct dss__Set_AddDeviceByID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByID * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByID(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByID(struct soap *soap, struct dss__Set_AddDeviceByID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByID * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByID;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByID %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByID*)p = *(struct dss__Set_AddDeviceByID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByIDResponse(struct soap *soap, struct dss__Set_AddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByIDResponse(struct soap *soap, const struct dss__Set_AddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByIDResponse(struct soap *soap, const struct dss__Set_AddDeviceByIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByIDResponse);
	if (soap_out_dss__Set_AddDeviceByIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByIDResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByIDResponse(struct soap *soap, struct dss__Set_AddDeviceByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByIDResponse(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByIDResponse, sizeof(struct dss__Set_AddDeviceByIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByIDResponse, 0, sizeof(struct dss__Set_AddDeviceByIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByIDResponse(struct soap *soap, struct dss__Set_AddDeviceByIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByIDResponse;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByIDResponse %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByIDResponse*)p = *(struct dss__Set_AddDeviceByIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByName(struct soap *soap, struct dss__Set_AddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByName(struct soap *soap, const struct dss__Set_AddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByName(struct soap *soap, const struct dss__Set_AddDeviceByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByName);
	if (soap_out_dss__Set_AddDeviceByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByName(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByName * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByName(struct soap *soap, struct dss__Set_AddDeviceByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByName * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByName(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByName, sizeof(struct dss__Set_AddDeviceByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByName, 0, sizeof(struct dss__Set_AddDeviceByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByName * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByName(struct soap *soap, struct dss__Set_AddDeviceByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByName * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByName;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByName %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByName*)p = *(struct dss__Set_AddDeviceByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByNameResponse(struct soap *soap, struct dss__Set_AddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByNameResponse(struct soap *soap, const struct dss__Set_AddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByNameResponse(struct soap *soap, const struct dss__Set_AddDeviceByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByNameResponse);
	if (soap_out_dss__Set_AddDeviceByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByNameResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByNameResponse(struct soap *soap, struct dss__Set_AddDeviceByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByNameResponse(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByNameResponse, sizeof(struct dss__Set_AddDeviceByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByNameResponse, 0, sizeof(struct dss__Set_AddDeviceByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByNameResponse(struct soap *soap, struct dss__Set_AddDeviceByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByNameResponse;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByNameResponse %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByNameResponse*)p = *(struct dss__Set_AddDeviceByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDeviceIDByName(struct soap *soap, struct dss__Apartment_GetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDeviceIDByName(struct soap *soap, const struct dss__Apartment_GetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_deviceName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDeviceIDByName(struct soap *soap, const struct dss__Apartment_GetDeviceIDByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDeviceIDByName);
	if (soap_out_dss__Apartment_GetDeviceIDByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDeviceIDByName(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDeviceIDByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceName", -1, &a->_deviceName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC4 soap_get_dss__Apartment_GetDeviceIDByName(struct soap *soap, struct dss__Apartment_GetDeviceIDByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDeviceIDByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC4 soap_in_dss__Apartment_GetDeviceIDByName(struct soap *soap, const char *tag, struct dss__Apartment_GetDeviceIDByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDeviceIDByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByName, sizeof(struct dss__Apartment_GetDeviceIDByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDeviceIDByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceName, "xsd:string"))
				{	soap_flag__deviceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDeviceIDByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDeviceIDByName, 0, sizeof(struct dss__Apartment_GetDeviceIDByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC6 soap_new_dss__Apartment_GetDeviceIDByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDeviceIDByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDeviceIDByName(struct soap *soap, struct dss__Apartment_GetDeviceIDByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDeviceIDByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDeviceIDByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDeviceIDByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByName;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDeviceIDByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDeviceIDByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDeviceIDByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDeviceIDByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDeviceIDByName %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDeviceIDByName*)p = *(struct dss__Apartment_GetDeviceIDByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, struct dss__Apartment_GetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const struct dss__Apartment_GetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->deviceID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const struct dss__Apartment_GetDeviceIDByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse);
	if (soap_out_dss__Apartment_GetDeviceIDByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDeviceIDByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, struct dss__Apartment_GetDeviceIDByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDeviceIDByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetDeviceIDByNameResponse *a, const char *type)
{
	short soap_flag_deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDeviceIDByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse, sizeof(struct dss__Apartment_GetDeviceIDByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDeviceIDByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deviceID", &a->deviceID, "xsd:int"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDeviceIDByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse, 0, sizeof(struct dss__Apartment_GetDeviceIDByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, struct dss__Apartment_GetDeviceIDByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByNameResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDeviceIDByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDeviceIDByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDeviceIDByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDeviceIDByNameResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDeviceIDByNameResponse*)p = *(struct dss__Apartment_GetDeviceIDByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDevices(struct soap *soap, struct dss__Apartment_GetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDevices(struct soap *soap, const struct dss__Apartment_GetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDevices(struct soap *soap, const struct dss__Apartment_GetDevices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDevices);
	if (soap_out_dss__Apartment_GetDevices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDevices(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDevices), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDevices * SOAP_FMAC4 soap_get_dss__Apartment_GetDevices(struct soap *soap, struct dss__Apartment_GetDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDevices * SOAP_FMAC4 soap_in_dss__Apartment_GetDevices(struct soap *soap, const char *tag, struct dss__Apartment_GetDevices *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDevices, sizeof(struct dss__Apartment_GetDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDevices, 0, sizeof(struct dss__Apartment_GetDevices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDevices * SOAP_FMAC6 soap_new_dss__Apartment_GetDevices(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDevices(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDevices(struct soap *soap, struct dss__Apartment_GetDevices *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDevices * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevices;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDevices);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevices[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDevices);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDevices*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDevices %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDevices*)p = *(struct dss__Apartment_GetDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDevicesResponse(struct soap *soap, struct dss__Apartment_GetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDevicesResponse(struct soap *soap, const struct dss__Apartment_GetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDevicesResponse(struct soap *soap, const struct dss__Apartment_GetDevicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDevicesResponse);
	if (soap_out_dss__Apartment_GetDevicesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDevicesResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDevicesResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetDevicesResponse(struct soap *soap, struct dss__Apartment_GetDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetDevicesResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetDevicesResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDevicesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDevicesResponse, sizeof(struct dss__Apartment_GetDevicesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDevicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDevicesResponse, 0, sizeof(struct dss__Apartment_GetDevicesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetDevicesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDevicesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDevicesResponse(struct soap *soap, struct dss__Apartment_GetDevicesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevicesResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDevicesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevicesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDevicesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDevicesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDevicesResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDevicesResponse*)p = *(struct dss__Apartment_GetDevicesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateEmptySet(struct soap *soap, struct dss__Apartment_CreateEmptySet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateEmptySet(struct soap *soap, const struct dss__Apartment_CreateEmptySet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateEmptySet(struct soap *soap, const struct dss__Apartment_CreateEmptySet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateEmptySet);
	if (soap_out_dss__Apartment_CreateEmptySet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateEmptySet(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateEmptySet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateEmptySet), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySet * SOAP_FMAC4 soap_get_dss__Apartment_CreateEmptySet(struct soap *soap, struct dss__Apartment_CreateEmptySet *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateEmptySet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySet * SOAP_FMAC4 soap_in_dss__Apartment_CreateEmptySet(struct soap *soap, const char *tag, struct dss__Apartment_CreateEmptySet *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateEmptySet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateEmptySet, sizeof(struct dss__Apartment_CreateEmptySet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateEmptySet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateEmptySet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateEmptySet, 0, sizeof(struct dss__Apartment_CreateEmptySet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateEmptySet * SOAP_FMAC6 soap_new_dss__Apartment_CreateEmptySet(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateEmptySet(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateEmptySet(struct soap *soap, struct dss__Apartment_CreateEmptySet *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySet * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateEmptySet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateEmptySet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateEmptySet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySet;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateEmptySet);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySet[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateEmptySet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateEmptySet*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateEmptySet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateEmptySet %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateEmptySet*)p = *(struct dss__Apartment_CreateEmptySet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateEmptySetResponse(struct soap *soap, struct dss__Apartment_CreateEmptySetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const struct dss__Apartment_CreateEmptySetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const struct dss__Apartment_CreateEmptySetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse);
	if (soap_out_dss__Apartment_CreateEmptySetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateEmptySetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateEmptySetResponse(struct soap *soap, struct dss__Apartment_CreateEmptySetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateEmptySetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateEmptySetResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateEmptySetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse, sizeof(struct dss__Apartment_CreateEmptySetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateEmptySetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateEmptySetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse, 0, sizeof(struct dss__Apartment_CreateEmptySetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateEmptySetResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateEmptySetResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateEmptySetResponse(struct soap *soap, struct dss__Apartment_CreateEmptySetResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateEmptySetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateEmptySetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySetResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateEmptySetResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateEmptySetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateEmptySetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateEmptySetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateEmptySetResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateEmptySetResponse*)p = *(struct dss__Apartment_CreateEmptySetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	a->_names.StringArray::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_names, SOAP_TYPE_StringArray);
	a->_names.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNames *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames);
	if (soap_out_dss__Apartment_CreateSetFromDeviceNames(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (a->_names.soap_out(soap, "names", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceNames *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__names = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames, sizeof(struct dss__Apartment_CreateSetFromDeviceNames), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__names && soap->error == SOAP_TAG_MISMATCH)
				if (a->_names.soap_in(soap, NULL, "xsd:string"))
				{	soap_flag__names--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceNames), 0, soap_copy_dss__Apartment_CreateSetFromDeviceNames);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__names > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNames;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceNames);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNames[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceNames);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceNames*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceNames %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceNames*)p = *(struct dss__Apartment_CreateSetFromDeviceNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNamesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse);
	if (soap_out_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceNamesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceNamesResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceNamesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse, sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNamesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNamesResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNamesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceNamesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceNamesResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceNamesResponse*)p = *(struct dss__Apartment_CreateSetFromDeviceNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	a->_ids.IntArray::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	a->_ids.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs);
	if (soap_out_dss__Apartment_CreateSetFromDeviceIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (a->_ids.soap_out(soap, "ids", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceIDs *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__ids = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceIDs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs, sizeof(struct dss__Apartment_CreateSetFromDeviceIDs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__ids && soap->error == SOAP_TAG_MISMATCH)
				if (a->_ids.soap_in(soap, NULL, "xsd:int"))
				{	soap_flag__ids--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceIDs), 0, soap_copy_dss__Apartment_CreateSetFromDeviceIDs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__ids > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDs;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceIDs %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceIDs*)p = *(struct dss__Apartment_CreateSetFromDeviceIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse);
	if (soap_out_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceIDsResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceIDsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse, sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDsResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceIDsResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceIDsResponse*)p = *(struct dss__Apartment_CreateSetFromDeviceIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromGroup(struct soap *soap, struct dss__Apartment_CreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromGroup(struct soap *soap, const struct dss__Apartment_CreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromGroup(struct soap *soap, const struct dss__Apartment_CreateSetFromGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromGroup);
	if (soap_out_dss__Apartment_CreateSetFromGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromGroup(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromGroup(struct soap *soap, struct dss__Apartment_CreateSetFromGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromGroup(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroup, sizeof(struct dss__Apartment_CreateSetFromGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromGroup, 0, sizeof(struct dss__Apartment_CreateSetFromGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromGroup(struct soap *soap, struct dss__Apartment_CreateSetFromGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroup;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromGroup %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromGroup*)p = *(struct dss__Apartment_CreateSetFromGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, struct dss__Apartment_CreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse);
	if (soap_out_dss__Apartment_CreateSetFromGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, struct dss__Apartment_CreateSetFromGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromGroupResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse, sizeof(struct dss__Apartment_CreateSetFromGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse, 0, sizeof(struct dss__Apartment_CreateSetFromGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, struct dss__Apartment_CreateSetFromGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroupResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromGroupResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromGroupResponse*)p = *(struct dss__Apartment_CreateSetFromGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__FreeSet(struct soap *soap, struct dss__FreeSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__FreeSet(struct soap *soap, const struct dss__FreeSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
	soap_embedded(soap, &a->_setID, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__FreeSet(struct soap *soap, const struct dss__FreeSet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__FreeSet);
	if (soap_out_dss__FreeSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__FreeSet(struct soap *soap, const char *tag, int id, const struct dss__FreeSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__FreeSet), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__FreeSet * SOAP_FMAC4 soap_get_dss__FreeSet(struct soap *soap, struct dss__FreeSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__FreeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__FreeSet * SOAP_FMAC4 soap_in_dss__FreeSet(struct soap *soap, const char *tag, struct dss__FreeSet *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__FreeSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__FreeSet, sizeof(struct dss__FreeSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__FreeSet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__FreeSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__FreeSet, 0, sizeof(struct dss__FreeSet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__FreeSet * SOAP_FMAC6 soap_new_dss__FreeSet(struct soap *soap, int n)
{	return soap_instantiate_dss__FreeSet(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__FreeSet(struct soap *soap, struct dss__FreeSet *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__FreeSet * SOAP_FMAC4 soap_instantiate_dss__FreeSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__FreeSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__FreeSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__FreeSet;
		if (size)
			*size = sizeof(struct dss__FreeSet);
	}
	else
	{	cp->ptr = (void*)new struct dss__FreeSet[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__FreeSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__FreeSet*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__FreeSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__FreeSet %p -> %p\n", q, p));
	*(struct dss__FreeSet*)p = *(struct dss__FreeSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__FreeSetResponse(struct soap *soap, struct dss__FreeSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__FreeSetResponse(struct soap *soap, const struct dss__FreeSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__FreeSetResponse(struct soap *soap, const struct dss__FreeSetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__FreeSetResponse);
	if (soap_out_dss__FreeSetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__FreeSetResponse(struct soap *soap, const char *tag, int id, const struct dss__FreeSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__FreeSetResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__FreeSetResponse * SOAP_FMAC4 soap_get_dss__FreeSetResponse(struct soap *soap, struct dss__FreeSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__FreeSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__FreeSetResponse * SOAP_FMAC4 soap_in_dss__FreeSetResponse(struct soap *soap, const char *tag, struct dss__FreeSetResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__FreeSetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__FreeSetResponse, sizeof(struct dss__FreeSetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__FreeSetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__FreeSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__FreeSetResponse, 0, sizeof(struct dss__FreeSetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__FreeSetResponse * SOAP_FMAC6 soap_new_dss__FreeSetResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__FreeSetResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__FreeSetResponse(struct soap *soap, struct dss__FreeSetResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__FreeSetResponse * SOAP_FMAC4 soap_instantiate_dss__FreeSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__FreeSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__FreeSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__FreeSetResponse;
		if (size)
			*size = sizeof(struct dss__FreeSetResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__FreeSetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__FreeSetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__FreeSetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__FreeSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__FreeSetResponse %p -> %p\n", q, p));
	*(struct dss__FreeSetResponse*)p = *(struct dss__FreeSetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOff(struct soap *soap, struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOff(struct soap *soap, const struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOff(struct soap *soap, const struct dss__SignOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOff);
	if (soap_out_dss__SignOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOff(struct soap *soap, const char *tag, int id, const struct dss__SignOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_get_dss__SignOff(struct soap *soap, struct dss__SignOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_in_dss__SignOff(struct soap *soap, const char *tag, struct dss__SignOff *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOff, sizeof(struct dss__SignOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOff, 0, sizeof(struct dss__SignOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SignOff * SOAP_FMAC6 soap_new_dss__SignOff(struct soap *soap, int n)
{	return soap_instantiate_dss__SignOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SignOff(struct soap *soap, struct dss__SignOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_instantiate_dss__SignOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SignOff;
		if (size)
			*size = sizeof(struct dss__SignOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__SignOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOff %p -> %p\n", q, p));
	*(struct dss__SignOff*)p = *(struct dss__SignOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOffResponse);
	if (soap_out_dss__SignOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOffResponse(struct soap *soap, const char *tag, int id, const struct dss__SignOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOffResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_get_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_in_dss__SignOffResponse(struct soap *soap, const char *tag, struct dss__SignOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOffResponse, sizeof(struct dss__SignOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOffResponse, 0, sizeof(struct dss__SignOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SignOffResponse * SOAP_FMAC6 soap_new_dss__SignOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SignOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_instantiate_dss__SignOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SignOffResponse;
		if (size)
			*size = sizeof(struct dss__SignOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SignOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOffResponse %p -> %p\n", q, p));
	*(struct dss__SignOffResponse*)p = *(struct dss__SignOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Authenticate(struct soap *soap, struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_userName);
	soap_default_string(soap, &a->_password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_userName);
	soap_serialize_string(soap, &a->_password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Authenticate);
	if (soap_out_dss__Authenticate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Authenticate(struct soap *soap, const char *tag, int id, const struct dss__Authenticate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Authenticate), type))
		return soap->error;
	if (soap_out_string(soap, "userName", -1, &a->_userName, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->_password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_get_dss__Authenticate(struct soap *soap, struct dss__Authenticate *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Authenticate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_in_dss__Authenticate(struct soap *soap, const char *tag, struct dss__Authenticate *a, const char *type)
{
	short soap_flag__userName = 1, soap_flag__password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Authenticate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Authenticate, sizeof(struct dss__Authenticate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Authenticate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__userName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_userName, "xsd:string"))
				{	soap_flag__userName--;
					continue;
				}
			if (soap_flag__password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_password, "xsd:string"))
				{	soap_flag__password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Authenticate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Authenticate, 0, sizeof(struct dss__Authenticate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Authenticate * SOAP_FMAC6 soap_new_dss__Authenticate(struct soap *soap, int n)
{	return soap_instantiate_dss__Authenticate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Authenticate(struct soap *soap, struct dss__Authenticate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_instantiate_dss__Authenticate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Authenticate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Authenticate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Authenticate;
		if (size)
			*size = sizeof(struct dss__Authenticate);
	}
	else
	{	cp->ptr = (void*)new struct dss__Authenticate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Authenticate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Authenticate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Authenticate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Authenticate %p -> %p\n", q, p));
	*(struct dss__Authenticate*)p = *(struct dss__Authenticate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->token, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__AuthenticateResponse);
	if (soap_out_dss__AuthenticateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__AuthenticateResponse(struct soap *soap, const char *tag, int id, const struct dss__AuthenticateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__AuthenticateResponse), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_get_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__AuthenticateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_in_dss__AuthenticateResponse(struct soap *soap, const char *tag, struct dss__AuthenticateResponse *a, const char *type)
{
	short soap_flag_token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__AuthenticateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__AuthenticateResponse, sizeof(struct dss__AuthenticateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__AuthenticateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "token", &a->token, "xsd:int"))
				{	soap_flag_token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__AuthenticateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__AuthenticateResponse, 0, sizeof(struct dss__AuthenticateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__AuthenticateResponse * SOAP_FMAC6 soap_new_dss__AuthenticateResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__AuthenticateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_instantiate_dss__AuthenticateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__AuthenticateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__AuthenticateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__AuthenticateResponse;
		if (size)
			*size = sizeof(struct dss__AuthenticateResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__AuthenticateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__AuthenticateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__AuthenticateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__AuthenticateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__AuthenticateResponse %p -> %p\n", q, p));
	*(struct dss__AuthenticateResponse*)p = *(struct dss__AuthenticateResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToStringArray(struct soap *soap, StringArray *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToStringArray(struct soap *soap, StringArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToStringArray);
	if (soap_out_PointerToStringArray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToStringArray(struct soap *soap, const char *tag, int id, StringArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_StringArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 StringArray ** SOAP_FMAC4 soap_get_PointerToStringArray(struct soap *soap, StringArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToStringArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 StringArray ** SOAP_FMAC4 soap_in_PointerToStringArray(struct soap *soap, const char *tag, StringArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (StringArray **)soap_malloc(soap, sizeof(StringArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (StringArray *)soap_instantiate_StringArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	StringArray ** p = (StringArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_StringArray, sizeof(StringArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */
