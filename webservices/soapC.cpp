/* soapC.cpp
   Generated by gSOAP 2.7.10 from model_soap.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.10 2009-01-23 19:03:30 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_dss__outParameter:
		return soap_in_dss__outParameter(soap, NULL, NULL, "dss:outParameter");
	case SOAP_TYPE_dss__inParameter:
		return soap_in_dss__inParameter(soap, NULL, NULL, "dss:inParameter");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		return soap_in_dss__Event_DeleteSchedule(soap, NULL, NULL, "dss:Event-DeleteSchedule");
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		return soap_in_dss__Event_DeleteScheduleResponse(soap, NULL, NULL, "dss:Event-DeleteScheduleResponse");
	case SOAP_TYPE_dss__Event_Schedule:
		return soap_in_dss__Event_Schedule(soap, NULL, NULL, "dss:Event-Schedule");
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		return soap_in_dss__Event_ScheduleResponse(soap, NULL, NULL, "dss:Event-ScheduleResponse");
	case SOAP_TYPE_dss__Event_Unsubscribe:
		return soap_in_dss__Event_Unsubscribe(soap, NULL, NULL, "dss:Event-Unsubscribe");
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		return soap_in_dss__Event_UnsubscribeResponse(soap, NULL, NULL, "dss:Event-UnsubscribeResponse");
	case SOAP_TYPE_dss__Event_Subscribe:
		return soap_in_dss__Event_Subscribe(soap, NULL, NULL, "dss:Event-Subscribe");
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		return soap_in_dss__Event_SubscribeResponse(soap, NULL, NULL, "dss:Event-SubscribeResponse");
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		return soap_in_dss__Event_GetActionParamsTemplate(soap, NULL, NULL, "dss:Event-GetActionParamsTemplate");
	case SOAP_TYPE_dss__Event_GetActionNames:
		return soap_in_dss__Event_GetActionNames(soap, NULL, NULL, "dss:Event-GetActionNames");
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		return soap_in_dss__Event_GetActionNamesResponse(soap, NULL, NULL, "dss:Event-GetActionNamesResponse");
	case SOAP_TYPE_dss__Event_Raise:
		return soap_in_dss__Event_Raise(soap, NULL, NULL, "dss:Event-Raise");
	case SOAP_TYPE_dss__Event_RaiseResponse:
		return soap_in_dss__Event_RaiseResponse(soap, NULL, NULL, "dss:Event-RaiseResponse");
	case SOAP_TYPE_dss__Switch_SimulateKeypress:
		return soap_in_dss__Switch_SimulateKeypress(soap, NULL, NULL, "dss:Switch-SimulateKeypress");
	case SOAP_TYPE_dss__Switch_SimulateKeypressResponse:
		return soap_in_dss__Switch_SimulateKeypressResponse(soap, NULL, NULL, "dss:Switch-SimulateKeypressResponse");
	case SOAP_TYPE_dss__Switch_GetGroupID:
		return soap_in_dss__Switch_GetGroupID(soap, NULL, NULL, "dss:Switch-GetGroupID");
	case SOAP_TYPE_dss__Switch_GetGroupIDResponse:
		return soap_in_dss__Switch_GetGroupIDResponse(soap, NULL, NULL, "dss:Switch-GetGroupIDResponse");
	case SOAP_TYPE_dss__Device_GetFunctionID:
		return soap_in_dss__Device_GetFunctionID(soap, NULL, NULL, "dss:Device-GetFunctionID");
	case SOAP_TYPE_dss__Device_GetFunctionIDResponse:
		return soap_in_dss__Device_GetFunctionIDResponse(soap, NULL, NULL, "dss:Device-GetFunctionIDResponse");
	case SOAP_TYPE_dss__Group_RemoveDevice:
		return soap_in_dss__Group_RemoveDevice(soap, NULL, NULL, "dss:Group-RemoveDevice");
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		return soap_in_dss__Group_RemoveDeviceResponse(soap, NULL, NULL, "dss:Group-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Group_AddDevice:
		return soap_in_dss__Group_AddDevice(soap, NULL, NULL, "dss:Group-AddDevice");
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		return soap_in_dss__Group_AddDeviceResponse(soap, NULL, NULL, "dss:Group-AddDeviceResponse");
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		return soap_in_dss__Group_RemoveUserGroup(soap, NULL, NULL, "dss:Group-RemoveUserGroup");
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		return soap_in_dss__Group_RemoveUserGroupResponse(soap, NULL, NULL, "dss:Group-RemoveUserGroupResponse");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		return soap_in_dss__Apartment_AllocateUserGroup(soap, NULL, NULL, "dss:Apartment-AllocateUserGroup");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		return soap_in_dss__Apartment_AllocateUserGroupResponse(soap, NULL, NULL, "dss:Apartment-AllocateUserGroupResponse");
	case SOAP_TYPE_dss__Zone_SetName:
		return soap_in_dss__Zone_SetName(soap, NULL, NULL, "dss:Zone-SetName");
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		return soap_in_dss__Zone_SetNameResponse(soap, NULL, NULL, "dss:Zone-SetNameResponse");
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		return soap_in_dss__Zone_RemoveDevice(soap, NULL, NULL, "dss:Zone-RemoveDevice");
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		return soap_in_dss__Zone_RemoveDeviceResponse(soap, NULL, NULL, "dss:Zone-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Zone_AddDevice:
		return soap_in_dss__Zone_AddDevice(soap, NULL, NULL, "dss:Zone-AddDevice");
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		return soap_in_dss__Zone_AddDeviceResponse(soap, NULL, NULL, "dss:Zone-AddDeviceResponse");
	case SOAP_TYPE_dss__Apartment_DeleteZone:
		return soap_in_dss__Apartment_DeleteZone(soap, NULL, NULL, "dss:Apartment-DeleteZone");
	case SOAP_TYPE_dss__Apartment_DeleteZoneResponse:
		return soap_in_dss__Apartment_DeleteZoneResponse(soap, NULL, NULL, "dss:Apartment-DeleteZoneResponse");
	case SOAP_TYPE_dss__Apartment_AllocateZone:
		return soap_in_dss__Apartment_AllocateZone(soap, NULL, NULL, "dss:Apartment-AllocateZone");
	case SOAP_TYPE_dss__Apartment_AllocateZoneResponse:
		return soap_in_dss__Apartment_AllocateZoneResponse(soap, NULL, NULL, "dss:Apartment-AllocateZoneResponse");
	case SOAP_TYPE_dss__Modulator_GetName:
		return soap_in_dss__Modulator_GetName(soap, NULL, NULL, "dss:Modulator-GetName");
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		return soap_in_dss__Modulator_GetNameResponse(soap, NULL, NULL, "dss:Modulator-GetNameResponse");
	case SOAP_TYPE_dss__Modulator_GetDSID:
		return soap_in_dss__Modulator_GetDSID(soap, NULL, NULL, "dss:Modulator-GetDSID");
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		return soap_in_dss__Modulator_GetDSIDResponse(soap, NULL, NULL, "dss:Modulator-GetDSIDResponse");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		return soap_in_dss__Apartment_GetModulatorIDs(soap, NULL, NULL, "dss:Apartment-GetModulatorIDs");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		return soap_in_dss__Apartment_GetModulatorIDsResponse(soap, NULL, NULL, "dss:Apartment-GetModulatorIDsResponse");
	case SOAP_TYPE_dss__Modulator_GetPowerConsumption:
		return soap_in_dss__Modulator_GetPowerConsumption(soap, NULL, NULL, "dss:Modulator-GetPowerConsumption");
	case SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse:
		return soap_in_dss__Modulator_GetPowerConsumptionResponse(soap, NULL, NULL, "dss:Modulator-GetPowerConsumptionResponse");
	case SOAP_TYPE_dss__Device_GetDSID:
		return soap_in_dss__Device_GetDSID(soap, NULL, NULL, "dss:Device-GetDSID");
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		return soap_in_dss__Device_GetDSIDResponse(soap, NULL, NULL, "dss:Device-GetDSIDResponse");
	case SOAP_TYPE_dss__Device_GetZoneID:
		return soap_in_dss__Device_GetZoneID(soap, NULL, NULL, "dss:Device-GetZoneID");
	case SOAP_TYPE_dss__Device_GetZoneIDResponse:
		return soap_in_dss__Device_GetZoneIDResponse(soap, NULL, NULL, "dss:Device-GetZoneIDResponse");
	case SOAP_TYPE_dss__Device_GetName:
		return soap_in_dss__Device_GetName(soap, NULL, NULL, "dss:Device-GetName");
	case SOAP_TYPE_dss__Device_GetNameResponse:
		return soap_in_dss__Device_GetNameResponse(soap, NULL, NULL, "dss:Device-GetNameResponse");
	case SOAP_TYPE_dss__Device_SaveScene:
		return soap_in_dss__Device_SaveScene(soap, NULL, NULL, "dss:Device-SaveScene");
	case SOAP_TYPE_dss__Device_SaveSceneResponse:
		return soap_in_dss__Device_SaveSceneResponse(soap, NULL, NULL, "dss:Device-SaveSceneResponse");
	case SOAP_TYPE_dss__Device_CallScene:
		return soap_in_dss__Device_CallScene(soap, NULL, NULL, "dss:Device-CallScene");
	case SOAP_TYPE_dss__Device_CallSceneResponse:
		return soap_in_dss__Device_CallSceneResponse(soap, NULL, NULL, "dss:Device-CallSceneResponse");
	case SOAP_TYPE_dss__Device_GetValue:
		return soap_in_dss__Device_GetValue(soap, NULL, NULL, "dss:Device-GetValue");
	case SOAP_TYPE_dss__Device_GetValueResponse:
		return soap_in_dss__Device_GetValueResponse(soap, NULL, NULL, "dss:Device-GetValueResponse");
	case SOAP_TYPE_dss__Device_SetValue:
		return soap_in_dss__Device_SetValue(soap, NULL, NULL, "dss:Device-SetValue");
	case SOAP_TYPE_dss__Device_SetValueResponse:
		return soap_in_dss__Device_SetValueResponse(soap, NULL, NULL, "dss:Device-SetValueResponse");
	case SOAP_TYPE_dss__Device_EndDim:
		return soap_in_dss__Device_EndDim(soap, NULL, NULL, "dss:Device-EndDim");
	case SOAP_TYPE_dss__Device_EndDimResponse:
		return soap_in_dss__Device_EndDimResponse(soap, NULL, NULL, "dss:Device-EndDimResponse");
	case SOAP_TYPE_dss__Device_StartDim:
		return soap_in_dss__Device_StartDim(soap, NULL, NULL, "dss:Device-StartDim");
	case SOAP_TYPE_dss__Device_StartDimResponse:
		return soap_in_dss__Device_StartDimResponse(soap, NULL, NULL, "dss:Device-StartDimResponse");
	case SOAP_TYPE_dss__Device_Disable:
		return soap_in_dss__Device_Disable(soap, NULL, NULL, "dss:Device-Disable");
	case SOAP_TYPE_dss__Device_DisableResponse:
		return soap_in_dss__Device_DisableResponse(soap, NULL, NULL, "dss:Device-DisableResponse");
	case SOAP_TYPE_dss__Device_Enable:
		return soap_in_dss__Device_Enable(soap, NULL, NULL, "dss:Device-Enable");
	case SOAP_TYPE_dss__Device_EnableResponse:
		return soap_in_dss__Device_EnableResponse(soap, NULL, NULL, "dss:Device-EnableResponse");
	case SOAP_TYPE_dss__Device_DecreaseValue:
		return soap_in_dss__Device_DecreaseValue(soap, NULL, NULL, "dss:Device-DecreaseValue");
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		return soap_in_dss__Device_DecreaseValueResponse(soap, NULL, NULL, "dss:Device-DecreaseValueResponse");
	case SOAP_TYPE_dss__Device_IncreaseValue:
		return soap_in_dss__Device_IncreaseValue(soap, NULL, NULL, "dss:Device-IncreaseValue");
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		return soap_in_dss__Device_IncreaseValueResponse(soap, NULL, NULL, "dss:Device-IncreaseValueResponse");
	case SOAP_TYPE_dss__Device_TurnOff:
		return soap_in_dss__Device_TurnOff(soap, NULL, NULL, "dss:Device-TurnOff");
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		return soap_in_dss__Device_TurnOffResponse(soap, NULL, NULL, "dss:Device-TurnOffResponse");
	case SOAP_TYPE_dss__Device_TurnOn:
		return soap_in_dss__Device_TurnOn(soap, NULL, NULL, "dss:Device-TurnOn");
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		return soap_in_dss__Device_TurnOnResponse(soap, NULL, NULL, "dss:Device-TurnOnResponse");
	case SOAP_TYPE_dss__Group_SaveScene:
		return soap_in_dss__Group_SaveScene(soap, NULL, NULL, "dss:Group-SaveScene");
	case SOAP_TYPE_dss__Group_SaveSceneResponse:
		return soap_in_dss__Group_SaveSceneResponse(soap, NULL, NULL, "dss:Group-SaveSceneResponse");
	case SOAP_TYPE_dss__Group_CallScene:
		return soap_in_dss__Group_CallScene(soap, NULL, NULL, "dss:Group-CallScene");
	case SOAP_TYPE_dss__Group_CallSceneResponse:
		return soap_in_dss__Group_CallSceneResponse(soap, NULL, NULL, "dss:Group-CallSceneResponse");
	case SOAP_TYPE_dss__Group_SetValue:
		return soap_in_dss__Group_SetValue(soap, NULL, NULL, "dss:Group-SetValue");
	case SOAP_TYPE_dss__Group_SetValueResponse:
		return soap_in_dss__Group_SetValueResponse(soap, NULL, NULL, "dss:Group-SetValueResponse");
	case SOAP_TYPE_dss__Group_EndDim:
		return soap_in_dss__Group_EndDim(soap, NULL, NULL, "dss:Group-EndDim");
	case SOAP_TYPE_dss__Group_EndDimResponse:
		return soap_in_dss__Group_EndDimResponse(soap, NULL, NULL, "dss:Group-EndDimResponse");
	case SOAP_TYPE_dss__Group_StartDim:
		return soap_in_dss__Group_StartDim(soap, NULL, NULL, "dss:Group-StartDim");
	case SOAP_TYPE_dss__Group_StartDimResponse:
		return soap_in_dss__Group_StartDimResponse(soap, NULL, NULL, "dss:Group-StartDimResponse");
	case SOAP_TYPE_dss__Group_Disable:
		return soap_in_dss__Group_Disable(soap, NULL, NULL, "dss:Group-Disable");
	case SOAP_TYPE_dss__Group_DisableResponse:
		return soap_in_dss__Group_DisableResponse(soap, NULL, NULL, "dss:Group-DisableResponse");
	case SOAP_TYPE_dss__Group_Enable:
		return soap_in_dss__Group_Enable(soap, NULL, NULL, "dss:Group-Enable");
	case SOAP_TYPE_dss__Group_EnableResponse:
		return soap_in_dss__Group_EnableResponse(soap, NULL, NULL, "dss:Group-EnableResponse");
	case SOAP_TYPE_dss__Group_DecreaseValue:
		return soap_in_dss__Group_DecreaseValue(soap, NULL, NULL, "dss:Group-DecreaseValue");
	case SOAP_TYPE_dss__Group_DecreaseValueResponse:
		return soap_in_dss__Group_DecreaseValueResponse(soap, NULL, NULL, "dss:Group-DecreaseValueResponse");
	case SOAP_TYPE_dss__Group_IncreaseValue:
		return soap_in_dss__Group_IncreaseValue(soap, NULL, NULL, "dss:Group-IncreaseValue");
	case SOAP_TYPE_dss__Group_IncreaseValueResponse:
		return soap_in_dss__Group_IncreaseValueResponse(soap, NULL, NULL, "dss:Group-IncreaseValueResponse");
	case SOAP_TYPE_dss__Group_TurnOff:
		return soap_in_dss__Group_TurnOff(soap, NULL, NULL, "dss:Group-TurnOff");
	case SOAP_TYPE_dss__Group_TurnOffResponse:
		return soap_in_dss__Group_TurnOffResponse(soap, NULL, NULL, "dss:Group-TurnOffResponse");
	case SOAP_TYPE_dss__Group_TurnOn:
		return soap_in_dss__Group_TurnOn(soap, NULL, NULL, "dss:Group-TurnOn");
	case SOAP_TYPE_dss__Group_TurnOnResponse:
		return soap_in_dss__Group_TurnOnResponse(soap, NULL, NULL, "dss:Group-TurnOnResponse");
	case SOAP_TYPE_dss__Set_SaveScene:
		return soap_in_dss__Set_SaveScene(soap, NULL, NULL, "dss:Set-SaveScene");
	case SOAP_TYPE_dss__Set_SaveSceneResponse:
		return soap_in_dss__Set_SaveSceneResponse(soap, NULL, NULL, "dss:Set-SaveSceneResponse");
	case SOAP_TYPE_dss__Set_CallScene:
		return soap_in_dss__Set_CallScene(soap, NULL, NULL, "dss:Set-CallScene");
	case SOAP_TYPE_dss__Set_CallSceneResponse:
		return soap_in_dss__Set_CallSceneResponse(soap, NULL, NULL, "dss:Set-CallSceneResponse");
	case SOAP_TYPE_dss__Set_SetValue:
		return soap_in_dss__Set_SetValue(soap, NULL, NULL, "dss:Set-SetValue");
	case SOAP_TYPE_dss__Set_SetValueResponse:
		return soap_in_dss__Set_SetValueResponse(soap, NULL, NULL, "dss:Set-SetValueResponse");
	case SOAP_TYPE_dss__Set_EndDim:
		return soap_in_dss__Set_EndDim(soap, NULL, NULL, "dss:Set-EndDim");
	case SOAP_TYPE_dss__Set_EndDimResponse:
		return soap_in_dss__Set_EndDimResponse(soap, NULL, NULL, "dss:Set-EndDimResponse");
	case SOAP_TYPE_dss__Set_StartDim:
		return soap_in_dss__Set_StartDim(soap, NULL, NULL, "dss:Set-StartDim");
	case SOAP_TYPE_dss__Set_StartDimResponse:
		return soap_in_dss__Set_StartDimResponse(soap, NULL, NULL, "dss:Set-StartDimResponse");
	case SOAP_TYPE_dss__Set_Disable:
		return soap_in_dss__Set_Disable(soap, NULL, NULL, "dss:Set-Disable");
	case SOAP_TYPE_dss__Set_DisableResponse:
		return soap_in_dss__Set_DisableResponse(soap, NULL, NULL, "dss:Set-DisableResponse");
	case SOAP_TYPE_dss__Set_Enable:
		return soap_in_dss__Set_Enable(soap, NULL, NULL, "dss:Set-Enable");
	case SOAP_TYPE_dss__Set_EnableResponse:
		return soap_in_dss__Set_EnableResponse(soap, NULL, NULL, "dss:Set-EnableResponse");
	case SOAP_TYPE_dss__Set_DecreaseValue:
		return soap_in_dss__Set_DecreaseValue(soap, NULL, NULL, "dss:Set-DecreaseValue");
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		return soap_in_dss__Set_DecreaseValueResponse(soap, NULL, NULL, "dss:Set-DecreaseValueResponse");
	case SOAP_TYPE_dss__Set_IncreaseValue:
		return soap_in_dss__Set_IncreaseValue(soap, NULL, NULL, "dss:Set-IncreaseValue");
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		return soap_in_dss__Set_IncreaseValueResponse(soap, NULL, NULL, "dss:Set-IncreaseValueResponse");
	case SOAP_TYPE_dss__Set_TurnOff:
		return soap_in_dss__Set_TurnOff(soap, NULL, NULL, "dss:Set-TurnOff");
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		return soap_in_dss__Set_TurnOffResponse(soap, NULL, NULL, "dss:Set-TurnOffResponse");
	case SOAP_TYPE_dss__Set_TurnOn:
		return soap_in_dss__Set_TurnOn(soap, NULL, NULL, "dss:Set-TurnOn");
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		return soap_in_dss__Set_TurnOnResponse(soap, NULL, NULL, "dss:Set-TurnOnResponse");
	case SOAP_TYPE_dss__Apartment_GetZoneIDs:
		return soap_in_dss__Apartment_GetZoneIDs(soap, NULL, NULL, "dss:Apartment-GetZoneIDs");
	case SOAP_TYPE_dss__Apartment_GetZoneIDsResponse:
		return soap_in_dss__Apartment_GetZoneIDsResponse(soap, NULL, NULL, "dss:Apartment-GetZoneIDsResponse");
	case SOAP_TYPE_dss__Apartment_GetZoneByName:
		return soap_in_dss__Apartment_GetZoneByName(soap, NULL, NULL, "dss:Apartment-GetZoneByName");
	case SOAP_TYPE_dss__Apartment_GetZoneByNameResponse:
		return soap_in_dss__Apartment_GetZoneByNameResponse(soap, NULL, NULL, "dss:Apartment-GetZoneByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		return soap_in_dss__Apartment_GetGroupByName(soap, NULL, NULL, "dss:Apartment-GetGroupByName");
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		return soap_in_dss__Apartment_GetGroupByNameResponse(soap, NULL, NULL, "dss:Apartment-GetGroupByNameResponse");
	case SOAP_TYPE_dss__Set_GetContainedDevices:
		return soap_in_dss__Set_GetContainedDevices(soap, NULL, NULL, "dss:Set-GetContainedDevices");
	case SOAP_TYPE_dss__Set_GetContainedDevicesResponse:
		return soap_in_dss__Set_GetContainedDevicesResponse(soap, NULL, NULL, "dss:Set-GetContainedDevicesResponse");
	case SOAP_TYPE_dss__Set_ByGroup:
		return soap_in_dss__Set_ByGroup(soap, NULL, NULL, "dss:Set-ByGroup");
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		return soap_in_dss__Set_ByGroupResponse(soap, NULL, NULL, "dss:Set-ByGroupResponse");
	case SOAP_TYPE_dss__Set_Remove:
		return soap_in_dss__Set_Remove(soap, NULL, NULL, "dss:Set-Remove");
	case SOAP_TYPE_dss__Set_RemoveResponse:
		return soap_in_dss__Set_RemoveResponse(soap, NULL, NULL, "dss:Set-RemoveResponse");
	case SOAP_TYPE_dss__Set_Combine:
		return soap_in_dss__Set_Combine(soap, NULL, NULL, "dss:Set-Combine");
	case SOAP_TYPE_dss__Set_CombineResponse:
		return soap_in_dss__Set_CombineResponse(soap, NULL, NULL, "dss:Set-CombineResponse");
	case SOAP_TYPE_dss__Set_RemoveDevice:
		return soap_in_dss__Set_RemoveDevice(soap, NULL, NULL, "dss:Set-RemoveDevice");
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		return soap_in_dss__Set_RemoveDeviceResponse(soap, NULL, NULL, "dss:Set-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		return soap_in_dss__Set_AddDeviceByID(soap, NULL, NULL, "dss:Set-AddDeviceByID");
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		return soap_in_dss__Set_AddDeviceByIDResponse(soap, NULL, NULL, "dss:Set-AddDeviceByIDResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		return soap_in_dss__Set_AddDeviceByName(soap, NULL, NULL, "dss:Set-AddDeviceByName");
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		return soap_in_dss__Set_AddDeviceByNameResponse(soap, NULL, NULL, "dss:Set-AddDeviceByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		return soap_in_dss__Apartment_GetDeviceIDByName(soap, NULL, NULL, "dss:Apartment-GetDeviceIDByName");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		return soap_in_dss__Apartment_GetDeviceIDByNameResponse(soap, NULL, NULL, "dss:Apartment-GetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDevices:
		return soap_in_dss__Apartment_GetDevices(soap, NULL, NULL, "dss:Apartment-GetDevices");
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		return soap_in_dss__Apartment_GetDevicesResponse(soap, NULL, NULL, "dss:Apartment-GetDevicesResponse");
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		return soap_in_dss__Apartment_CreateEmptySet(soap, NULL, NULL, "dss:Apartment-CreateEmptySet");
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		return soap_in_dss__Apartment_CreateEmptySetResponse(soap, NULL, NULL, "dss:Apartment-CreateEmptySetResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		return soap_in_dss__Apartment_CreateSetFromDeviceNames(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceNames");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		return soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		return soap_in_dss__Apartment_CreateSetFromDeviceIDs(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		return soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, NULL, NULL, "dss:Apartment-CreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		return soap_in_dss__Apartment_CreateSetFromGroup(soap, NULL, NULL, "dss:Apartment-CreateSetFromGroup");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		return soap_in_dss__Apartment_CreateSetFromGroupResponse(soap, NULL, NULL, "dss:Apartment-CreateSetFromGroupResponse");
	case SOAP_TYPE_dss__FreeSet:
		return soap_in_dss__FreeSet(soap, NULL, NULL, "dss:FreeSet");
	case SOAP_TYPE_dss__FreeSetResponse:
		return soap_in_dss__FreeSetResponse(soap, NULL, NULL, "dss:FreeSetResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_in_dss__SignOff(soap, NULL, NULL, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_in_dss__SignOffResponse(soap, NULL, NULL, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_in_dss__Authenticate(soap, NULL, NULL, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, "dss:AuthenticateResponse");
	case SOAP_TYPE_dss__Test:
		return soap_in_dss__Test(soap, NULL, NULL, "dss:Test");
	case SOAP_TYPE_dss__TestResponse:
		return soap_in_dss__TestResponse(soap, NULL, NULL, "dss:TestResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "dss:outParameter"))
		{	*type = SOAP_TYPE_dss__outParameter;
			return soap_in_dss__outParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:inParameter"))
		{	*type = SOAP_TYPE_dss__inParameter;
			return soap_in_dss__inParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-DeleteSchedule"))
		{	*type = SOAP_TYPE_dss__Event_DeleteSchedule;
			return soap_in_dss__Event_DeleteSchedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-DeleteScheduleResponse"))
		{	*type = SOAP_TYPE_dss__Event_DeleteScheduleResponse;
			return soap_in_dss__Event_DeleteScheduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Schedule"))
		{	*type = SOAP_TYPE_dss__Event_Schedule;
			return soap_in_dss__Event_Schedule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-ScheduleResponse"))
		{	*type = SOAP_TYPE_dss__Event_ScheduleResponse;
			return soap_in_dss__Event_ScheduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Unsubscribe"))
		{	*type = SOAP_TYPE_dss__Event_Unsubscribe;
			return soap_in_dss__Event_Unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-UnsubscribeResponse"))
		{	*type = SOAP_TYPE_dss__Event_UnsubscribeResponse;
			return soap_in_dss__Event_UnsubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Subscribe"))
		{	*type = SOAP_TYPE_dss__Event_Subscribe;
			return soap_in_dss__Event_Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-SubscribeResponse"))
		{	*type = SOAP_TYPE_dss__Event_SubscribeResponse;
			return soap_in_dss__Event_SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-GetActionParamsTemplate"))
		{	*type = SOAP_TYPE_dss__Event_GetActionParamsTemplate;
			return soap_in_dss__Event_GetActionParamsTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-GetActionNames"))
		{	*type = SOAP_TYPE_dss__Event_GetActionNames;
			return soap_in_dss__Event_GetActionNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-GetActionNamesResponse"))
		{	*type = SOAP_TYPE_dss__Event_GetActionNamesResponse;
			return soap_in_dss__Event_GetActionNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-Raise"))
		{	*type = SOAP_TYPE_dss__Event_Raise;
			return soap_in_dss__Event_Raise(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Event-RaiseResponse"))
		{	*type = SOAP_TYPE_dss__Event_RaiseResponse;
			return soap_in_dss__Event_RaiseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Switch-SimulateKeypress"))
		{	*type = SOAP_TYPE_dss__Switch_SimulateKeypress;
			return soap_in_dss__Switch_SimulateKeypress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Switch-SimulateKeypressResponse"))
		{	*type = SOAP_TYPE_dss__Switch_SimulateKeypressResponse;
			return soap_in_dss__Switch_SimulateKeypressResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Switch-GetGroupID"))
		{	*type = SOAP_TYPE_dss__Switch_GetGroupID;
			return soap_in_dss__Switch_GetGroupID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Switch-GetGroupIDResponse"))
		{	*type = SOAP_TYPE_dss__Switch_GetGroupIDResponse;
			return soap_in_dss__Switch_GetGroupIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetFunctionID"))
		{	*type = SOAP_TYPE_dss__Device_GetFunctionID;
			return soap_in_dss__Device_GetFunctionID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetFunctionIDResponse"))
		{	*type = SOAP_TYPE_dss__Device_GetFunctionIDResponse;
			return soap_in_dss__Device_GetFunctionIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveDevice"))
		{	*type = SOAP_TYPE_dss__Group_RemoveDevice;
			return soap_in_dss__Group_RemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Group_RemoveDeviceResponse;
			return soap_in_dss__Group_RemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-AddDevice"))
		{	*type = SOAP_TYPE_dss__Group_AddDevice;
			return soap_in_dss__Group_AddDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-AddDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Group_AddDeviceResponse;
			return soap_in_dss__Group_AddDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveUserGroup"))
		{	*type = SOAP_TYPE_dss__Group_RemoveUserGroup;
			return soap_in_dss__Group_RemoveUserGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-RemoveUserGroupResponse"))
		{	*type = SOAP_TYPE_dss__Group_RemoveUserGroupResponse;
			return soap_in_dss__Group_RemoveUserGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateUserGroup"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateUserGroup;
			return soap_in_dss__Apartment_AllocateUserGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateUserGroupResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse;
			return soap_in_dss__Apartment_AllocateUserGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-SetName"))
		{	*type = SOAP_TYPE_dss__Zone_SetName;
			return soap_in_dss__Zone_SetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-SetNameResponse"))
		{	*type = SOAP_TYPE_dss__Zone_SetNameResponse;
			return soap_in_dss__Zone_SetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-RemoveDevice"))
		{	*type = SOAP_TYPE_dss__Zone_RemoveDevice;
			return soap_in_dss__Zone_RemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-RemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Zone_RemoveDeviceResponse;
			return soap_in_dss__Zone_RemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-AddDevice"))
		{	*type = SOAP_TYPE_dss__Zone_AddDevice;
			return soap_in_dss__Zone_AddDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-AddDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Zone_AddDeviceResponse;
			return soap_in_dss__Zone_AddDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-DeleteZone"))
		{	*type = SOAP_TYPE_dss__Apartment_DeleteZone;
			return soap_in_dss__Apartment_DeleteZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-DeleteZoneResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_DeleteZoneResponse;
			return soap_in_dss__Apartment_DeleteZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateZone"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateZone;
			return soap_in_dss__Apartment_AllocateZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-AllocateZoneResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_AllocateZoneResponse;
			return soap_in_dss__Apartment_AllocateZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetName"))
		{	*type = SOAP_TYPE_dss__Modulator_GetName;
			return soap_in_dss__Modulator_GetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetNameResponse"))
		{	*type = SOAP_TYPE_dss__Modulator_GetNameResponse;
			return soap_in_dss__Modulator_GetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetDSID"))
		{	*type = SOAP_TYPE_dss__Modulator_GetDSID;
			return soap_in_dss__Modulator_GetDSID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetDSIDResponse"))
		{	*type = SOAP_TYPE_dss__Modulator_GetDSIDResponse;
			return soap_in_dss__Modulator_GetDSIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetModulatorIDs"))
		{	*type = SOAP_TYPE_dss__Apartment_GetModulatorIDs;
			return soap_in_dss__Apartment_GetModulatorIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetModulatorIDsResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse;
			return soap_in_dss__Apartment_GetModulatorIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetPowerConsumption"))
		{	*type = SOAP_TYPE_dss__Modulator_GetPowerConsumption;
			return soap_in_dss__Modulator_GetPowerConsumption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Modulator-GetPowerConsumptionResponse"))
		{	*type = SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse;
			return soap_in_dss__Modulator_GetPowerConsumptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetDSID"))
		{	*type = SOAP_TYPE_dss__Device_GetDSID;
			return soap_in_dss__Device_GetDSID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetDSIDResponse"))
		{	*type = SOAP_TYPE_dss__Device_GetDSIDResponse;
			return soap_in_dss__Device_GetDSIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetZoneID"))
		{	*type = SOAP_TYPE_dss__Device_GetZoneID;
			return soap_in_dss__Device_GetZoneID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetZoneIDResponse"))
		{	*type = SOAP_TYPE_dss__Device_GetZoneIDResponse;
			return soap_in_dss__Device_GetZoneIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetName"))
		{	*type = SOAP_TYPE_dss__Device_GetName;
			return soap_in_dss__Device_GetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetNameResponse"))
		{	*type = SOAP_TYPE_dss__Device_GetNameResponse;
			return soap_in_dss__Device_GetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-SaveScene"))
		{	*type = SOAP_TYPE_dss__Device_SaveScene;
			return soap_in_dss__Device_SaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-SaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__Device_SaveSceneResponse;
			return soap_in_dss__Device_SaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-CallScene"))
		{	*type = SOAP_TYPE_dss__Device_CallScene;
			return soap_in_dss__Device_CallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-CallSceneResponse"))
		{	*type = SOAP_TYPE_dss__Device_CallSceneResponse;
			return soap_in_dss__Device_CallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetValue"))
		{	*type = SOAP_TYPE_dss__Device_GetValue;
			return soap_in_dss__Device_GetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-GetValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_GetValueResponse;
			return soap_in_dss__Device_GetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-SetValue"))
		{	*type = SOAP_TYPE_dss__Device_SetValue;
			return soap_in_dss__Device_SetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-SetValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_SetValueResponse;
			return soap_in_dss__Device_SetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-EndDim"))
		{	*type = SOAP_TYPE_dss__Device_EndDim;
			return soap_in_dss__Device_EndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-EndDimResponse"))
		{	*type = SOAP_TYPE_dss__Device_EndDimResponse;
			return soap_in_dss__Device_EndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-StartDim"))
		{	*type = SOAP_TYPE_dss__Device_StartDim;
			return soap_in_dss__Device_StartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-StartDimResponse"))
		{	*type = SOAP_TYPE_dss__Device_StartDimResponse;
			return soap_in_dss__Device_StartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-Disable"))
		{	*type = SOAP_TYPE_dss__Device_Disable;
			return soap_in_dss__Device_Disable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-DisableResponse"))
		{	*type = SOAP_TYPE_dss__Device_DisableResponse;
			return soap_in_dss__Device_DisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-Enable"))
		{	*type = SOAP_TYPE_dss__Device_Enable;
			return soap_in_dss__Device_Enable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-EnableResponse"))
		{	*type = SOAP_TYPE_dss__Device_EnableResponse;
			return soap_in_dss__Device_EnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-DecreaseValue"))
		{	*type = SOAP_TYPE_dss__Device_DecreaseValue;
			return soap_in_dss__Device_DecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-DecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_DecreaseValueResponse;
			return soap_in_dss__Device_DecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-IncreaseValue"))
		{	*type = SOAP_TYPE_dss__Device_IncreaseValue;
			return soap_in_dss__Device_IncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-IncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Device_IncreaseValueResponse;
			return soap_in_dss__Device_IncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOff"))
		{	*type = SOAP_TYPE_dss__Device_TurnOff;
			return soap_in_dss__Device_TurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOffResponse"))
		{	*type = SOAP_TYPE_dss__Device_TurnOffResponse;
			return soap_in_dss__Device_TurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOn"))
		{	*type = SOAP_TYPE_dss__Device_TurnOn;
			return soap_in_dss__Device_TurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Device-TurnOnResponse"))
		{	*type = SOAP_TYPE_dss__Device_TurnOnResponse;
			return soap_in_dss__Device_TurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-SaveScene"))
		{	*type = SOAP_TYPE_dss__Group_SaveScene;
			return soap_in_dss__Group_SaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-SaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__Group_SaveSceneResponse;
			return soap_in_dss__Group_SaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-CallScene"))
		{	*type = SOAP_TYPE_dss__Group_CallScene;
			return soap_in_dss__Group_CallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-CallSceneResponse"))
		{	*type = SOAP_TYPE_dss__Group_CallSceneResponse;
			return soap_in_dss__Group_CallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-SetValue"))
		{	*type = SOAP_TYPE_dss__Group_SetValue;
			return soap_in_dss__Group_SetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-SetValueResponse"))
		{	*type = SOAP_TYPE_dss__Group_SetValueResponse;
			return soap_in_dss__Group_SetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-EndDim"))
		{	*type = SOAP_TYPE_dss__Group_EndDim;
			return soap_in_dss__Group_EndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-EndDimResponse"))
		{	*type = SOAP_TYPE_dss__Group_EndDimResponse;
			return soap_in_dss__Group_EndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-StartDim"))
		{	*type = SOAP_TYPE_dss__Group_StartDim;
			return soap_in_dss__Group_StartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-StartDimResponse"))
		{	*type = SOAP_TYPE_dss__Group_StartDimResponse;
			return soap_in_dss__Group_StartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-Disable"))
		{	*type = SOAP_TYPE_dss__Group_Disable;
			return soap_in_dss__Group_Disable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-DisableResponse"))
		{	*type = SOAP_TYPE_dss__Group_DisableResponse;
			return soap_in_dss__Group_DisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-Enable"))
		{	*type = SOAP_TYPE_dss__Group_Enable;
			return soap_in_dss__Group_Enable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-EnableResponse"))
		{	*type = SOAP_TYPE_dss__Group_EnableResponse;
			return soap_in_dss__Group_EnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-DecreaseValue"))
		{	*type = SOAP_TYPE_dss__Group_DecreaseValue;
			return soap_in_dss__Group_DecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-DecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Group_DecreaseValueResponse;
			return soap_in_dss__Group_DecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-IncreaseValue"))
		{	*type = SOAP_TYPE_dss__Group_IncreaseValue;
			return soap_in_dss__Group_IncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-IncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Group_IncreaseValueResponse;
			return soap_in_dss__Group_IncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-TurnOff"))
		{	*type = SOAP_TYPE_dss__Group_TurnOff;
			return soap_in_dss__Group_TurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-TurnOffResponse"))
		{	*type = SOAP_TYPE_dss__Group_TurnOffResponse;
			return soap_in_dss__Group_TurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-TurnOn"))
		{	*type = SOAP_TYPE_dss__Group_TurnOn;
			return soap_in_dss__Group_TurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Group-TurnOnResponse"))
		{	*type = SOAP_TYPE_dss__Group_TurnOnResponse;
			return soap_in_dss__Group_TurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-SaveScene"))
		{	*type = SOAP_TYPE_dss__Set_SaveScene;
			return soap_in_dss__Set_SaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-SaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__Set_SaveSceneResponse;
			return soap_in_dss__Set_SaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-CallScene"))
		{	*type = SOAP_TYPE_dss__Set_CallScene;
			return soap_in_dss__Set_CallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-CallSceneResponse"))
		{	*type = SOAP_TYPE_dss__Set_CallSceneResponse;
			return soap_in_dss__Set_CallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-SetValue"))
		{	*type = SOAP_TYPE_dss__Set_SetValue;
			return soap_in_dss__Set_SetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-SetValueResponse"))
		{	*type = SOAP_TYPE_dss__Set_SetValueResponse;
			return soap_in_dss__Set_SetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-EndDim"))
		{	*type = SOAP_TYPE_dss__Set_EndDim;
			return soap_in_dss__Set_EndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-EndDimResponse"))
		{	*type = SOAP_TYPE_dss__Set_EndDimResponse;
			return soap_in_dss__Set_EndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-StartDim"))
		{	*type = SOAP_TYPE_dss__Set_StartDim;
			return soap_in_dss__Set_StartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-StartDimResponse"))
		{	*type = SOAP_TYPE_dss__Set_StartDimResponse;
			return soap_in_dss__Set_StartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Disable"))
		{	*type = SOAP_TYPE_dss__Set_Disable;
			return soap_in_dss__Set_Disable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-DisableResponse"))
		{	*type = SOAP_TYPE_dss__Set_DisableResponse;
			return soap_in_dss__Set_DisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Enable"))
		{	*type = SOAP_TYPE_dss__Set_Enable;
			return soap_in_dss__Set_Enable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-EnableResponse"))
		{	*type = SOAP_TYPE_dss__Set_EnableResponse;
			return soap_in_dss__Set_EnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-DecreaseValue"))
		{	*type = SOAP_TYPE_dss__Set_DecreaseValue;
			return soap_in_dss__Set_DecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-DecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Set_DecreaseValueResponse;
			return soap_in_dss__Set_DecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-IncreaseValue"))
		{	*type = SOAP_TYPE_dss__Set_IncreaseValue;
			return soap_in_dss__Set_IncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-IncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__Set_IncreaseValueResponse;
			return soap_in_dss__Set_IncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOff"))
		{	*type = SOAP_TYPE_dss__Set_TurnOff;
			return soap_in_dss__Set_TurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOffResponse"))
		{	*type = SOAP_TYPE_dss__Set_TurnOffResponse;
			return soap_in_dss__Set_TurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOn"))
		{	*type = SOAP_TYPE_dss__Set_TurnOn;
			return soap_in_dss__Set_TurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-TurnOnResponse"))
		{	*type = SOAP_TYPE_dss__Set_TurnOnResponse;
			return soap_in_dss__Set_TurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetZoneIDs"))
		{	*type = SOAP_TYPE_dss__Apartment_GetZoneIDs;
			return soap_in_dss__Apartment_GetZoneIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetZoneIDsResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetZoneIDsResponse;
			return soap_in_dss__Apartment_GetZoneIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetZoneByName"))
		{	*type = SOAP_TYPE_dss__Apartment_GetZoneByName;
			return soap_in_dss__Apartment_GetZoneByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetZoneByNameResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetZoneByNameResponse;
			return soap_in_dss__Apartment_GetZoneByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetGroupByName"))
		{	*type = SOAP_TYPE_dss__Apartment_GetGroupByName;
			return soap_in_dss__Apartment_GetGroupByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetGroupByNameResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetGroupByNameResponse;
			return soap_in_dss__Apartment_GetGroupByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-GetContainedDevices"))
		{	*type = SOAP_TYPE_dss__Set_GetContainedDevices;
			return soap_in_dss__Set_GetContainedDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-GetContainedDevicesResponse"))
		{	*type = SOAP_TYPE_dss__Set_GetContainedDevicesResponse;
			return soap_in_dss__Set_GetContainedDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-ByGroup"))
		{	*type = SOAP_TYPE_dss__Set_ByGroup;
			return soap_in_dss__Set_ByGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-ByGroupResponse"))
		{	*type = SOAP_TYPE_dss__Set_ByGroupResponse;
			return soap_in_dss__Set_ByGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Remove"))
		{	*type = SOAP_TYPE_dss__Set_Remove;
			return soap_in_dss__Set_Remove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-RemoveResponse"))
		{	*type = SOAP_TYPE_dss__Set_RemoveResponse;
			return soap_in_dss__Set_RemoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-Combine"))
		{	*type = SOAP_TYPE_dss__Set_Combine;
			return soap_in_dss__Set_Combine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-CombineResponse"))
		{	*type = SOAP_TYPE_dss__Set_CombineResponse;
			return soap_in_dss__Set_CombineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-RemoveDevice"))
		{	*type = SOAP_TYPE_dss__Set_RemoveDevice;
			return soap_in_dss__Set_RemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-RemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Set_RemoveDeviceResponse;
			return soap_in_dss__Set_RemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByID"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByID;
			return soap_in_dss__Set_AddDeviceByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByIDResponse"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByIDResponse;
			return soap_in_dss__Set_AddDeviceByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByName"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByName;
			return soap_in_dss__Set_AddDeviceByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Set-AddDeviceByNameResponse"))
		{	*type = SOAP_TYPE_dss__Set_AddDeviceByNameResponse;
			return soap_in_dss__Set_AddDeviceByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDeviceIDByName"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDeviceIDByName;
			return soap_in_dss__Apartment_GetDeviceIDByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDeviceIDByNameResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse;
			return soap_in_dss__Apartment_GetDeviceIDByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDevices"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDevices;
			return soap_in_dss__Apartment_GetDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-GetDevicesResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_GetDevicesResponse;
			return soap_in_dss__Apartment_GetDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateEmptySet"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateEmptySet;
			return soap_in_dss__Apartment_CreateEmptySet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateEmptySetResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateEmptySetResponse;
			return soap_in_dss__Apartment_CreateEmptySetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceNames"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames;
			return soap_in_dss__Apartment_CreateSetFromDeviceNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceNamesResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse;
			return soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceIDs"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs;
			return soap_in_dss__Apartment_CreateSetFromDeviceIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromDeviceIDsResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse;
			return soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromGroup"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromGroup;
			return soap_in_dss__Apartment_CreateSetFromGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Apartment-CreateSetFromGroupResponse"))
		{	*type = SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse;
			return soap_in_dss__Apartment_CreateSetFromGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:FreeSet"))
		{	*type = SOAP_TYPE_dss__FreeSet;
			return soap_in_dss__FreeSet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:FreeSetResponse"))
		{	*type = SOAP_TYPE_dss__FreeSetResponse;
			return soap_in_dss__FreeSetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOff"))
		{	*type = SOAP_TYPE_dss__SignOff;
			return soap_in_dss__SignOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOffResponse"))
		{	*type = SOAP_TYPE_dss__SignOffResponse;
			return soap_in_dss__SignOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Authenticate"))
		{	*type = SOAP_TYPE_dss__Authenticate;
			return soap_in_dss__Authenticate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:AuthenticateResponse"))
		{	*type = SOAP_TYPE_dss__AuthenticateResponse;
			return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Test"))
		{	*type = SOAP_TYPE_dss__Test;
			return soap_in_dss__Test(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:TestResponse"))
		{	*type = SOAP_TYPE_dss__TestResponse;
			return soap_in_dss__TestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_out_xsd__unsignedInt(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_dss__outParameter:
		return ((dss__outParameter *)ptr)->soap_out(soap, tag, id, "dss:outParameter");
	case SOAP_TYPE_dss__inParameter:
		return ((dss__inParameter *)ptr)->soap_out(soap, tag, id, "dss:inParameter");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		return soap_out_dss__Event_DeleteSchedule(soap, tag, id, (const struct dss__Event_DeleteSchedule *)ptr, "dss:Event-DeleteSchedule");
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		return soap_out_dss__Event_DeleteScheduleResponse(soap, tag, id, (const struct dss__Event_DeleteScheduleResponse *)ptr, "dss:Event-DeleteScheduleResponse");
	case SOAP_TYPE_dss__Event_Schedule:
		return soap_out_dss__Event_Schedule(soap, tag, id, (const struct dss__Event_Schedule *)ptr, "dss:Event-Schedule");
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		return soap_out_dss__Event_ScheduleResponse(soap, tag, id, (const struct dss__Event_ScheduleResponse *)ptr, "dss:Event-ScheduleResponse");
	case SOAP_TYPE_dss__Event_Unsubscribe:
		return soap_out_dss__Event_Unsubscribe(soap, tag, id, (const struct dss__Event_Unsubscribe *)ptr, "dss:Event-Unsubscribe");
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		return soap_out_dss__Event_UnsubscribeResponse(soap, tag, id, (const struct dss__Event_UnsubscribeResponse *)ptr, "dss:Event-UnsubscribeResponse");
	case SOAP_TYPE_dss__Event_Subscribe:
		return soap_out_dss__Event_Subscribe(soap, tag, id, (const struct dss__Event_Subscribe *)ptr, "dss:Event-Subscribe");
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		return soap_out_dss__Event_SubscribeResponse(soap, tag, id, (const struct dss__Event_SubscribeResponse *)ptr, "dss:Event-SubscribeResponse");
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		return soap_out_dss__Event_GetActionParamsTemplate(soap, tag, id, (const struct dss__Event_GetActionParamsTemplate *)ptr, "dss:Event-GetActionParamsTemplate");
	case SOAP_TYPE_dss__Event_GetActionNames:
		return soap_out_dss__Event_GetActionNames(soap, tag, id, (const struct dss__Event_GetActionNames *)ptr, "dss:Event-GetActionNames");
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		return soap_out_dss__Event_GetActionNamesResponse(soap, tag, id, (const struct dss__Event_GetActionNamesResponse *)ptr, "dss:Event-GetActionNamesResponse");
	case SOAP_TYPE_dss__Event_Raise:
		return soap_out_dss__Event_Raise(soap, tag, id, (const struct dss__Event_Raise *)ptr, "dss:Event-Raise");
	case SOAP_TYPE_dss__Event_RaiseResponse:
		return soap_out_dss__Event_RaiseResponse(soap, tag, id, (const struct dss__Event_RaiseResponse *)ptr, "dss:Event-RaiseResponse");
	case SOAP_TYPE_dss__Switch_SimulateKeypress:
		return soap_out_dss__Switch_SimulateKeypress(soap, tag, id, (const struct dss__Switch_SimulateKeypress *)ptr, "dss:Switch-SimulateKeypress");
	case SOAP_TYPE_dss__Switch_SimulateKeypressResponse:
		return soap_out_dss__Switch_SimulateKeypressResponse(soap, tag, id, (const struct dss__Switch_SimulateKeypressResponse *)ptr, "dss:Switch-SimulateKeypressResponse");
	case SOAP_TYPE_dss__Switch_GetGroupID:
		return soap_out_dss__Switch_GetGroupID(soap, tag, id, (const struct dss__Switch_GetGroupID *)ptr, "dss:Switch-GetGroupID");
	case SOAP_TYPE_dss__Switch_GetGroupIDResponse:
		return soap_out_dss__Switch_GetGroupIDResponse(soap, tag, id, (const struct dss__Switch_GetGroupIDResponse *)ptr, "dss:Switch-GetGroupIDResponse");
	case SOAP_TYPE_dss__Device_GetFunctionID:
		return soap_out_dss__Device_GetFunctionID(soap, tag, id, (const struct dss__Device_GetFunctionID *)ptr, "dss:Device-GetFunctionID");
	case SOAP_TYPE_dss__Device_GetFunctionIDResponse:
		return soap_out_dss__Device_GetFunctionIDResponse(soap, tag, id, (const struct dss__Device_GetFunctionIDResponse *)ptr, "dss:Device-GetFunctionIDResponse");
	case SOAP_TYPE_dss__Group_RemoveDevice:
		return soap_out_dss__Group_RemoveDevice(soap, tag, id, (const struct dss__Group_RemoveDevice *)ptr, "dss:Group-RemoveDevice");
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		return soap_out_dss__Group_RemoveDeviceResponse(soap, tag, id, (const struct dss__Group_RemoveDeviceResponse *)ptr, "dss:Group-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Group_AddDevice:
		return soap_out_dss__Group_AddDevice(soap, tag, id, (const struct dss__Group_AddDevice *)ptr, "dss:Group-AddDevice");
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		return soap_out_dss__Group_AddDeviceResponse(soap, tag, id, (const struct dss__Group_AddDeviceResponse *)ptr, "dss:Group-AddDeviceResponse");
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		return soap_out_dss__Group_RemoveUserGroup(soap, tag, id, (const struct dss__Group_RemoveUserGroup *)ptr, "dss:Group-RemoveUserGroup");
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		return soap_out_dss__Group_RemoveUserGroupResponse(soap, tag, id, (const struct dss__Group_RemoveUserGroupResponse *)ptr, "dss:Group-RemoveUserGroupResponse");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		return soap_out_dss__Apartment_AllocateUserGroup(soap, tag, id, (const struct dss__Apartment_AllocateUserGroup *)ptr, "dss:Apartment-AllocateUserGroup");
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		return soap_out_dss__Apartment_AllocateUserGroupResponse(soap, tag, id, (const struct dss__Apartment_AllocateUserGroupResponse *)ptr, "dss:Apartment-AllocateUserGroupResponse");
	case SOAP_TYPE_dss__Zone_SetName:
		return soap_out_dss__Zone_SetName(soap, tag, id, (const struct dss__Zone_SetName *)ptr, "dss:Zone-SetName");
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		return soap_out_dss__Zone_SetNameResponse(soap, tag, id, (const struct dss__Zone_SetNameResponse *)ptr, "dss:Zone-SetNameResponse");
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		return soap_out_dss__Zone_RemoveDevice(soap, tag, id, (const struct dss__Zone_RemoveDevice *)ptr, "dss:Zone-RemoveDevice");
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		return soap_out_dss__Zone_RemoveDeviceResponse(soap, tag, id, (const struct dss__Zone_RemoveDeviceResponse *)ptr, "dss:Zone-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Zone_AddDevice:
		return soap_out_dss__Zone_AddDevice(soap, tag, id, (const struct dss__Zone_AddDevice *)ptr, "dss:Zone-AddDevice");
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		return soap_out_dss__Zone_AddDeviceResponse(soap, tag, id, (const struct dss__Zone_AddDeviceResponse *)ptr, "dss:Zone-AddDeviceResponse");
	case SOAP_TYPE_dss__Apartment_DeleteZone:
		return soap_out_dss__Apartment_DeleteZone(soap, tag, id, (const struct dss__Apartment_DeleteZone *)ptr, "dss:Apartment-DeleteZone");
	case SOAP_TYPE_dss__Apartment_DeleteZoneResponse:
		return soap_out_dss__Apartment_DeleteZoneResponse(soap, tag, id, (const struct dss__Apartment_DeleteZoneResponse *)ptr, "dss:Apartment-DeleteZoneResponse");
	case SOAP_TYPE_dss__Apartment_AllocateZone:
		return soap_out_dss__Apartment_AllocateZone(soap, tag, id, (const struct dss__Apartment_AllocateZone *)ptr, "dss:Apartment-AllocateZone");
	case SOAP_TYPE_dss__Apartment_AllocateZoneResponse:
		return soap_out_dss__Apartment_AllocateZoneResponse(soap, tag, id, (const struct dss__Apartment_AllocateZoneResponse *)ptr, "dss:Apartment-AllocateZoneResponse");
	case SOAP_TYPE_dss__Modulator_GetName:
		return soap_out_dss__Modulator_GetName(soap, tag, id, (const struct dss__Modulator_GetName *)ptr, "dss:Modulator-GetName");
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		return soap_out_dss__Modulator_GetNameResponse(soap, tag, id, (const struct dss__Modulator_GetNameResponse *)ptr, "dss:Modulator-GetNameResponse");
	case SOAP_TYPE_dss__Modulator_GetDSID:
		return soap_out_dss__Modulator_GetDSID(soap, tag, id, (const struct dss__Modulator_GetDSID *)ptr, "dss:Modulator-GetDSID");
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		return soap_out_dss__Modulator_GetDSIDResponse(soap, tag, id, (const struct dss__Modulator_GetDSIDResponse *)ptr, "dss:Modulator-GetDSIDResponse");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		return soap_out_dss__Apartment_GetModulatorIDs(soap, tag, id, (const struct dss__Apartment_GetModulatorIDs *)ptr, "dss:Apartment-GetModulatorIDs");
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		return soap_out_dss__Apartment_GetModulatorIDsResponse(soap, tag, id, (const struct dss__Apartment_GetModulatorIDsResponse *)ptr, "dss:Apartment-GetModulatorIDsResponse");
	case SOAP_TYPE_dss__Modulator_GetPowerConsumption:
		return soap_out_dss__Modulator_GetPowerConsumption(soap, tag, id, (const struct dss__Modulator_GetPowerConsumption *)ptr, "dss:Modulator-GetPowerConsumption");
	case SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse:
		return soap_out_dss__Modulator_GetPowerConsumptionResponse(soap, tag, id, (const struct dss__Modulator_GetPowerConsumptionResponse *)ptr, "dss:Modulator-GetPowerConsumptionResponse");
	case SOAP_TYPE_dss__Device_GetDSID:
		return soap_out_dss__Device_GetDSID(soap, tag, id, (const struct dss__Device_GetDSID *)ptr, "dss:Device-GetDSID");
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		return soap_out_dss__Device_GetDSIDResponse(soap, tag, id, (const struct dss__Device_GetDSIDResponse *)ptr, "dss:Device-GetDSIDResponse");
	case SOAP_TYPE_dss__Device_GetZoneID:
		return soap_out_dss__Device_GetZoneID(soap, tag, id, (const struct dss__Device_GetZoneID *)ptr, "dss:Device-GetZoneID");
	case SOAP_TYPE_dss__Device_GetZoneIDResponse:
		return soap_out_dss__Device_GetZoneIDResponse(soap, tag, id, (const struct dss__Device_GetZoneIDResponse *)ptr, "dss:Device-GetZoneIDResponse");
	case SOAP_TYPE_dss__Device_GetName:
		return soap_out_dss__Device_GetName(soap, tag, id, (const struct dss__Device_GetName *)ptr, "dss:Device-GetName");
	case SOAP_TYPE_dss__Device_GetNameResponse:
		return soap_out_dss__Device_GetNameResponse(soap, tag, id, (const struct dss__Device_GetNameResponse *)ptr, "dss:Device-GetNameResponse");
	case SOAP_TYPE_dss__Device_SaveScene:
		return soap_out_dss__Device_SaveScene(soap, tag, id, (const struct dss__Device_SaveScene *)ptr, "dss:Device-SaveScene");
	case SOAP_TYPE_dss__Device_SaveSceneResponse:
		return soap_out_dss__Device_SaveSceneResponse(soap, tag, id, (const struct dss__Device_SaveSceneResponse *)ptr, "dss:Device-SaveSceneResponse");
	case SOAP_TYPE_dss__Device_CallScene:
		return soap_out_dss__Device_CallScene(soap, tag, id, (const struct dss__Device_CallScene *)ptr, "dss:Device-CallScene");
	case SOAP_TYPE_dss__Device_CallSceneResponse:
		return soap_out_dss__Device_CallSceneResponse(soap, tag, id, (const struct dss__Device_CallSceneResponse *)ptr, "dss:Device-CallSceneResponse");
	case SOAP_TYPE_dss__Device_GetValue:
		return soap_out_dss__Device_GetValue(soap, tag, id, (const struct dss__Device_GetValue *)ptr, "dss:Device-GetValue");
	case SOAP_TYPE_dss__Device_GetValueResponse:
		return soap_out_dss__Device_GetValueResponse(soap, tag, id, (const struct dss__Device_GetValueResponse *)ptr, "dss:Device-GetValueResponse");
	case SOAP_TYPE_dss__Device_SetValue:
		return soap_out_dss__Device_SetValue(soap, tag, id, (const struct dss__Device_SetValue *)ptr, "dss:Device-SetValue");
	case SOAP_TYPE_dss__Device_SetValueResponse:
		return soap_out_dss__Device_SetValueResponse(soap, tag, id, (const struct dss__Device_SetValueResponse *)ptr, "dss:Device-SetValueResponse");
	case SOAP_TYPE_dss__Device_EndDim:
		return soap_out_dss__Device_EndDim(soap, tag, id, (const struct dss__Device_EndDim *)ptr, "dss:Device-EndDim");
	case SOAP_TYPE_dss__Device_EndDimResponse:
		return soap_out_dss__Device_EndDimResponse(soap, tag, id, (const struct dss__Device_EndDimResponse *)ptr, "dss:Device-EndDimResponse");
	case SOAP_TYPE_dss__Device_StartDim:
		return soap_out_dss__Device_StartDim(soap, tag, id, (const struct dss__Device_StartDim *)ptr, "dss:Device-StartDim");
	case SOAP_TYPE_dss__Device_StartDimResponse:
		return soap_out_dss__Device_StartDimResponse(soap, tag, id, (const struct dss__Device_StartDimResponse *)ptr, "dss:Device-StartDimResponse");
	case SOAP_TYPE_dss__Device_Disable:
		return soap_out_dss__Device_Disable(soap, tag, id, (const struct dss__Device_Disable *)ptr, "dss:Device-Disable");
	case SOAP_TYPE_dss__Device_DisableResponse:
		return soap_out_dss__Device_DisableResponse(soap, tag, id, (const struct dss__Device_DisableResponse *)ptr, "dss:Device-DisableResponse");
	case SOAP_TYPE_dss__Device_Enable:
		return soap_out_dss__Device_Enable(soap, tag, id, (const struct dss__Device_Enable *)ptr, "dss:Device-Enable");
	case SOAP_TYPE_dss__Device_EnableResponse:
		return soap_out_dss__Device_EnableResponse(soap, tag, id, (const struct dss__Device_EnableResponse *)ptr, "dss:Device-EnableResponse");
	case SOAP_TYPE_dss__Device_DecreaseValue:
		return soap_out_dss__Device_DecreaseValue(soap, tag, id, (const struct dss__Device_DecreaseValue *)ptr, "dss:Device-DecreaseValue");
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		return soap_out_dss__Device_DecreaseValueResponse(soap, tag, id, (const struct dss__Device_DecreaseValueResponse *)ptr, "dss:Device-DecreaseValueResponse");
	case SOAP_TYPE_dss__Device_IncreaseValue:
		return soap_out_dss__Device_IncreaseValue(soap, tag, id, (const struct dss__Device_IncreaseValue *)ptr, "dss:Device-IncreaseValue");
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		return soap_out_dss__Device_IncreaseValueResponse(soap, tag, id, (const struct dss__Device_IncreaseValueResponse *)ptr, "dss:Device-IncreaseValueResponse");
	case SOAP_TYPE_dss__Device_TurnOff:
		return soap_out_dss__Device_TurnOff(soap, tag, id, (const struct dss__Device_TurnOff *)ptr, "dss:Device-TurnOff");
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		return soap_out_dss__Device_TurnOffResponse(soap, tag, id, (const struct dss__Device_TurnOffResponse *)ptr, "dss:Device-TurnOffResponse");
	case SOAP_TYPE_dss__Device_TurnOn:
		return soap_out_dss__Device_TurnOn(soap, tag, id, (const struct dss__Device_TurnOn *)ptr, "dss:Device-TurnOn");
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		return soap_out_dss__Device_TurnOnResponse(soap, tag, id, (const struct dss__Device_TurnOnResponse *)ptr, "dss:Device-TurnOnResponse");
	case SOAP_TYPE_dss__Group_SaveScene:
		return soap_out_dss__Group_SaveScene(soap, tag, id, (const struct dss__Group_SaveScene *)ptr, "dss:Group-SaveScene");
	case SOAP_TYPE_dss__Group_SaveSceneResponse:
		return soap_out_dss__Group_SaveSceneResponse(soap, tag, id, (const struct dss__Group_SaveSceneResponse *)ptr, "dss:Group-SaveSceneResponse");
	case SOAP_TYPE_dss__Group_CallScene:
		return soap_out_dss__Group_CallScene(soap, tag, id, (const struct dss__Group_CallScene *)ptr, "dss:Group-CallScene");
	case SOAP_TYPE_dss__Group_CallSceneResponse:
		return soap_out_dss__Group_CallSceneResponse(soap, tag, id, (const struct dss__Group_CallSceneResponse *)ptr, "dss:Group-CallSceneResponse");
	case SOAP_TYPE_dss__Group_SetValue:
		return soap_out_dss__Group_SetValue(soap, tag, id, (const struct dss__Group_SetValue *)ptr, "dss:Group-SetValue");
	case SOAP_TYPE_dss__Group_SetValueResponse:
		return soap_out_dss__Group_SetValueResponse(soap, tag, id, (const struct dss__Group_SetValueResponse *)ptr, "dss:Group-SetValueResponse");
	case SOAP_TYPE_dss__Group_EndDim:
		return soap_out_dss__Group_EndDim(soap, tag, id, (const struct dss__Group_EndDim *)ptr, "dss:Group-EndDim");
	case SOAP_TYPE_dss__Group_EndDimResponse:
		return soap_out_dss__Group_EndDimResponse(soap, tag, id, (const struct dss__Group_EndDimResponse *)ptr, "dss:Group-EndDimResponse");
	case SOAP_TYPE_dss__Group_StartDim:
		return soap_out_dss__Group_StartDim(soap, tag, id, (const struct dss__Group_StartDim *)ptr, "dss:Group-StartDim");
	case SOAP_TYPE_dss__Group_StartDimResponse:
		return soap_out_dss__Group_StartDimResponse(soap, tag, id, (const struct dss__Group_StartDimResponse *)ptr, "dss:Group-StartDimResponse");
	case SOAP_TYPE_dss__Group_Disable:
		return soap_out_dss__Group_Disable(soap, tag, id, (const struct dss__Group_Disable *)ptr, "dss:Group-Disable");
	case SOAP_TYPE_dss__Group_DisableResponse:
		return soap_out_dss__Group_DisableResponse(soap, tag, id, (const struct dss__Group_DisableResponse *)ptr, "dss:Group-DisableResponse");
	case SOAP_TYPE_dss__Group_Enable:
		return soap_out_dss__Group_Enable(soap, tag, id, (const struct dss__Group_Enable *)ptr, "dss:Group-Enable");
	case SOAP_TYPE_dss__Group_EnableResponse:
		return soap_out_dss__Group_EnableResponse(soap, tag, id, (const struct dss__Group_EnableResponse *)ptr, "dss:Group-EnableResponse");
	case SOAP_TYPE_dss__Group_DecreaseValue:
		return soap_out_dss__Group_DecreaseValue(soap, tag, id, (const struct dss__Group_DecreaseValue *)ptr, "dss:Group-DecreaseValue");
	case SOAP_TYPE_dss__Group_DecreaseValueResponse:
		return soap_out_dss__Group_DecreaseValueResponse(soap, tag, id, (const struct dss__Group_DecreaseValueResponse *)ptr, "dss:Group-DecreaseValueResponse");
	case SOAP_TYPE_dss__Group_IncreaseValue:
		return soap_out_dss__Group_IncreaseValue(soap, tag, id, (const struct dss__Group_IncreaseValue *)ptr, "dss:Group-IncreaseValue");
	case SOAP_TYPE_dss__Group_IncreaseValueResponse:
		return soap_out_dss__Group_IncreaseValueResponse(soap, tag, id, (const struct dss__Group_IncreaseValueResponse *)ptr, "dss:Group-IncreaseValueResponse");
	case SOAP_TYPE_dss__Group_TurnOff:
		return soap_out_dss__Group_TurnOff(soap, tag, id, (const struct dss__Group_TurnOff *)ptr, "dss:Group-TurnOff");
	case SOAP_TYPE_dss__Group_TurnOffResponse:
		return soap_out_dss__Group_TurnOffResponse(soap, tag, id, (const struct dss__Group_TurnOffResponse *)ptr, "dss:Group-TurnOffResponse");
	case SOAP_TYPE_dss__Group_TurnOn:
		return soap_out_dss__Group_TurnOn(soap, tag, id, (const struct dss__Group_TurnOn *)ptr, "dss:Group-TurnOn");
	case SOAP_TYPE_dss__Group_TurnOnResponse:
		return soap_out_dss__Group_TurnOnResponse(soap, tag, id, (const struct dss__Group_TurnOnResponse *)ptr, "dss:Group-TurnOnResponse");
	case SOAP_TYPE_dss__Set_SaveScene:
		return soap_out_dss__Set_SaveScene(soap, tag, id, (const struct dss__Set_SaveScene *)ptr, "dss:Set-SaveScene");
	case SOAP_TYPE_dss__Set_SaveSceneResponse:
		return soap_out_dss__Set_SaveSceneResponse(soap, tag, id, (const struct dss__Set_SaveSceneResponse *)ptr, "dss:Set-SaveSceneResponse");
	case SOAP_TYPE_dss__Set_CallScene:
		return soap_out_dss__Set_CallScene(soap, tag, id, (const struct dss__Set_CallScene *)ptr, "dss:Set-CallScene");
	case SOAP_TYPE_dss__Set_CallSceneResponse:
		return soap_out_dss__Set_CallSceneResponse(soap, tag, id, (const struct dss__Set_CallSceneResponse *)ptr, "dss:Set-CallSceneResponse");
	case SOAP_TYPE_dss__Set_SetValue:
		return soap_out_dss__Set_SetValue(soap, tag, id, (const struct dss__Set_SetValue *)ptr, "dss:Set-SetValue");
	case SOAP_TYPE_dss__Set_SetValueResponse:
		return soap_out_dss__Set_SetValueResponse(soap, tag, id, (const struct dss__Set_SetValueResponse *)ptr, "dss:Set-SetValueResponse");
	case SOAP_TYPE_dss__Set_EndDim:
		return soap_out_dss__Set_EndDim(soap, tag, id, (const struct dss__Set_EndDim *)ptr, "dss:Set-EndDim");
	case SOAP_TYPE_dss__Set_EndDimResponse:
		return soap_out_dss__Set_EndDimResponse(soap, tag, id, (const struct dss__Set_EndDimResponse *)ptr, "dss:Set-EndDimResponse");
	case SOAP_TYPE_dss__Set_StartDim:
		return soap_out_dss__Set_StartDim(soap, tag, id, (const struct dss__Set_StartDim *)ptr, "dss:Set-StartDim");
	case SOAP_TYPE_dss__Set_StartDimResponse:
		return soap_out_dss__Set_StartDimResponse(soap, tag, id, (const struct dss__Set_StartDimResponse *)ptr, "dss:Set-StartDimResponse");
	case SOAP_TYPE_dss__Set_Disable:
		return soap_out_dss__Set_Disable(soap, tag, id, (const struct dss__Set_Disable *)ptr, "dss:Set-Disable");
	case SOAP_TYPE_dss__Set_DisableResponse:
		return soap_out_dss__Set_DisableResponse(soap, tag, id, (const struct dss__Set_DisableResponse *)ptr, "dss:Set-DisableResponse");
	case SOAP_TYPE_dss__Set_Enable:
		return soap_out_dss__Set_Enable(soap, tag, id, (const struct dss__Set_Enable *)ptr, "dss:Set-Enable");
	case SOAP_TYPE_dss__Set_EnableResponse:
		return soap_out_dss__Set_EnableResponse(soap, tag, id, (const struct dss__Set_EnableResponse *)ptr, "dss:Set-EnableResponse");
	case SOAP_TYPE_dss__Set_DecreaseValue:
		return soap_out_dss__Set_DecreaseValue(soap, tag, id, (const struct dss__Set_DecreaseValue *)ptr, "dss:Set-DecreaseValue");
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		return soap_out_dss__Set_DecreaseValueResponse(soap, tag, id, (const struct dss__Set_DecreaseValueResponse *)ptr, "dss:Set-DecreaseValueResponse");
	case SOAP_TYPE_dss__Set_IncreaseValue:
		return soap_out_dss__Set_IncreaseValue(soap, tag, id, (const struct dss__Set_IncreaseValue *)ptr, "dss:Set-IncreaseValue");
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		return soap_out_dss__Set_IncreaseValueResponse(soap, tag, id, (const struct dss__Set_IncreaseValueResponse *)ptr, "dss:Set-IncreaseValueResponse");
	case SOAP_TYPE_dss__Set_TurnOff:
		return soap_out_dss__Set_TurnOff(soap, tag, id, (const struct dss__Set_TurnOff *)ptr, "dss:Set-TurnOff");
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		return soap_out_dss__Set_TurnOffResponse(soap, tag, id, (const struct dss__Set_TurnOffResponse *)ptr, "dss:Set-TurnOffResponse");
	case SOAP_TYPE_dss__Set_TurnOn:
		return soap_out_dss__Set_TurnOn(soap, tag, id, (const struct dss__Set_TurnOn *)ptr, "dss:Set-TurnOn");
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		return soap_out_dss__Set_TurnOnResponse(soap, tag, id, (const struct dss__Set_TurnOnResponse *)ptr, "dss:Set-TurnOnResponse");
	case SOAP_TYPE_dss__Apartment_GetZoneIDs:
		return soap_out_dss__Apartment_GetZoneIDs(soap, tag, id, (const struct dss__Apartment_GetZoneIDs *)ptr, "dss:Apartment-GetZoneIDs");
	case SOAP_TYPE_dss__Apartment_GetZoneIDsResponse:
		return soap_out_dss__Apartment_GetZoneIDsResponse(soap, tag, id, (const struct dss__Apartment_GetZoneIDsResponse *)ptr, "dss:Apartment-GetZoneIDsResponse");
	case SOAP_TYPE_dss__Apartment_GetZoneByName:
		return soap_out_dss__Apartment_GetZoneByName(soap, tag, id, (const struct dss__Apartment_GetZoneByName *)ptr, "dss:Apartment-GetZoneByName");
	case SOAP_TYPE_dss__Apartment_GetZoneByNameResponse:
		return soap_out_dss__Apartment_GetZoneByNameResponse(soap, tag, id, (const struct dss__Apartment_GetZoneByNameResponse *)ptr, "dss:Apartment-GetZoneByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		return soap_out_dss__Apartment_GetGroupByName(soap, tag, id, (const struct dss__Apartment_GetGroupByName *)ptr, "dss:Apartment-GetGroupByName");
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		return soap_out_dss__Apartment_GetGroupByNameResponse(soap, tag, id, (const struct dss__Apartment_GetGroupByNameResponse *)ptr, "dss:Apartment-GetGroupByNameResponse");
	case SOAP_TYPE_dss__Set_GetContainedDevices:
		return soap_out_dss__Set_GetContainedDevices(soap, tag, id, (const struct dss__Set_GetContainedDevices *)ptr, "dss:Set-GetContainedDevices");
	case SOAP_TYPE_dss__Set_GetContainedDevicesResponse:
		return soap_out_dss__Set_GetContainedDevicesResponse(soap, tag, id, (const struct dss__Set_GetContainedDevicesResponse *)ptr, "dss:Set-GetContainedDevicesResponse");
	case SOAP_TYPE_dss__Set_ByGroup:
		return soap_out_dss__Set_ByGroup(soap, tag, id, (const struct dss__Set_ByGroup *)ptr, "dss:Set-ByGroup");
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		return soap_out_dss__Set_ByGroupResponse(soap, tag, id, (const struct dss__Set_ByGroupResponse *)ptr, "dss:Set-ByGroupResponse");
	case SOAP_TYPE_dss__Set_Remove:
		return soap_out_dss__Set_Remove(soap, tag, id, (const struct dss__Set_Remove *)ptr, "dss:Set-Remove");
	case SOAP_TYPE_dss__Set_RemoveResponse:
		return soap_out_dss__Set_RemoveResponse(soap, tag, id, (const struct dss__Set_RemoveResponse *)ptr, "dss:Set-RemoveResponse");
	case SOAP_TYPE_dss__Set_Combine:
		return soap_out_dss__Set_Combine(soap, tag, id, (const struct dss__Set_Combine *)ptr, "dss:Set-Combine");
	case SOAP_TYPE_dss__Set_CombineResponse:
		return soap_out_dss__Set_CombineResponse(soap, tag, id, (const struct dss__Set_CombineResponse *)ptr, "dss:Set-CombineResponse");
	case SOAP_TYPE_dss__Set_RemoveDevice:
		return soap_out_dss__Set_RemoveDevice(soap, tag, id, (const struct dss__Set_RemoveDevice *)ptr, "dss:Set-RemoveDevice");
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		return soap_out_dss__Set_RemoveDeviceResponse(soap, tag, id, (const struct dss__Set_RemoveDeviceResponse *)ptr, "dss:Set-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		return soap_out_dss__Set_AddDeviceByID(soap, tag, id, (const struct dss__Set_AddDeviceByID *)ptr, "dss:Set-AddDeviceByID");
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		return soap_out_dss__Set_AddDeviceByIDResponse(soap, tag, id, (const struct dss__Set_AddDeviceByIDResponse *)ptr, "dss:Set-AddDeviceByIDResponse");
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		return soap_out_dss__Set_AddDeviceByName(soap, tag, id, (const struct dss__Set_AddDeviceByName *)ptr, "dss:Set-AddDeviceByName");
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		return soap_out_dss__Set_AddDeviceByNameResponse(soap, tag, id, (const struct dss__Set_AddDeviceByNameResponse *)ptr, "dss:Set-AddDeviceByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		return soap_out_dss__Apartment_GetDeviceIDByName(soap, tag, id, (const struct dss__Apartment_GetDeviceIDByName *)ptr, "dss:Apartment-GetDeviceIDByName");
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		return soap_out_dss__Apartment_GetDeviceIDByNameResponse(soap, tag, id, (const struct dss__Apartment_GetDeviceIDByNameResponse *)ptr, "dss:Apartment-GetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__Apartment_GetDevices:
		return soap_out_dss__Apartment_GetDevices(soap, tag, id, (const struct dss__Apartment_GetDevices *)ptr, "dss:Apartment-GetDevices");
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		return soap_out_dss__Apartment_GetDevicesResponse(soap, tag, id, (const struct dss__Apartment_GetDevicesResponse *)ptr, "dss:Apartment-GetDevicesResponse");
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		return soap_out_dss__Apartment_CreateEmptySet(soap, tag, id, (const struct dss__Apartment_CreateEmptySet *)ptr, "dss:Apartment-CreateEmptySet");
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		return soap_out_dss__Apartment_CreateEmptySetResponse(soap, tag, id, (const struct dss__Apartment_CreateEmptySetResponse *)ptr, "dss:Apartment-CreateEmptySetResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		return soap_out_dss__Apartment_CreateSetFromDeviceNames(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceNames *)ptr, "dss:Apartment-CreateSetFromDeviceNames");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		return soap_out_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceNamesResponse *)ptr, "dss:Apartment-CreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		return soap_out_dss__Apartment_CreateSetFromDeviceIDs(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceIDs *)ptr, "dss:Apartment-CreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		return soap_out_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, tag, id, (const struct dss__Apartment_CreateSetFromDeviceIDsResponse *)ptr, "dss:Apartment-CreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		return soap_out_dss__Apartment_CreateSetFromGroup(soap, tag, id, (const struct dss__Apartment_CreateSetFromGroup *)ptr, "dss:Apartment-CreateSetFromGroup");
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		return soap_out_dss__Apartment_CreateSetFromGroupResponse(soap, tag, id, (const struct dss__Apartment_CreateSetFromGroupResponse *)ptr, "dss:Apartment-CreateSetFromGroupResponse");
	case SOAP_TYPE_dss__FreeSet:
		return soap_out_dss__FreeSet(soap, tag, id, (const struct dss__FreeSet *)ptr, "dss:FreeSet");
	case SOAP_TYPE_dss__FreeSetResponse:
		return soap_out_dss__FreeSetResponse(soap, tag, id, (const struct dss__FreeSetResponse *)ptr, "dss:FreeSetResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_out_dss__SignOff(soap, tag, id, (const struct dss__SignOff *)ptr, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_out_dss__SignOffResponse(soap, tag, id, (const struct dss__SignOffResponse *)ptr, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_out_dss__Authenticate(soap, tag, id, (const struct dss__Authenticate *)ptr, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_out_dss__AuthenticateResponse(soap, tag, id, (const struct dss__AuthenticateResponse *)ptr, "dss:AuthenticateResponse");
	case SOAP_TYPE_dss__Test:
		return soap_out_dss__Test(soap, tag, id, (const struct dss__Test *)ptr, "dss:Test");
	case SOAP_TYPE_dss__TestResponse:
		return soap_out_dss__TestResponse(soap, tag, id, (const struct dss__TestResponse *)ptr, "dss:TestResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_dss__outParameter:
		((dss__outParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_dss__inParameter:
		((dss__inParameter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		soap_serialize_dss__Event_DeleteSchedule(soap, (const struct dss__Event_DeleteSchedule *)ptr);
		break;
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		soap_serialize_dss__Event_DeleteScheduleResponse(soap, (const struct dss__Event_DeleteScheduleResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Schedule:
		soap_serialize_dss__Event_Schedule(soap, (const struct dss__Event_Schedule *)ptr);
		break;
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		soap_serialize_dss__Event_ScheduleResponse(soap, (const struct dss__Event_ScheduleResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Unsubscribe:
		soap_serialize_dss__Event_Unsubscribe(soap, (const struct dss__Event_Unsubscribe *)ptr);
		break;
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		soap_serialize_dss__Event_UnsubscribeResponse(soap, (const struct dss__Event_UnsubscribeResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Subscribe:
		soap_serialize_dss__Event_Subscribe(soap, (const struct dss__Event_Subscribe *)ptr);
		break;
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		soap_serialize_dss__Event_SubscribeResponse(soap, (const struct dss__Event_SubscribeResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		soap_serialize_dss__Event_GetActionParamsTemplate(soap, (const struct dss__Event_GetActionParamsTemplate *)ptr);
		break;
	case SOAP_TYPE_dss__Event_GetActionNames:
		soap_serialize_dss__Event_GetActionNames(soap, (const struct dss__Event_GetActionNames *)ptr);
		break;
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		soap_serialize_dss__Event_GetActionNamesResponse(soap, (const struct dss__Event_GetActionNamesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Event_Raise:
		soap_serialize_dss__Event_Raise(soap, (const struct dss__Event_Raise *)ptr);
		break;
	case SOAP_TYPE_dss__Event_RaiseResponse:
		soap_serialize_dss__Event_RaiseResponse(soap, (const struct dss__Event_RaiseResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Switch_SimulateKeypress:
		soap_serialize_dss__Switch_SimulateKeypress(soap, (const struct dss__Switch_SimulateKeypress *)ptr);
		break;
	case SOAP_TYPE_dss__Switch_SimulateKeypressResponse:
		soap_serialize_dss__Switch_SimulateKeypressResponse(soap, (const struct dss__Switch_SimulateKeypressResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Switch_GetGroupID:
		soap_serialize_dss__Switch_GetGroupID(soap, (const struct dss__Switch_GetGroupID *)ptr);
		break;
	case SOAP_TYPE_dss__Switch_GetGroupIDResponse:
		soap_serialize_dss__Switch_GetGroupIDResponse(soap, (const struct dss__Switch_GetGroupIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetFunctionID:
		soap_serialize_dss__Device_GetFunctionID(soap, (const struct dss__Device_GetFunctionID *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetFunctionIDResponse:
		soap_serialize_dss__Device_GetFunctionIDResponse(soap, (const struct dss__Device_GetFunctionIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveDevice:
		soap_serialize_dss__Group_RemoveDevice(soap, (const struct dss__Group_RemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		soap_serialize_dss__Group_RemoveDeviceResponse(soap, (const struct dss__Group_RemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_AddDevice:
		soap_serialize_dss__Group_AddDevice(soap, (const struct dss__Group_AddDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		soap_serialize_dss__Group_AddDeviceResponse(soap, (const struct dss__Group_AddDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		soap_serialize_dss__Group_RemoveUserGroup(soap, (const struct dss__Group_RemoveUserGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		soap_serialize_dss__Group_RemoveUserGroupResponse(soap, (const struct dss__Group_RemoveUserGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		soap_serialize_dss__Apartment_AllocateUserGroup(soap, (const struct dss__Apartment_AllocateUserGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		soap_serialize_dss__Apartment_AllocateUserGroupResponse(soap, (const struct dss__Apartment_AllocateUserGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_SetName:
		soap_serialize_dss__Zone_SetName(soap, (const struct dss__Zone_SetName *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		soap_serialize_dss__Zone_SetNameResponse(soap, (const struct dss__Zone_SetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		soap_serialize_dss__Zone_RemoveDevice(soap, (const struct dss__Zone_RemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		soap_serialize_dss__Zone_RemoveDeviceResponse(soap, (const struct dss__Zone_RemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_AddDevice:
		soap_serialize_dss__Zone_AddDevice(soap, (const struct dss__Zone_AddDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		soap_serialize_dss__Zone_AddDeviceResponse(soap, (const struct dss__Zone_AddDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_DeleteZone:
		soap_serialize_dss__Apartment_DeleteZone(soap, (const struct dss__Apartment_DeleteZone *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_DeleteZoneResponse:
		soap_serialize_dss__Apartment_DeleteZoneResponse(soap, (const struct dss__Apartment_DeleteZoneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateZone:
		soap_serialize_dss__Apartment_AllocateZone(soap, (const struct dss__Apartment_AllocateZone *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_AllocateZoneResponse:
		soap_serialize_dss__Apartment_AllocateZoneResponse(soap, (const struct dss__Apartment_AllocateZoneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetName:
		soap_serialize_dss__Modulator_GetName(soap, (const struct dss__Modulator_GetName *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		soap_serialize_dss__Modulator_GetNameResponse(soap, (const struct dss__Modulator_GetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetDSID:
		soap_serialize_dss__Modulator_GetDSID(soap, (const struct dss__Modulator_GetDSID *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		soap_serialize_dss__Modulator_GetDSIDResponse(soap, (const struct dss__Modulator_GetDSIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		soap_serialize_dss__Apartment_GetModulatorIDs(soap, (const struct dss__Apartment_GetModulatorIDs *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		soap_serialize_dss__Apartment_GetModulatorIDsResponse(soap, (const struct dss__Apartment_GetModulatorIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetPowerConsumption:
		soap_serialize_dss__Modulator_GetPowerConsumption(soap, (const struct dss__Modulator_GetPowerConsumption *)ptr);
		break;
	case SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse:
		soap_serialize_dss__Modulator_GetPowerConsumptionResponse(soap, (const struct dss__Modulator_GetPowerConsumptionResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetDSID:
		soap_serialize_dss__Device_GetDSID(soap, (const struct dss__Device_GetDSID *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		soap_serialize_dss__Device_GetDSIDResponse(soap, (const struct dss__Device_GetDSIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetZoneID:
		soap_serialize_dss__Device_GetZoneID(soap, (const struct dss__Device_GetZoneID *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetZoneIDResponse:
		soap_serialize_dss__Device_GetZoneIDResponse(soap, (const struct dss__Device_GetZoneIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetName:
		soap_serialize_dss__Device_GetName(soap, (const struct dss__Device_GetName *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetNameResponse:
		soap_serialize_dss__Device_GetNameResponse(soap, (const struct dss__Device_GetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_SaveScene:
		soap_serialize_dss__Device_SaveScene(soap, (const struct dss__Device_SaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__Device_SaveSceneResponse:
		soap_serialize_dss__Device_SaveSceneResponse(soap, (const struct dss__Device_SaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_CallScene:
		soap_serialize_dss__Device_CallScene(soap, (const struct dss__Device_CallScene *)ptr);
		break;
	case SOAP_TYPE_dss__Device_CallSceneResponse:
		soap_serialize_dss__Device_CallSceneResponse(soap, (const struct dss__Device_CallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetValue:
		soap_serialize_dss__Device_GetValue(soap, (const struct dss__Device_GetValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_GetValueResponse:
		soap_serialize_dss__Device_GetValueResponse(soap, (const struct dss__Device_GetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_SetValue:
		soap_serialize_dss__Device_SetValue(soap, (const struct dss__Device_SetValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_SetValueResponse:
		soap_serialize_dss__Device_SetValueResponse(soap, (const struct dss__Device_SetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_EndDim:
		soap_serialize_dss__Device_EndDim(soap, (const struct dss__Device_EndDim *)ptr);
		break;
	case SOAP_TYPE_dss__Device_EndDimResponse:
		soap_serialize_dss__Device_EndDimResponse(soap, (const struct dss__Device_EndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_StartDim:
		soap_serialize_dss__Device_StartDim(soap, (const struct dss__Device_StartDim *)ptr);
		break;
	case SOAP_TYPE_dss__Device_StartDimResponse:
		soap_serialize_dss__Device_StartDimResponse(soap, (const struct dss__Device_StartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_Disable:
		soap_serialize_dss__Device_Disable(soap, (const struct dss__Device_Disable *)ptr);
		break;
	case SOAP_TYPE_dss__Device_DisableResponse:
		soap_serialize_dss__Device_DisableResponse(soap, (const struct dss__Device_DisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_Enable:
		soap_serialize_dss__Device_Enable(soap, (const struct dss__Device_Enable *)ptr);
		break;
	case SOAP_TYPE_dss__Device_EnableResponse:
		soap_serialize_dss__Device_EnableResponse(soap, (const struct dss__Device_EnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_DecreaseValue:
		soap_serialize_dss__Device_DecreaseValue(soap, (const struct dss__Device_DecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		soap_serialize_dss__Device_DecreaseValueResponse(soap, (const struct dss__Device_DecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_IncreaseValue:
		soap_serialize_dss__Device_IncreaseValue(soap, (const struct dss__Device_IncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		soap_serialize_dss__Device_IncreaseValueResponse(soap, (const struct dss__Device_IncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOff:
		soap_serialize_dss__Device_TurnOff(soap, (const struct dss__Device_TurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		soap_serialize_dss__Device_TurnOffResponse(soap, (const struct dss__Device_TurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOn:
		soap_serialize_dss__Device_TurnOn(soap, (const struct dss__Device_TurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		soap_serialize_dss__Device_TurnOnResponse(soap, (const struct dss__Device_TurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_SaveScene:
		soap_serialize_dss__Group_SaveScene(soap, (const struct dss__Group_SaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__Group_SaveSceneResponse:
		soap_serialize_dss__Group_SaveSceneResponse(soap, (const struct dss__Group_SaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_CallScene:
		soap_serialize_dss__Group_CallScene(soap, (const struct dss__Group_CallScene *)ptr);
		break;
	case SOAP_TYPE_dss__Group_CallSceneResponse:
		soap_serialize_dss__Group_CallSceneResponse(soap, (const struct dss__Group_CallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_SetValue:
		soap_serialize_dss__Group_SetValue(soap, (const struct dss__Group_SetValue *)ptr);
		break;
	case SOAP_TYPE_dss__Group_SetValueResponse:
		soap_serialize_dss__Group_SetValueResponse(soap, (const struct dss__Group_SetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_EndDim:
		soap_serialize_dss__Group_EndDim(soap, (const struct dss__Group_EndDim *)ptr);
		break;
	case SOAP_TYPE_dss__Group_EndDimResponse:
		soap_serialize_dss__Group_EndDimResponse(soap, (const struct dss__Group_EndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_StartDim:
		soap_serialize_dss__Group_StartDim(soap, (const struct dss__Group_StartDim *)ptr);
		break;
	case SOAP_TYPE_dss__Group_StartDimResponse:
		soap_serialize_dss__Group_StartDimResponse(soap, (const struct dss__Group_StartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_Disable:
		soap_serialize_dss__Group_Disable(soap, (const struct dss__Group_Disable *)ptr);
		break;
	case SOAP_TYPE_dss__Group_DisableResponse:
		soap_serialize_dss__Group_DisableResponse(soap, (const struct dss__Group_DisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_Enable:
		soap_serialize_dss__Group_Enable(soap, (const struct dss__Group_Enable *)ptr);
		break;
	case SOAP_TYPE_dss__Group_EnableResponse:
		soap_serialize_dss__Group_EnableResponse(soap, (const struct dss__Group_EnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_DecreaseValue:
		soap_serialize_dss__Group_DecreaseValue(soap, (const struct dss__Group_DecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Group_DecreaseValueResponse:
		soap_serialize_dss__Group_DecreaseValueResponse(soap, (const struct dss__Group_DecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_IncreaseValue:
		soap_serialize_dss__Group_IncreaseValue(soap, (const struct dss__Group_IncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Group_IncreaseValueResponse:
		soap_serialize_dss__Group_IncreaseValueResponse(soap, (const struct dss__Group_IncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_TurnOff:
		soap_serialize_dss__Group_TurnOff(soap, (const struct dss__Group_TurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__Group_TurnOffResponse:
		soap_serialize_dss__Group_TurnOffResponse(soap, (const struct dss__Group_TurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Group_TurnOn:
		soap_serialize_dss__Group_TurnOn(soap, (const struct dss__Group_TurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__Group_TurnOnResponse:
		soap_serialize_dss__Group_TurnOnResponse(soap, (const struct dss__Group_TurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_SaveScene:
		soap_serialize_dss__Set_SaveScene(soap, (const struct dss__Set_SaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__Set_SaveSceneResponse:
		soap_serialize_dss__Set_SaveSceneResponse(soap, (const struct dss__Set_SaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_CallScene:
		soap_serialize_dss__Set_CallScene(soap, (const struct dss__Set_CallScene *)ptr);
		break;
	case SOAP_TYPE_dss__Set_CallSceneResponse:
		soap_serialize_dss__Set_CallSceneResponse(soap, (const struct dss__Set_CallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_SetValue:
		soap_serialize_dss__Set_SetValue(soap, (const struct dss__Set_SetValue *)ptr);
		break;
	case SOAP_TYPE_dss__Set_SetValueResponse:
		soap_serialize_dss__Set_SetValueResponse(soap, (const struct dss__Set_SetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_EndDim:
		soap_serialize_dss__Set_EndDim(soap, (const struct dss__Set_EndDim *)ptr);
		break;
	case SOAP_TYPE_dss__Set_EndDimResponse:
		soap_serialize_dss__Set_EndDimResponse(soap, (const struct dss__Set_EndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_StartDim:
		soap_serialize_dss__Set_StartDim(soap, (const struct dss__Set_StartDim *)ptr);
		break;
	case SOAP_TYPE_dss__Set_StartDimResponse:
		soap_serialize_dss__Set_StartDimResponse(soap, (const struct dss__Set_StartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Disable:
		soap_serialize_dss__Set_Disable(soap, (const struct dss__Set_Disable *)ptr);
		break;
	case SOAP_TYPE_dss__Set_DisableResponse:
		soap_serialize_dss__Set_DisableResponse(soap, (const struct dss__Set_DisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Enable:
		soap_serialize_dss__Set_Enable(soap, (const struct dss__Set_Enable *)ptr);
		break;
	case SOAP_TYPE_dss__Set_EnableResponse:
		soap_serialize_dss__Set_EnableResponse(soap, (const struct dss__Set_EnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_DecreaseValue:
		soap_serialize_dss__Set_DecreaseValue(soap, (const struct dss__Set_DecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		soap_serialize_dss__Set_DecreaseValueResponse(soap, (const struct dss__Set_DecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_IncreaseValue:
		soap_serialize_dss__Set_IncreaseValue(soap, (const struct dss__Set_IncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		soap_serialize_dss__Set_IncreaseValueResponse(soap, (const struct dss__Set_IncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOff:
		soap_serialize_dss__Set_TurnOff(soap, (const struct dss__Set_TurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		soap_serialize_dss__Set_TurnOffResponse(soap, (const struct dss__Set_TurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOn:
		soap_serialize_dss__Set_TurnOn(soap, (const struct dss__Set_TurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		soap_serialize_dss__Set_TurnOnResponse(soap, (const struct dss__Set_TurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneIDs:
		soap_serialize_dss__Apartment_GetZoneIDs(soap, (const struct dss__Apartment_GetZoneIDs *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneIDsResponse:
		soap_serialize_dss__Apartment_GetZoneIDsResponse(soap, (const struct dss__Apartment_GetZoneIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneByName:
		soap_serialize_dss__Apartment_GetZoneByName(soap, (const struct dss__Apartment_GetZoneByName *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneByNameResponse:
		soap_serialize_dss__Apartment_GetZoneByNameResponse(soap, (const struct dss__Apartment_GetZoneByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		soap_serialize_dss__Apartment_GetGroupByName(soap, (const struct dss__Apartment_GetGroupByName *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		soap_serialize_dss__Apartment_GetGroupByNameResponse(soap, (const struct dss__Apartment_GetGroupByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_GetContainedDevices:
		soap_serialize_dss__Set_GetContainedDevices(soap, (const struct dss__Set_GetContainedDevices *)ptr);
		break;
	case SOAP_TYPE_dss__Set_GetContainedDevicesResponse:
		soap_serialize_dss__Set_GetContainedDevicesResponse(soap, (const struct dss__Set_GetContainedDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_ByGroup:
		soap_serialize_dss__Set_ByGroup(soap, (const struct dss__Set_ByGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		soap_serialize_dss__Set_ByGroupResponse(soap, (const struct dss__Set_ByGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Remove:
		soap_serialize_dss__Set_Remove(soap, (const struct dss__Set_Remove *)ptr);
		break;
	case SOAP_TYPE_dss__Set_RemoveResponse:
		soap_serialize_dss__Set_RemoveResponse(soap, (const struct dss__Set_RemoveResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_Combine:
		soap_serialize_dss__Set_Combine(soap, (const struct dss__Set_Combine *)ptr);
		break;
	case SOAP_TYPE_dss__Set_CombineResponse:
		soap_serialize_dss__Set_CombineResponse(soap, (const struct dss__Set_CombineResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_RemoveDevice:
		soap_serialize_dss__Set_RemoveDevice(soap, (const struct dss__Set_RemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		soap_serialize_dss__Set_RemoveDeviceResponse(soap, (const struct dss__Set_RemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		soap_serialize_dss__Set_AddDeviceByID(soap, (const struct dss__Set_AddDeviceByID *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		soap_serialize_dss__Set_AddDeviceByIDResponse(soap, (const struct dss__Set_AddDeviceByIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		soap_serialize_dss__Set_AddDeviceByName(soap, (const struct dss__Set_AddDeviceByName *)ptr);
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		soap_serialize_dss__Set_AddDeviceByNameResponse(soap, (const struct dss__Set_AddDeviceByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		soap_serialize_dss__Apartment_GetDeviceIDByName(soap, (const struct dss__Apartment_GetDeviceIDByName *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		soap_serialize_dss__Apartment_GetDeviceIDByNameResponse(soap, (const struct dss__Apartment_GetDeviceIDByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDevices:
		soap_serialize_dss__Apartment_GetDevices(soap, (const struct dss__Apartment_GetDevices *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		soap_serialize_dss__Apartment_GetDevicesResponse(soap, (const struct dss__Apartment_GetDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		soap_serialize_dss__Apartment_CreateEmptySet(soap, (const struct dss__Apartment_CreateEmptySet *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		soap_serialize_dss__Apartment_CreateEmptySetResponse(soap, (const struct dss__Apartment_CreateEmptySetResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		soap_serialize_dss__Apartment_CreateSetFromDeviceNames(soap, (const struct dss__Apartment_CreateSetFromDeviceNames *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		soap_serialize_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, (const struct dss__Apartment_CreateSetFromDeviceNamesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		soap_serialize_dss__Apartment_CreateSetFromDeviceIDs(soap, (const struct dss__Apartment_CreateSetFromDeviceIDs *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		soap_serialize_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, (const struct dss__Apartment_CreateSetFromDeviceIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		soap_serialize_dss__Apartment_CreateSetFromGroup(soap, (const struct dss__Apartment_CreateSetFromGroup *)ptr);
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		soap_serialize_dss__Apartment_CreateSetFromGroupResponse(soap, (const struct dss__Apartment_CreateSetFromGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__FreeSet:
		soap_serialize_dss__FreeSet(soap, (const struct dss__FreeSet *)ptr);
		break;
	case SOAP_TYPE_dss__FreeSetResponse:
		soap_serialize_dss__FreeSetResponse(soap, (const struct dss__FreeSetResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SignOff:
		soap_serialize_dss__SignOff(soap, (const struct dss__SignOff *)ptr);
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		soap_serialize_dss__SignOffResponse(soap, (const struct dss__SignOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Authenticate:
		soap_serialize_dss__Authenticate(soap, (const struct dss__Authenticate *)ptr);
		break;
	case SOAP_TYPE_dss__AuthenticateResponse:
		soap_serialize_dss__AuthenticateResponse(soap, (const struct dss__AuthenticateResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Test:
		soap_serialize_dss__Test(soap, (const struct dss__Test *)ptr);
		break;
	case SOAP_TYPE_dss__TestResponse:
		soap_serialize_dss__TestResponse(soap, (const struct dss__TestResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_dss__TestResponse:
		return (void*)soap_instantiate_dss__TestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Test:
		return (void*)soap_instantiate_dss__Test(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__AuthenticateResponse:
		return (void*)soap_instantiate_dss__AuthenticateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Authenticate:
		return (void*)soap_instantiate_dss__Authenticate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOffResponse:
		return (void*)soap_instantiate_dss__SignOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOff:
		return (void*)soap_instantiate_dss__SignOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__FreeSetResponse:
		return (void*)soap_instantiate_dss__FreeSetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__FreeSet:
		return (void*)soap_instantiate_dss__FreeSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		return (void*)soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		return (void*)soap_instantiate_dss__Apartment_CreateEmptySetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		return (void*)soap_instantiate_dss__Apartment_CreateEmptySet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		return (void*)soap_instantiate_dss__Apartment_GetDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDevices:
		return (void*)soap_instantiate_dss__Apartment_GetDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		return (void*)soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		return (void*)soap_instantiate_dss__Apartment_GetDeviceIDByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		return (void*)soap_instantiate_dss__Set_AddDeviceByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		return (void*)soap_instantiate_dss__Set_AddDeviceByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		return (void*)soap_instantiate_dss__Set_AddDeviceByIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		return (void*)soap_instantiate_dss__Set_AddDeviceByID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		return (void*)soap_instantiate_dss__Set_RemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_RemoveDevice:
		return (void*)soap_instantiate_dss__Set_RemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_CombineResponse:
		return (void*)soap_instantiate_dss__Set_CombineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Combine:
		return (void*)soap_instantiate_dss__Set_Combine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_RemoveResponse:
		return (void*)soap_instantiate_dss__Set_RemoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Remove:
		return (void*)soap_instantiate_dss__Set_Remove(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		return (void*)soap_instantiate_dss__Set_ByGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_ByGroup:
		return (void*)soap_instantiate_dss__Set_ByGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_GetContainedDevicesResponse:
		return (void*)soap_instantiate_dss__Set_GetContainedDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_GetContainedDevices:
		return (void*)soap_instantiate_dss__Set_GetContainedDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		return (void*)soap_instantiate_dss__Apartment_GetGroupByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		return (void*)soap_instantiate_dss__Apartment_GetGroupByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetZoneByNameResponse:
		return (void*)soap_instantiate_dss__Apartment_GetZoneByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetZoneByName:
		return (void*)soap_instantiate_dss__Apartment_GetZoneByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetZoneIDsResponse:
		return (void*)soap_instantiate_dss__Apartment_GetZoneIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetZoneIDs:
		return (void*)soap_instantiate_dss__Apartment_GetZoneIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		return (void*)soap_instantiate_dss__Set_TurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOn:
		return (void*)soap_instantiate_dss__Set_TurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		return (void*)soap_instantiate_dss__Set_TurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_TurnOff:
		return (void*)soap_instantiate_dss__Set_TurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		return (void*)soap_instantiate_dss__Set_IncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_IncreaseValue:
		return (void*)soap_instantiate_dss__Set_IncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		return (void*)soap_instantiate_dss__Set_DecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_DecreaseValue:
		return (void*)soap_instantiate_dss__Set_DecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_EnableResponse:
		return (void*)soap_instantiate_dss__Set_EnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Enable:
		return (void*)soap_instantiate_dss__Set_Enable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_DisableResponse:
		return (void*)soap_instantiate_dss__Set_DisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_Disable:
		return (void*)soap_instantiate_dss__Set_Disable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_StartDimResponse:
		return (void*)soap_instantiate_dss__Set_StartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_StartDim:
		return (void*)soap_instantiate_dss__Set_StartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_EndDimResponse:
		return (void*)soap_instantiate_dss__Set_EndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_EndDim:
		return (void*)soap_instantiate_dss__Set_EndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_SetValueResponse:
		return (void*)soap_instantiate_dss__Set_SetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_SetValue:
		return (void*)soap_instantiate_dss__Set_SetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_CallSceneResponse:
		return (void*)soap_instantiate_dss__Set_CallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_CallScene:
		return (void*)soap_instantiate_dss__Set_CallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_SaveSceneResponse:
		return (void*)soap_instantiate_dss__Set_SaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Set_SaveScene:
		return (void*)soap_instantiate_dss__Set_SaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_TurnOnResponse:
		return (void*)soap_instantiate_dss__Group_TurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_TurnOn:
		return (void*)soap_instantiate_dss__Group_TurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_TurnOffResponse:
		return (void*)soap_instantiate_dss__Group_TurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_TurnOff:
		return (void*)soap_instantiate_dss__Group_TurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_IncreaseValueResponse:
		return (void*)soap_instantiate_dss__Group_IncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_IncreaseValue:
		return (void*)soap_instantiate_dss__Group_IncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_DecreaseValueResponse:
		return (void*)soap_instantiate_dss__Group_DecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_DecreaseValue:
		return (void*)soap_instantiate_dss__Group_DecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_EnableResponse:
		return (void*)soap_instantiate_dss__Group_EnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_Enable:
		return (void*)soap_instantiate_dss__Group_Enable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_DisableResponse:
		return (void*)soap_instantiate_dss__Group_DisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_Disable:
		return (void*)soap_instantiate_dss__Group_Disable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_StartDimResponse:
		return (void*)soap_instantiate_dss__Group_StartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_StartDim:
		return (void*)soap_instantiate_dss__Group_StartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_EndDimResponse:
		return (void*)soap_instantiate_dss__Group_EndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_EndDim:
		return (void*)soap_instantiate_dss__Group_EndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_SetValueResponse:
		return (void*)soap_instantiate_dss__Group_SetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_SetValue:
		return (void*)soap_instantiate_dss__Group_SetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_CallSceneResponse:
		return (void*)soap_instantiate_dss__Group_CallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_CallScene:
		return (void*)soap_instantiate_dss__Group_CallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_SaveSceneResponse:
		return (void*)soap_instantiate_dss__Group_SaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_SaveScene:
		return (void*)soap_instantiate_dss__Group_SaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		return (void*)soap_instantiate_dss__Device_TurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOn:
		return (void*)soap_instantiate_dss__Device_TurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		return (void*)soap_instantiate_dss__Device_TurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_TurnOff:
		return (void*)soap_instantiate_dss__Device_TurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		return (void*)soap_instantiate_dss__Device_IncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_IncreaseValue:
		return (void*)soap_instantiate_dss__Device_IncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		return (void*)soap_instantiate_dss__Device_DecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_DecreaseValue:
		return (void*)soap_instantiate_dss__Device_DecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_EnableResponse:
		return (void*)soap_instantiate_dss__Device_EnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_Enable:
		return (void*)soap_instantiate_dss__Device_Enable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_DisableResponse:
		return (void*)soap_instantiate_dss__Device_DisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_Disable:
		return (void*)soap_instantiate_dss__Device_Disable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_StartDimResponse:
		return (void*)soap_instantiate_dss__Device_StartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_StartDim:
		return (void*)soap_instantiate_dss__Device_StartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_EndDimResponse:
		return (void*)soap_instantiate_dss__Device_EndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_EndDim:
		return (void*)soap_instantiate_dss__Device_EndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_SetValueResponse:
		return (void*)soap_instantiate_dss__Device_SetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_SetValue:
		return (void*)soap_instantiate_dss__Device_SetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetValueResponse:
		return (void*)soap_instantiate_dss__Device_GetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetValue:
		return (void*)soap_instantiate_dss__Device_GetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_CallSceneResponse:
		return (void*)soap_instantiate_dss__Device_CallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_CallScene:
		return (void*)soap_instantiate_dss__Device_CallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_SaveSceneResponse:
		return (void*)soap_instantiate_dss__Device_SaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_SaveScene:
		return (void*)soap_instantiate_dss__Device_SaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetNameResponse:
		return (void*)soap_instantiate_dss__Device_GetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetName:
		return (void*)soap_instantiate_dss__Device_GetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetZoneIDResponse:
		return (void*)soap_instantiate_dss__Device_GetZoneIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetZoneID:
		return (void*)soap_instantiate_dss__Device_GetZoneID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		return (void*)soap_instantiate_dss__Device_GetDSIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetDSID:
		return (void*)soap_instantiate_dss__Device_GetDSID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse:
		return (void*)soap_instantiate_dss__Modulator_GetPowerConsumptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetPowerConsumption:
		return (void*)soap_instantiate_dss__Modulator_GetPowerConsumption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		return (void*)soap_instantiate_dss__Apartment_GetModulatorIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		return (void*)soap_instantiate_dss__Apartment_GetModulatorIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		return (void*)soap_instantiate_dss__Modulator_GetDSIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetDSID:
		return (void*)soap_instantiate_dss__Modulator_GetDSID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		return (void*)soap_instantiate_dss__Modulator_GetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Modulator_GetName:
		return (void*)soap_instantiate_dss__Modulator_GetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateZoneResponse:
		return (void*)soap_instantiate_dss__Apartment_AllocateZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateZone:
		return (void*)soap_instantiate_dss__Apartment_AllocateZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_DeleteZoneResponse:
		return (void*)soap_instantiate_dss__Apartment_DeleteZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_DeleteZone:
		return (void*)soap_instantiate_dss__Apartment_DeleteZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		return (void*)soap_instantiate_dss__Zone_AddDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_AddDevice:
		return (void*)soap_instantiate_dss__Zone_AddDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		return (void*)soap_instantiate_dss__Zone_RemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		return (void*)soap_instantiate_dss__Zone_RemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		return (void*)soap_instantiate_dss__Zone_SetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_SetName:
		return (void*)soap_instantiate_dss__Zone_SetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		return (void*)soap_instantiate_dss__Apartment_AllocateUserGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		return (void*)soap_instantiate_dss__Apartment_AllocateUserGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		return (void*)soap_instantiate_dss__Group_RemoveUserGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		return (void*)soap_instantiate_dss__Group_RemoveUserGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		return (void*)soap_instantiate_dss__Group_AddDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_AddDevice:
		return (void*)soap_instantiate_dss__Group_AddDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		return (void*)soap_instantiate_dss__Group_RemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Group_RemoveDevice:
		return (void*)soap_instantiate_dss__Group_RemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetFunctionIDResponse:
		return (void*)soap_instantiate_dss__Device_GetFunctionIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Device_GetFunctionID:
		return (void*)soap_instantiate_dss__Device_GetFunctionID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Switch_GetGroupIDResponse:
		return (void*)soap_instantiate_dss__Switch_GetGroupIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Switch_GetGroupID:
		return (void*)soap_instantiate_dss__Switch_GetGroupID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Switch_SimulateKeypressResponse:
		return (void*)soap_instantiate_dss__Switch_SimulateKeypressResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Switch_SimulateKeypress:
		return (void*)soap_instantiate_dss__Switch_SimulateKeypress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__inParameter:
		return (void*)soap_instantiate_dss__inParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__outParameter:
		return (void*)soap_instantiate_dss__outParameter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_RaiseResponse:
		return (void*)soap_instantiate_dss__Event_RaiseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Raise:
		return (void*)soap_instantiate_dss__Event_Raise(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		return (void*)soap_instantiate_dss__Event_GetActionNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_GetActionNames:
		return (void*)soap_instantiate_dss__Event_GetActionNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		return (void*)soap_instantiate_dss__Event_GetActionParamsTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		return (void*)soap_instantiate_dss__Event_SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Subscribe:
		return (void*)soap_instantiate_dss__Event_Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		return (void*)soap_instantiate_dss__Event_UnsubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Unsubscribe:
		return (void*)soap_instantiate_dss__Event_Unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		return (void*)soap_instantiate_dss__Event_ScheduleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_Schedule:
		return (void*)soap_instantiate_dss__Event_Schedule(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		return (void*)soap_instantiate_dss__Event_DeleteScheduleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		return (void*)soap_instantiate_dss__Event_DeleteSchedule(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_dss__TestResponse:
		if (p->size < 0)
			delete (struct dss__TestResponse*)p->ptr;
		else
			delete[] (struct dss__TestResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Test:
		if (p->size < 0)
			delete (struct dss__Test*)p->ptr;
		else
			delete[] (struct dss__Test*)p->ptr;
		break;
	case SOAP_TYPE_dss__AuthenticateResponse:
		if (p->size < 0)
			delete (struct dss__AuthenticateResponse*)p->ptr;
		else
			delete[] (struct dss__AuthenticateResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Authenticate:
		if (p->size < 0)
			delete (struct dss__Authenticate*)p->ptr;
		else
			delete[] (struct dss__Authenticate*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		if (p->size < 0)
			delete (struct dss__SignOffResponse*)p->ptr;
		else
			delete[] (struct dss__SignOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOff:
		if (p->size < 0)
			delete (struct dss__SignOff*)p->ptr;
		else
			delete[] (struct dss__SignOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__FreeSetResponse:
		if (p->size < 0)
			delete (struct dss__FreeSetResponse*)p->ptr;
		else
			delete[] (struct dss__FreeSetResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__FreeSet:
		if (p->size < 0)
			delete (struct dss__FreeSet*)p->ptr;
		else
			delete[] (struct dss__FreeSet*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromGroup:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromGroup*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceIDsResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceIDs*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceIDs*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceNamesResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceNamesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateSetFromDeviceNames*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateSetFromDeviceNames*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySetResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateEmptySetResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateEmptySetResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_CreateEmptySet:
		if (p->size < 0)
			delete (struct dss__Apartment_CreateEmptySet*)p->ptr;
		else
			delete[] (struct dss__Apartment_CreateEmptySet*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDevicesResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDevicesResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDevicesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDevices:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDevices*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDevices*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDeviceIDByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDeviceIDByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetDeviceIDByName:
		if (p->size < 0)
			delete (struct dss__Apartment_GetDeviceIDByName*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetDeviceIDByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByNameResponse:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByName:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByName*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByIDResponse:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByIDResponse*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_AddDeviceByID:
		if (p->size < 0)
			delete (struct dss__Set_AddDeviceByID*)p->ptr;
		else
			delete[] (struct dss__Set_AddDeviceByID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_RemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Set_RemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Set_RemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_RemoveDevice:
		if (p->size < 0)
			delete (struct dss__Set_RemoveDevice*)p->ptr;
		else
			delete[] (struct dss__Set_RemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_CombineResponse:
		if (p->size < 0)
			delete (struct dss__Set_CombineResponse*)p->ptr;
		else
			delete[] (struct dss__Set_CombineResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Combine:
		if (p->size < 0)
			delete (struct dss__Set_Combine*)p->ptr;
		else
			delete[] (struct dss__Set_Combine*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_RemoveResponse:
		if (p->size < 0)
			delete (struct dss__Set_RemoveResponse*)p->ptr;
		else
			delete[] (struct dss__Set_RemoveResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Remove:
		if (p->size < 0)
			delete (struct dss__Set_Remove*)p->ptr;
		else
			delete[] (struct dss__Set_Remove*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_ByGroupResponse:
		if (p->size < 0)
			delete (struct dss__Set_ByGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Set_ByGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_ByGroup:
		if (p->size < 0)
			delete (struct dss__Set_ByGroup*)p->ptr;
		else
			delete[] (struct dss__Set_ByGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_GetContainedDevicesResponse:
		if (p->size < 0)
			delete (struct dss__Set_GetContainedDevicesResponse*)p->ptr;
		else
			delete[] (struct dss__Set_GetContainedDevicesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_GetContainedDevices:
		if (p->size < 0)
			delete (struct dss__Set_GetContainedDevices*)p->ptr;
		else
			delete[] (struct dss__Set_GetContainedDevices*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByNameResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetGroupByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetGroupByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetGroupByName:
		if (p->size < 0)
			delete (struct dss__Apartment_GetGroupByName*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetGroupByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneByNameResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetZoneByNameResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetZoneByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneByName:
		if (p->size < 0)
			delete (struct dss__Apartment_GetZoneByName*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetZoneByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneIDsResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetZoneIDsResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetZoneIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetZoneIDs:
		if (p->size < 0)
			delete (struct dss__Apartment_GetZoneIDs*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetZoneIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOnResponse:
		if (p->size < 0)
			delete (struct dss__Set_TurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOn:
		if (p->size < 0)
			delete (struct dss__Set_TurnOn*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOffResponse:
		if (p->size < 0)
			delete (struct dss__Set_TurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_TurnOff:
		if (p->size < 0)
			delete (struct dss__Set_TurnOff*)p->ptr;
		else
			delete[] (struct dss__Set_TurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_IncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Set_IncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Set_IncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_IncreaseValue:
		if (p->size < 0)
			delete (struct dss__Set_IncreaseValue*)p->ptr;
		else
			delete[] (struct dss__Set_IncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_DecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Set_DecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Set_DecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_DecreaseValue:
		if (p->size < 0)
			delete (struct dss__Set_DecreaseValue*)p->ptr;
		else
			delete[] (struct dss__Set_DecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_EnableResponse:
		if (p->size < 0)
			delete (struct dss__Set_EnableResponse*)p->ptr;
		else
			delete[] (struct dss__Set_EnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Enable:
		if (p->size < 0)
			delete (struct dss__Set_Enable*)p->ptr;
		else
			delete[] (struct dss__Set_Enable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_DisableResponse:
		if (p->size < 0)
			delete (struct dss__Set_DisableResponse*)p->ptr;
		else
			delete[] (struct dss__Set_DisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_Disable:
		if (p->size < 0)
			delete (struct dss__Set_Disable*)p->ptr;
		else
			delete[] (struct dss__Set_Disable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_StartDimResponse:
		if (p->size < 0)
			delete (struct dss__Set_StartDimResponse*)p->ptr;
		else
			delete[] (struct dss__Set_StartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_StartDim:
		if (p->size < 0)
			delete (struct dss__Set_StartDim*)p->ptr;
		else
			delete[] (struct dss__Set_StartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_EndDimResponse:
		if (p->size < 0)
			delete (struct dss__Set_EndDimResponse*)p->ptr;
		else
			delete[] (struct dss__Set_EndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_EndDim:
		if (p->size < 0)
			delete (struct dss__Set_EndDim*)p->ptr;
		else
			delete[] (struct dss__Set_EndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_SetValueResponse:
		if (p->size < 0)
			delete (struct dss__Set_SetValueResponse*)p->ptr;
		else
			delete[] (struct dss__Set_SetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_SetValue:
		if (p->size < 0)
			delete (struct dss__Set_SetValue*)p->ptr;
		else
			delete[] (struct dss__Set_SetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_CallSceneResponse:
		if (p->size < 0)
			delete (struct dss__Set_CallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__Set_CallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_CallScene:
		if (p->size < 0)
			delete (struct dss__Set_CallScene*)p->ptr;
		else
			delete[] (struct dss__Set_CallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_SaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__Set_SaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__Set_SaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Set_SaveScene:
		if (p->size < 0)
			delete (struct dss__Set_SaveScene*)p->ptr;
		else
			delete[] (struct dss__Set_SaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_TurnOnResponse:
		if (p->size < 0)
			delete (struct dss__Group_TurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__Group_TurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_TurnOn:
		if (p->size < 0)
			delete (struct dss__Group_TurnOn*)p->ptr;
		else
			delete[] (struct dss__Group_TurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_TurnOffResponse:
		if (p->size < 0)
			delete (struct dss__Group_TurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__Group_TurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_TurnOff:
		if (p->size < 0)
			delete (struct dss__Group_TurnOff*)p->ptr;
		else
			delete[] (struct dss__Group_TurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_IncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Group_IncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Group_IncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_IncreaseValue:
		if (p->size < 0)
			delete (struct dss__Group_IncreaseValue*)p->ptr;
		else
			delete[] (struct dss__Group_IncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_DecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Group_DecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Group_DecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_DecreaseValue:
		if (p->size < 0)
			delete (struct dss__Group_DecreaseValue*)p->ptr;
		else
			delete[] (struct dss__Group_DecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_EnableResponse:
		if (p->size < 0)
			delete (struct dss__Group_EnableResponse*)p->ptr;
		else
			delete[] (struct dss__Group_EnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_Enable:
		if (p->size < 0)
			delete (struct dss__Group_Enable*)p->ptr;
		else
			delete[] (struct dss__Group_Enable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_DisableResponse:
		if (p->size < 0)
			delete (struct dss__Group_DisableResponse*)p->ptr;
		else
			delete[] (struct dss__Group_DisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_Disable:
		if (p->size < 0)
			delete (struct dss__Group_Disable*)p->ptr;
		else
			delete[] (struct dss__Group_Disable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_StartDimResponse:
		if (p->size < 0)
			delete (struct dss__Group_StartDimResponse*)p->ptr;
		else
			delete[] (struct dss__Group_StartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_StartDim:
		if (p->size < 0)
			delete (struct dss__Group_StartDim*)p->ptr;
		else
			delete[] (struct dss__Group_StartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_EndDimResponse:
		if (p->size < 0)
			delete (struct dss__Group_EndDimResponse*)p->ptr;
		else
			delete[] (struct dss__Group_EndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_EndDim:
		if (p->size < 0)
			delete (struct dss__Group_EndDim*)p->ptr;
		else
			delete[] (struct dss__Group_EndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_SetValueResponse:
		if (p->size < 0)
			delete (struct dss__Group_SetValueResponse*)p->ptr;
		else
			delete[] (struct dss__Group_SetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_SetValue:
		if (p->size < 0)
			delete (struct dss__Group_SetValue*)p->ptr;
		else
			delete[] (struct dss__Group_SetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_CallSceneResponse:
		if (p->size < 0)
			delete (struct dss__Group_CallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__Group_CallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_CallScene:
		if (p->size < 0)
			delete (struct dss__Group_CallScene*)p->ptr;
		else
			delete[] (struct dss__Group_CallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_SaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__Group_SaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__Group_SaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_SaveScene:
		if (p->size < 0)
			delete (struct dss__Group_SaveScene*)p->ptr;
		else
			delete[] (struct dss__Group_SaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOnResponse:
		if (p->size < 0)
			delete (struct dss__Device_TurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOn:
		if (p->size < 0)
			delete (struct dss__Device_TurnOn*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOffResponse:
		if (p->size < 0)
			delete (struct dss__Device_TurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_TurnOff:
		if (p->size < 0)
			delete (struct dss__Device_TurnOff*)p->ptr;
		else
			delete[] (struct dss__Device_TurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_IncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_IncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_IncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_IncreaseValue:
		if (p->size < 0)
			delete (struct dss__Device_IncreaseValue*)p->ptr;
		else
			delete[] (struct dss__Device_IncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_DecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_DecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_DecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_DecreaseValue:
		if (p->size < 0)
			delete (struct dss__Device_DecreaseValue*)p->ptr;
		else
			delete[] (struct dss__Device_DecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_EnableResponse:
		if (p->size < 0)
			delete (struct dss__Device_EnableResponse*)p->ptr;
		else
			delete[] (struct dss__Device_EnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_Enable:
		if (p->size < 0)
			delete (struct dss__Device_Enable*)p->ptr;
		else
			delete[] (struct dss__Device_Enable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_DisableResponse:
		if (p->size < 0)
			delete (struct dss__Device_DisableResponse*)p->ptr;
		else
			delete[] (struct dss__Device_DisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_Disable:
		if (p->size < 0)
			delete (struct dss__Device_Disable*)p->ptr;
		else
			delete[] (struct dss__Device_Disable*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_StartDimResponse:
		if (p->size < 0)
			delete (struct dss__Device_StartDimResponse*)p->ptr;
		else
			delete[] (struct dss__Device_StartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_StartDim:
		if (p->size < 0)
			delete (struct dss__Device_StartDim*)p->ptr;
		else
			delete[] (struct dss__Device_StartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_EndDimResponse:
		if (p->size < 0)
			delete (struct dss__Device_EndDimResponse*)p->ptr;
		else
			delete[] (struct dss__Device_EndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_EndDim:
		if (p->size < 0)
			delete (struct dss__Device_EndDim*)p->ptr;
		else
			delete[] (struct dss__Device_EndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_SetValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_SetValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_SetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_SetValue:
		if (p->size < 0)
			delete (struct dss__Device_SetValue*)p->ptr;
		else
			delete[] (struct dss__Device_SetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetValueResponse:
		if (p->size < 0)
			delete (struct dss__Device_GetValueResponse*)p->ptr;
		else
			delete[] (struct dss__Device_GetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetValue:
		if (p->size < 0)
			delete (struct dss__Device_GetValue*)p->ptr;
		else
			delete[] (struct dss__Device_GetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_CallSceneResponse:
		if (p->size < 0)
			delete (struct dss__Device_CallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__Device_CallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_CallScene:
		if (p->size < 0)
			delete (struct dss__Device_CallScene*)p->ptr;
		else
			delete[] (struct dss__Device_CallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_SaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__Device_SaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__Device_SaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_SaveScene:
		if (p->size < 0)
			delete (struct dss__Device_SaveScene*)p->ptr;
		else
			delete[] (struct dss__Device_SaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetNameResponse:
		if (p->size < 0)
			delete (struct dss__Device_GetNameResponse*)p->ptr;
		else
			delete[] (struct dss__Device_GetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetName:
		if (p->size < 0)
			delete (struct dss__Device_GetName*)p->ptr;
		else
			delete[] (struct dss__Device_GetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetZoneIDResponse:
		if (p->size < 0)
			delete (struct dss__Device_GetZoneIDResponse*)p->ptr;
		else
			delete[] (struct dss__Device_GetZoneIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetZoneID:
		if (p->size < 0)
			delete (struct dss__Device_GetZoneID*)p->ptr;
		else
			delete[] (struct dss__Device_GetZoneID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetDSIDResponse:
		if (p->size < 0)
			delete (struct dss__Device_GetDSIDResponse*)p->ptr;
		else
			delete[] (struct dss__Device_GetDSIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetDSID:
		if (p->size < 0)
			delete (struct dss__Device_GetDSID*)p->ptr;
		else
			delete[] (struct dss__Device_GetDSID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse:
		if (p->size < 0)
			delete (struct dss__Modulator_GetPowerConsumptionResponse*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetPowerConsumptionResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetPowerConsumption:
		if (p->size < 0)
			delete (struct dss__Modulator_GetPowerConsumption*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetPowerConsumption*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_GetModulatorIDsResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetModulatorIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_GetModulatorIDs:
		if (p->size < 0)
			delete (struct dss__Apartment_GetModulatorIDs*)p->ptr;
		else
			delete[] (struct dss__Apartment_GetModulatorIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetDSIDResponse:
		if (p->size < 0)
			delete (struct dss__Modulator_GetDSIDResponse*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetDSIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetDSID:
		if (p->size < 0)
			delete (struct dss__Modulator_GetDSID*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetDSID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetNameResponse:
		if (p->size < 0)
			delete (struct dss__Modulator_GetNameResponse*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Modulator_GetName:
		if (p->size < 0)
			delete (struct dss__Modulator_GetName*)p->ptr;
		else
			delete[] (struct dss__Modulator_GetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateZoneResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateZoneResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateZoneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateZone:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateZone*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateZone*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_DeleteZoneResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_DeleteZoneResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_DeleteZoneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_DeleteZone:
		if (p->size < 0)
			delete (struct dss__Apartment_DeleteZone*)p->ptr;
		else
			delete[] (struct dss__Apartment_DeleteZone*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Zone_AddDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Zone_AddDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_AddDevice:
		if (p->size < 0)
			delete (struct dss__Zone_AddDevice*)p->ptr;
		else
			delete[] (struct dss__Zone_AddDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Zone_RemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Zone_RemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		if (p->size < 0)
			delete (struct dss__Zone_RemoveDevice*)p->ptr;
		else
			delete[] (struct dss__Zone_RemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		if (p->size < 0)
			delete (struct dss__Zone_SetNameResponse*)p->ptr;
		else
			delete[] (struct dss__Zone_SetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_SetName:
		if (p->size < 0)
			delete (struct dss__Zone_SetName*)p->ptr;
		else
			delete[] (struct dss__Zone_SetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateUserGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateUserGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Apartment_AllocateUserGroup:
		if (p->size < 0)
			delete (struct dss__Apartment_AllocateUserGroup*)p->ptr;
		else
			delete[] (struct dss__Apartment_AllocateUserGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroupResponse:
		if (p->size < 0)
			delete (struct dss__Group_RemoveUserGroupResponse*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveUserGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveUserGroup:
		if (p->size < 0)
			delete (struct dss__Group_RemoveUserGroup*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveUserGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_AddDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Group_AddDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Group_AddDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_AddDevice:
		if (p->size < 0)
			delete (struct dss__Group_AddDevice*)p->ptr;
		else
			delete[] (struct dss__Group_AddDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Group_RemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Group_RemoveDevice:
		if (p->size < 0)
			delete (struct dss__Group_RemoveDevice*)p->ptr;
		else
			delete[] (struct dss__Group_RemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetFunctionIDResponse:
		if (p->size < 0)
			delete (struct dss__Device_GetFunctionIDResponse*)p->ptr;
		else
			delete[] (struct dss__Device_GetFunctionIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Device_GetFunctionID:
		if (p->size < 0)
			delete (struct dss__Device_GetFunctionID*)p->ptr;
		else
			delete[] (struct dss__Device_GetFunctionID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Switch_GetGroupIDResponse:
		if (p->size < 0)
			delete (struct dss__Switch_GetGroupIDResponse*)p->ptr;
		else
			delete[] (struct dss__Switch_GetGroupIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Switch_GetGroupID:
		if (p->size < 0)
			delete (struct dss__Switch_GetGroupID*)p->ptr;
		else
			delete[] (struct dss__Switch_GetGroupID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Switch_SimulateKeypressResponse:
		if (p->size < 0)
			delete (struct dss__Switch_SimulateKeypressResponse*)p->ptr;
		else
			delete[] (struct dss__Switch_SimulateKeypressResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Switch_SimulateKeypress:
		if (p->size < 0)
			delete (struct dss__Switch_SimulateKeypress*)p->ptr;
		else
			delete[] (struct dss__Switch_SimulateKeypress*)p->ptr;
		break;
	case SOAP_TYPE_dss__inParameter:
		if (p->size < 0)
			delete (dss__inParameter*)p->ptr;
		else
			delete[] (dss__inParameter*)p->ptr;
		break;
	case SOAP_TYPE_dss__outParameter:
		if (p->size < 0)
			delete (dss__outParameter*)p->ptr;
		else
			delete[] (dss__outParameter*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_RaiseResponse:
		if (p->size < 0)
			delete (struct dss__Event_RaiseResponse*)p->ptr;
		else
			delete[] (struct dss__Event_RaiseResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Raise:
		if (p->size < 0)
			delete (struct dss__Event_Raise*)p->ptr;
		else
			delete[] (struct dss__Event_Raise*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_GetActionNamesResponse:
		if (p->size < 0)
			delete (struct dss__Event_GetActionNamesResponse*)p->ptr;
		else
			delete[] (struct dss__Event_GetActionNamesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_GetActionNames:
		if (p->size < 0)
			delete (struct dss__Event_GetActionNames*)p->ptr;
		else
			delete[] (struct dss__Event_GetActionNames*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_GetActionParamsTemplate:
		if (p->size < 0)
			delete (struct dss__Event_GetActionParamsTemplate*)p->ptr;
		else
			delete[] (struct dss__Event_GetActionParamsTemplate*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_SubscribeResponse:
		if (p->size < 0)
			delete (struct dss__Event_SubscribeResponse*)p->ptr;
		else
			delete[] (struct dss__Event_SubscribeResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Subscribe:
		if (p->size < 0)
			delete (struct dss__Event_Subscribe*)p->ptr;
		else
			delete[] (struct dss__Event_Subscribe*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_UnsubscribeResponse:
		if (p->size < 0)
			delete (struct dss__Event_UnsubscribeResponse*)p->ptr;
		else
			delete[] (struct dss__Event_UnsubscribeResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Unsubscribe:
		if (p->size < 0)
			delete (struct dss__Event_Unsubscribe*)p->ptr;
		else
			delete[] (struct dss__Event_Unsubscribe*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_ScheduleResponse:
		if (p->size < 0)
			delete (struct dss__Event_ScheduleResponse*)p->ptr;
		else
			delete[] (struct dss__Event_ScheduleResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_Schedule:
		if (p->size < 0)
			delete (struct dss__Event_Schedule*)p->ptr;
		else
			delete[] (struct dss__Event_Schedule*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_DeleteScheduleResponse:
		if (p->size < 0)
			delete (struct dss__Event_DeleteScheduleResponse*)p->ptr;
		else
			delete[] (struct dss__Event_DeleteScheduleResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event_DeleteSchedule:
		if (p->size < 0)
			delete (struct dss__Event_DeleteSchedule*)p->ptr;
		else
			delete[] (struct dss__Event_DeleteSchedule*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedInt(struct soap *soap, unsigned long *a)
{	soap_default_unsignedLong(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedInt(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (soap_out_xsd__unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void dss__outParameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->dss__outParameter::values);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->dss__outParameter::names);
}

void dss__outParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->dss__outParameter::values);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->dss__outParameter::names);
}

int dss__outParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dss__outParameter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int dss__outParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dss__outParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__outParameter(struct soap *soap, const char *tag, int id, const dss__outParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__outParameter), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "values", -1, &(a->dss__outParameter::values), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "names", -1, &(a->dss__outParameter::names), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dss__outParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dss__outParameter(soap, this, tag, type);
}

SOAP_FMAC3 dss__outParameter * SOAP_FMAC4 soap_get_dss__outParameter(struct soap *soap, dss__outParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__outParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *dss__outParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_dss__outParameter(soap, tag, this, type);
}

SOAP_FMAC3 dss__outParameter * SOAP_FMAC4 soap_in_dss__outParameter(struct soap *soap, const char *tag, dss__outParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dss__outParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__outParameter, sizeof(dss__outParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_dss__outParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (dss__outParameter *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "values", &(a->dss__outParameter::values), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "names", &(a->dss__outParameter::names), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (dss__outParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__outParameter, 0, sizeof(dss__outParameter), 0, soap_copy_dss__outParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 dss__outParameter * SOAP_FMAC6 soap_new_dss__outParameter(struct soap *soap, int n)
{	return soap_instantiate_dss__outParameter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__outParameter(struct soap *soap, dss__outParameter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 dss__outParameter * SOAP_FMAC4 soap_instantiate_dss__outParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__outParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__outParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new dss__outParameter;
		if (size)
			*size = sizeof(dss__outParameter);
	}
	else
	{	cp->ptr = (void*)new dss__outParameter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(dss__outParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dss__outParameter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__outParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dss__outParameter %p -> %p\n", q, p));
	*(dss__outParameter*)p = *(dss__outParameter*)q;
}

void dss__inParameter::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &this->dss__inParameter::values);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->dss__inParameter::names);
}

void dss__inParameter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->dss__inParameter::values);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->dss__inParameter::names);
}

int dss__inParameter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dss__inParameter);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int dss__inParameter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dss__inParameter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__inParameter(struct soap *soap, const char *tag, int id, const dss__inParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__inParameter), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "values", -1, &(a->dss__inParameter::values), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "names", -1, &(a->dss__inParameter::names), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dss__inParameter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dss__inParameter(soap, this, tag, type);
}

SOAP_FMAC3 dss__inParameter * SOAP_FMAC4 soap_get_dss__inParameter(struct soap *soap, dss__inParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__inParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *dss__inParameter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_dss__inParameter(soap, tag, this, type);
}

SOAP_FMAC3 dss__inParameter * SOAP_FMAC4 soap_in_dss__inParameter(struct soap *soap, const char *tag, dss__inParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dss__inParameter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__inParameter, sizeof(dss__inParameter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_dss__inParameter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (dss__inParameter *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "values", &(a->dss__inParameter::values), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "names", &(a->dss__inParameter::names), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (dss__inParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__inParameter, 0, sizeof(dss__inParameter), 0, soap_copy_dss__inParameter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 dss__inParameter * SOAP_FMAC6 soap_new_dss__inParameter(struct soap *soap, int n)
{	return soap_instantiate_dss__inParameter(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__inParameter(struct soap *soap, dss__inParameter *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 dss__inParameter * SOAP_FMAC4 soap_instantiate_dss__inParameter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__inParameter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__inParameter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new dss__inParameter;
		if (size)
			*size = sizeof(dss__inParameter);
	}
	else
	{	cp->ptr = (void*)new dss__inParameter[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(dss__inParameter);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dss__inParameter*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__inParameter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dss__inParameter %p -> %p\n", q, p));
	*(dss__inParameter*)p = *(dss__inParameter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_DeleteSchedule(struct soap *soap, struct dss__Event_DeleteSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_scheduleEventID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_DeleteSchedule(struct soap *soap, const struct dss__Event_DeleteSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_DeleteSchedule(struct soap *soap, const struct dss__Event_DeleteSchedule *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_DeleteSchedule);
	if (soap_out_dss__Event_DeleteSchedule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_DeleteSchedule(struct soap *soap, const char *tag, int id, const struct dss__Event_DeleteSchedule *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_DeleteSchedule), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "scheduleEventID", -1, &a->_scheduleEventID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_DeleteSchedule * SOAP_FMAC4 soap_get_dss__Event_DeleteSchedule(struct soap *soap, struct dss__Event_DeleteSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_DeleteSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_DeleteSchedule * SOAP_FMAC4 soap_in_dss__Event_DeleteSchedule(struct soap *soap, const char *tag, struct dss__Event_DeleteSchedule *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__scheduleEventID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_DeleteSchedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_DeleteSchedule, sizeof(struct dss__Event_DeleteSchedule), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_DeleteSchedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__scheduleEventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_scheduleEventID, "xsd:int"))
				{	soap_flag__scheduleEventID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_DeleteSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_DeleteSchedule, 0, sizeof(struct dss__Event_DeleteSchedule), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__scheduleEventID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_DeleteSchedule * SOAP_FMAC6 soap_new_dss__Event_DeleteSchedule(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_DeleteSchedule(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_DeleteSchedule(struct soap *soap, struct dss__Event_DeleteSchedule *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_DeleteSchedule * SOAP_FMAC4 soap_instantiate_dss__Event_DeleteSchedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_DeleteSchedule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_DeleteSchedule, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_DeleteSchedule;
		if (size)
			*size = sizeof(struct dss__Event_DeleteSchedule);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_DeleteSchedule[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_DeleteSchedule);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_DeleteSchedule*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_DeleteSchedule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_DeleteSchedule %p -> %p\n", q, p));
	*(struct dss__Event_DeleteSchedule*)p = *(struct dss__Event_DeleteSchedule*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_DeleteScheduleResponse(struct soap *soap, struct dss__Event_DeleteScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_DeleteScheduleResponse(struct soap *soap, const struct dss__Event_DeleteScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_DeleteScheduleResponse(struct soap *soap, const struct dss__Event_DeleteScheduleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_DeleteScheduleResponse);
	if (soap_out_dss__Event_DeleteScheduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_DeleteScheduleResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_DeleteScheduleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_DeleteScheduleResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC4 soap_get_dss__Event_DeleteScheduleResponse(struct soap *soap, struct dss__Event_DeleteScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_DeleteScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC4 soap_in_dss__Event_DeleteScheduleResponse(struct soap *soap, const char *tag, struct dss__Event_DeleteScheduleResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_DeleteScheduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_DeleteScheduleResponse, sizeof(struct dss__Event_DeleteScheduleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_DeleteScheduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_DeleteScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_DeleteScheduleResponse, 0, sizeof(struct dss__Event_DeleteScheduleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC6 soap_new_dss__Event_DeleteScheduleResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_DeleteScheduleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_DeleteScheduleResponse(struct soap *soap, struct dss__Event_DeleteScheduleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_DeleteScheduleResponse * SOAP_FMAC4 soap_instantiate_dss__Event_DeleteScheduleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_DeleteScheduleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_DeleteScheduleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_DeleteScheduleResponse;
		if (size)
			*size = sizeof(struct dss__Event_DeleteScheduleResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_DeleteScheduleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_DeleteScheduleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_DeleteScheduleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_DeleteScheduleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_DeleteScheduleResponse %p -> %p\n", q, p));
	*(struct dss__Event_DeleteScheduleResponse*)p = *(struct dss__Event_DeleteScheduleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Schedule(struct soap *soap, struct dss__Event_Schedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_icalString);
	soap_default_int(soap, &a->_eventID);
	a->_params.dss__inParameter::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Schedule(struct soap *soap, const struct dss__Event_Schedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_icalString);
	a->_params.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Schedule(struct soap *soap, const struct dss__Event_Schedule *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Schedule);
	if (soap_out_dss__Event_Schedule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Schedule(struct soap *soap, const char *tag, int id, const struct dss__Event_Schedule *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Schedule), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "icalString", -1, &a->_icalString, ""))
		return soap->error;
	if (soap_out_int(soap, "eventID", -1, &a->_eventID, ""))
		return soap->error;
	if (a->_params.soap_out(soap, "params", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Schedule * SOAP_FMAC4 soap_get_dss__Event_Schedule(struct soap *soap, struct dss__Event_Schedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Schedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Schedule * SOAP_FMAC4 soap_in_dss__Event_Schedule(struct soap *soap, const char *tag, struct dss__Event_Schedule *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__icalString = 1, soap_flag__eventID = 1, soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Schedule *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Schedule, sizeof(struct dss__Event_Schedule), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_Schedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__icalString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_icalString, "xsd:string"))
				{	soap_flag__icalString--;
					continue;
				}
			if (soap_flag__eventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_eventID, "xsd:int"))
				{	soap_flag__eventID--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (a->_params.soap_in(soap, NULL, "dss:inParameter"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Schedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Schedule, 0, sizeof(struct dss__Event_Schedule), 0, soap_copy_dss__Event_Schedule);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__eventID > 0 || soap_flag__params > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Schedule * SOAP_FMAC6 soap_new_dss__Event_Schedule(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Schedule(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Schedule(struct soap *soap, struct dss__Event_Schedule *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Schedule * SOAP_FMAC4 soap_instantiate_dss__Event_Schedule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Schedule(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Schedule, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Schedule;
		if (size)
			*size = sizeof(struct dss__Event_Schedule);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Schedule[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Schedule);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Schedule*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Schedule(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Schedule %p -> %p\n", q, p));
	*(struct dss__Event_Schedule*)p = *(struct dss__Event_Schedule*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_ScheduleResponse(struct soap *soap, struct dss__Event_ScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->scheduledEventID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_ScheduleResponse(struct soap *soap, const struct dss__Event_ScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_ScheduleResponse(struct soap *soap, const struct dss__Event_ScheduleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_ScheduleResponse);
	if (soap_out_dss__Event_ScheduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_ScheduleResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_ScheduleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_ScheduleResponse), type))
		return soap->error;
	if (soap_out_int(soap, "scheduledEventID", -1, &a->scheduledEventID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_ScheduleResponse * SOAP_FMAC4 soap_get_dss__Event_ScheduleResponse(struct soap *soap, struct dss__Event_ScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_ScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_ScheduleResponse * SOAP_FMAC4 soap_in_dss__Event_ScheduleResponse(struct soap *soap, const char *tag, struct dss__Event_ScheduleResponse *a, const char *type)
{
	short soap_flag_scheduledEventID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_ScheduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_ScheduleResponse, sizeof(struct dss__Event_ScheduleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_ScheduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_scheduledEventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "scheduledEventID", &a->scheduledEventID, "xsd:int"))
				{	soap_flag_scheduledEventID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_ScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_ScheduleResponse, 0, sizeof(struct dss__Event_ScheduleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_scheduledEventID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_ScheduleResponse * SOAP_FMAC6 soap_new_dss__Event_ScheduleResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_ScheduleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_ScheduleResponse(struct soap *soap, struct dss__Event_ScheduleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_ScheduleResponse * SOAP_FMAC4 soap_instantiate_dss__Event_ScheduleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_ScheduleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_ScheduleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_ScheduleResponse;
		if (size)
			*size = sizeof(struct dss__Event_ScheduleResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_ScheduleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_ScheduleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_ScheduleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_ScheduleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_ScheduleResponse %p -> %p\n", q, p));
	*(struct dss__Event_ScheduleResponse*)p = *(struct dss__Event_ScheduleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Unsubscribe(struct soap *soap, struct dss__Event_Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_subscriptionID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Unsubscribe(struct soap *soap, const struct dss__Event_Unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Unsubscribe(struct soap *soap, const struct dss__Event_Unsubscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Unsubscribe);
	if (soap_out_dss__Event_Unsubscribe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Unsubscribe(struct soap *soap, const char *tag, int id, const struct dss__Event_Unsubscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Unsubscribe), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "subscriptionID", -1, &a->_subscriptionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Unsubscribe * SOAP_FMAC4 soap_get_dss__Event_Unsubscribe(struct soap *soap, struct dss__Event_Unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Unsubscribe * SOAP_FMAC4 soap_in_dss__Event_Unsubscribe(struct soap *soap, const char *tag, struct dss__Event_Unsubscribe *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__subscriptionID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Unsubscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Unsubscribe, sizeof(struct dss__Event_Unsubscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_Unsubscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__subscriptionID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_subscriptionID, "xsd:int"))
				{	soap_flag__subscriptionID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Unsubscribe, 0, sizeof(struct dss__Event_Unsubscribe), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__subscriptionID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Unsubscribe * SOAP_FMAC6 soap_new_dss__Event_Unsubscribe(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Unsubscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Unsubscribe(struct soap *soap, struct dss__Event_Unsubscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Unsubscribe * SOAP_FMAC4 soap_instantiate_dss__Event_Unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Unsubscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Unsubscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Unsubscribe;
		if (size)
			*size = sizeof(struct dss__Event_Unsubscribe);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Unsubscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Unsubscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Unsubscribe*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Unsubscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Unsubscribe %p -> %p\n", q, p));
	*(struct dss__Event_Unsubscribe*)p = *(struct dss__Event_Unsubscribe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_UnsubscribeResponse(struct soap *soap, struct dss__Event_UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_UnsubscribeResponse(struct soap *soap, const struct dss__Event_UnsubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_UnsubscribeResponse(struct soap *soap, const struct dss__Event_UnsubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_UnsubscribeResponse);
	if (soap_out_dss__Event_UnsubscribeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_UnsubscribeResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_UnsubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_UnsubscribeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_UnsubscribeResponse * SOAP_FMAC4 soap_get_dss__Event_UnsubscribeResponse(struct soap *soap, struct dss__Event_UnsubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_UnsubscribeResponse * SOAP_FMAC4 soap_in_dss__Event_UnsubscribeResponse(struct soap *soap, const char *tag, struct dss__Event_UnsubscribeResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_UnsubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_UnsubscribeResponse, sizeof(struct dss__Event_UnsubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_UnsubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_UnsubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_UnsubscribeResponse, 0, sizeof(struct dss__Event_UnsubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_UnsubscribeResponse * SOAP_FMAC6 soap_new_dss__Event_UnsubscribeResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_UnsubscribeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_UnsubscribeResponse(struct soap *soap, struct dss__Event_UnsubscribeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_UnsubscribeResponse * SOAP_FMAC4 soap_instantiate_dss__Event_UnsubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_UnsubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_UnsubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_UnsubscribeResponse;
		if (size)
			*size = sizeof(struct dss__Event_UnsubscribeResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_UnsubscribeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_UnsubscribeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_UnsubscribeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_UnsubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_UnsubscribeResponse %p -> %p\n", q, p));
	*(struct dss__Event_UnsubscribeResponse*)p = *(struct dss__Event_UnsubscribeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Subscribe(struct soap *soap, struct dss__Event_Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__vectorTemplateOfint(soap, &a->_eventIDs);
	soap_default_std__vectorTemplateOfint(soap, &a->_sourceIDs);
	soap_default_string(soap, &a->_actionName);
	a->_params.dss__inParameter::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Subscribe(struct soap *soap, const struct dss__Event_Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->_eventIDs);
	soap_serialize_std__vectorTemplateOfint(soap, &a->_sourceIDs);
	soap_serialize_string(soap, &a->_actionName);
	a->_params.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Subscribe(struct soap *soap, const struct dss__Event_Subscribe *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Subscribe);
	if (soap_out_dss__Event_Subscribe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Subscribe(struct soap *soap, const char *tag, int id, const struct dss__Event_Subscribe *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Subscribe), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "eventIDs", -1, &a->_eventIDs, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "sourceIDs", -1, &a->_sourceIDs, ""))
		return soap->error;
	if (soap_out_string(soap, "actionName", -1, &a->_actionName, ""))
		return soap->error;
	if (a->_params.soap_out(soap, "params", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Subscribe * SOAP_FMAC4 soap_get_dss__Event_Subscribe(struct soap *soap, struct dss__Event_Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Subscribe * SOAP_FMAC4 soap_in_dss__Event_Subscribe(struct soap *soap, const char *tag, struct dss__Event_Subscribe *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__actionName = 1, soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Subscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Subscribe, sizeof(struct dss__Event_Subscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_Subscribe(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, NULL, &a->_eventIDs, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, NULL, &a->_sourceIDs, "xsd:int"))
					continue;
			if (soap_flag__actionName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_actionName, "xsd:string"))
				{	soap_flag__actionName--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (a->_params.soap_in(soap, NULL, "dss:inParameter"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Subscribe, 0, sizeof(struct dss__Event_Subscribe), 0, soap_copy_dss__Event_Subscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__params > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Subscribe * SOAP_FMAC6 soap_new_dss__Event_Subscribe(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Subscribe(struct soap *soap, struct dss__Event_Subscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Subscribe * SOAP_FMAC4 soap_instantiate_dss__Event_Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Subscribe;
		if (size)
			*size = sizeof(struct dss__Event_Subscribe);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Subscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Subscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Subscribe*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Subscribe %p -> %p\n", q, p));
	*(struct dss__Event_Subscribe*)p = *(struct dss__Event_Subscribe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_SubscribeResponse(struct soap *soap, struct dss__Event_SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->subscriptionID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_SubscribeResponse(struct soap *soap, const struct dss__Event_SubscribeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_SubscribeResponse(struct soap *soap, const struct dss__Event_SubscribeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_SubscribeResponse);
	if (soap_out_dss__Event_SubscribeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_SubscribeResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_SubscribeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_SubscribeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "subscriptionID", -1, &a->subscriptionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_SubscribeResponse * SOAP_FMAC4 soap_get_dss__Event_SubscribeResponse(struct soap *soap, struct dss__Event_SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_SubscribeResponse * SOAP_FMAC4 soap_in_dss__Event_SubscribeResponse(struct soap *soap, const char *tag, struct dss__Event_SubscribeResponse *a, const char *type)
{
	short soap_flag_subscriptionID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_SubscribeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_SubscribeResponse, sizeof(struct dss__Event_SubscribeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_SubscribeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_subscriptionID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "subscriptionID", &a->subscriptionID, "xsd:int"))
				{	soap_flag_subscriptionID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_SubscribeResponse, 0, sizeof(struct dss__Event_SubscribeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subscriptionID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_SubscribeResponse * SOAP_FMAC6 soap_new_dss__Event_SubscribeResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_SubscribeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_SubscribeResponse(struct soap *soap, struct dss__Event_SubscribeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_SubscribeResponse * SOAP_FMAC4 soap_instantiate_dss__Event_SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_SubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_SubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_SubscribeResponse;
		if (size)
			*size = sizeof(struct dss__Event_SubscribeResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_SubscribeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_SubscribeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_SubscribeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_SubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_SubscribeResponse %p -> %p\n", q, p));
	*(struct dss__Event_SubscribeResponse*)p = *(struct dss__Event_SubscribeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_GetActionParamsTemplate(struct soap *soap, struct dss__Event_GetActionParamsTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_GetActionParamsTemplate(struct soap *soap, const struct dss__Event_GetActionParamsTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_GetActionParamsTemplate(struct soap *soap, const struct dss__Event_GetActionParamsTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_GetActionParamsTemplate);
	if (soap_out_dss__Event_GetActionParamsTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_GetActionParamsTemplate(struct soap *soap, const char *tag, int id, const struct dss__Event_GetActionParamsTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_GetActionParamsTemplate), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC4 soap_get_dss__Event_GetActionParamsTemplate(struct soap *soap, struct dss__Event_GetActionParamsTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_GetActionParamsTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC4 soap_in_dss__Event_GetActionParamsTemplate(struct soap *soap, const char *tag, struct dss__Event_GetActionParamsTemplate *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_GetActionParamsTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_GetActionParamsTemplate, sizeof(struct dss__Event_GetActionParamsTemplate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_GetActionParamsTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_GetActionParamsTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_GetActionParamsTemplate, 0, sizeof(struct dss__Event_GetActionParamsTemplate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC6 soap_new_dss__Event_GetActionParamsTemplate(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_GetActionParamsTemplate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_GetActionParamsTemplate(struct soap *soap, struct dss__Event_GetActionParamsTemplate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_GetActionParamsTemplate * SOAP_FMAC4 soap_instantiate_dss__Event_GetActionParamsTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_GetActionParamsTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_GetActionParamsTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_GetActionParamsTemplate;
		if (size)
			*size = sizeof(struct dss__Event_GetActionParamsTemplate);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_GetActionParamsTemplate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_GetActionParamsTemplate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_GetActionParamsTemplate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_GetActionParamsTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_GetActionParamsTemplate %p -> %p\n", q, p));
	*(struct dss__Event_GetActionParamsTemplate*)p = *(struct dss__Event_GetActionParamsTemplate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_GetActionNames(struct soap *soap, struct dss__Event_GetActionNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_GetActionNames(struct soap *soap, const struct dss__Event_GetActionNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_GetActionNames(struct soap *soap, const struct dss__Event_GetActionNames *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_GetActionNames);
	if (soap_out_dss__Event_GetActionNames(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_GetActionNames(struct soap *soap, const char *tag, int id, const struct dss__Event_GetActionNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_GetActionNames), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_GetActionNames * SOAP_FMAC4 soap_get_dss__Event_GetActionNames(struct soap *soap, struct dss__Event_GetActionNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_GetActionNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_GetActionNames * SOAP_FMAC4 soap_in_dss__Event_GetActionNames(struct soap *soap, const char *tag, struct dss__Event_GetActionNames *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_GetActionNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_GetActionNames, sizeof(struct dss__Event_GetActionNames), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_GetActionNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_GetActionNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_GetActionNames, 0, sizeof(struct dss__Event_GetActionNames), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_GetActionNames * SOAP_FMAC6 soap_new_dss__Event_GetActionNames(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_GetActionNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_GetActionNames(struct soap *soap, struct dss__Event_GetActionNames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_GetActionNames * SOAP_FMAC4 soap_instantiate_dss__Event_GetActionNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_GetActionNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_GetActionNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_GetActionNames;
		if (size)
			*size = sizeof(struct dss__Event_GetActionNames);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_GetActionNames[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_GetActionNames);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_GetActionNames*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_GetActionNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_GetActionNames %p -> %p\n", q, p));
	*(struct dss__Event_GetActionNames*)p = *(struct dss__Event_GetActionNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_GetActionNamesResponse(struct soap *soap, struct dss__Event_GetActionNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->names);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_GetActionNamesResponse(struct soap *soap, const struct dss__Event_GetActionNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->names);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_GetActionNamesResponse(struct soap *soap, const struct dss__Event_GetActionNamesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_GetActionNamesResponse);
	if (soap_out_dss__Event_GetActionNamesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_GetActionNamesResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_GetActionNamesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_GetActionNamesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "names", -1, &a->names, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_GetActionNamesResponse * SOAP_FMAC4 soap_get_dss__Event_GetActionNamesResponse(struct soap *soap, struct dss__Event_GetActionNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_GetActionNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_GetActionNamesResponse * SOAP_FMAC4 soap_in_dss__Event_GetActionNamesResponse(struct soap *soap, const char *tag, struct dss__Event_GetActionNamesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_GetActionNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_GetActionNamesResponse, sizeof(struct dss__Event_GetActionNamesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_GetActionNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "names", &a->names, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_GetActionNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_GetActionNamesResponse, 0, sizeof(struct dss__Event_GetActionNamesResponse), 0, soap_copy_dss__Event_GetActionNamesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_GetActionNamesResponse * SOAP_FMAC6 soap_new_dss__Event_GetActionNamesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_GetActionNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_GetActionNamesResponse(struct soap *soap, struct dss__Event_GetActionNamesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_GetActionNamesResponse * SOAP_FMAC4 soap_instantiate_dss__Event_GetActionNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_GetActionNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_GetActionNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_GetActionNamesResponse;
		if (size)
			*size = sizeof(struct dss__Event_GetActionNamesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_GetActionNamesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_GetActionNamesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_GetActionNamesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_GetActionNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_GetActionNamesResponse %p -> %p\n", q, p));
	*(struct dss__Event_GetActionNamesResponse*)p = *(struct dss__Event_GetActionNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_Raise(struct soap *soap, struct dss__Event_Raise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_eventID);
	soap_default_int(soap, &a->_sourceID);
	a->_params.dss__inParameter::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_Raise(struct soap *soap, const struct dss__Event_Raise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_params.soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_Raise(struct soap *soap, const struct dss__Event_Raise *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_Raise);
	if (soap_out_dss__Event_Raise(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_Raise(struct soap *soap, const char *tag, int id, const struct dss__Event_Raise *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_Raise), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "eventID", -1, &a->_eventID, ""))
		return soap->error;
	if (soap_out_int(soap, "sourceID", -1, &a->_sourceID, ""))
		return soap->error;
	if (a->_params.soap_out(soap, "params", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_Raise * SOAP_FMAC4 soap_get_dss__Event_Raise(struct soap *soap, struct dss__Event_Raise *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_Raise(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_Raise * SOAP_FMAC4 soap_in_dss__Event_Raise(struct soap *soap, const char *tag, struct dss__Event_Raise *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__eventID = 1, soap_flag__sourceID = 1, soap_flag__params = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_Raise *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_Raise, sizeof(struct dss__Event_Raise), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Event_Raise(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__eventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_eventID, "xsd:int"))
				{	soap_flag__eventID--;
					continue;
				}
			if (soap_flag__sourceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sourceID, "xsd:int"))
				{	soap_flag__sourceID--;
					continue;
				}
			if (soap_flag__params && soap->error == SOAP_TAG_MISMATCH)
				if (a->_params.soap_in(soap, NULL, "dss:inParameter"))
				{	soap_flag__params--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_Raise *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_Raise, 0, sizeof(struct dss__Event_Raise), 0, soap_copy_dss__Event_Raise);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__eventID > 0 || soap_flag__sourceID > 0 || soap_flag__params > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_Raise * SOAP_FMAC6 soap_new_dss__Event_Raise(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_Raise(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_Raise(struct soap *soap, struct dss__Event_Raise *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_Raise * SOAP_FMAC4 soap_instantiate_dss__Event_Raise(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_Raise(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_Raise, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_Raise;
		if (size)
			*size = sizeof(struct dss__Event_Raise);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_Raise[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_Raise);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_Raise*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_Raise(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_Raise %p -> %p\n", q, p));
	*(struct dss__Event_Raise*)p = *(struct dss__Event_Raise*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Event_RaiseResponse(struct soap *soap, struct dss__Event_RaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Event_RaiseResponse(struct soap *soap, const struct dss__Event_RaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Event_RaiseResponse(struct soap *soap, const struct dss__Event_RaiseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Event_RaiseResponse);
	if (soap_out_dss__Event_RaiseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event_RaiseResponse(struct soap *soap, const char *tag, int id, const struct dss__Event_RaiseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event_RaiseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Event_RaiseResponse * SOAP_FMAC4 soap_get_dss__Event_RaiseResponse(struct soap *soap, struct dss__Event_RaiseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event_RaiseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Event_RaiseResponse * SOAP_FMAC4 soap_in_dss__Event_RaiseResponse(struct soap *soap, const char *tag, struct dss__Event_RaiseResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Event_RaiseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event_RaiseResponse, sizeof(struct dss__Event_RaiseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Event_RaiseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Event_RaiseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event_RaiseResponse, 0, sizeof(struct dss__Event_RaiseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Event_RaiseResponse * SOAP_FMAC6 soap_new_dss__Event_RaiseResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Event_RaiseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event_RaiseResponse(struct soap *soap, struct dss__Event_RaiseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Event_RaiseResponse * SOAP_FMAC4 soap_instantiate_dss__Event_RaiseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event_RaiseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event_RaiseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Event_RaiseResponse;
		if (size)
			*size = sizeof(struct dss__Event_RaiseResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Event_RaiseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Event_RaiseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Event_RaiseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event_RaiseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Event_RaiseResponse %p -> %p\n", q, p));
	*(struct dss__Event_RaiseResponse*)p = *(struct dss__Event_RaiseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Switch_SimulateKeypress(struct soap *soap, struct dss__Switch_SimulateKeypress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_int(soap, &a->_buttonNr);
	soap_default_string(soap, &a->_kind);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Switch_SimulateKeypress(struct soap *soap, const struct dss__Switch_SimulateKeypress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_kind);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Switch_SimulateKeypress(struct soap *soap, const struct dss__Switch_SimulateKeypress *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Switch_SimulateKeypress);
	if (soap_out_dss__Switch_SimulateKeypress(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Switch_SimulateKeypress(struct soap *soap, const char *tag, int id, const struct dss__Switch_SimulateKeypress *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Switch_SimulateKeypress), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "buttonNr", -1, &a->_buttonNr, ""))
		return soap->error;
	if (soap_out_string(soap, "kind", -1, &a->_kind, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Switch_SimulateKeypress * SOAP_FMAC4 soap_get_dss__Switch_SimulateKeypress(struct soap *soap, struct dss__Switch_SimulateKeypress *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Switch_SimulateKeypress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Switch_SimulateKeypress * SOAP_FMAC4 soap_in_dss__Switch_SimulateKeypress(struct soap *soap, const char *tag, struct dss__Switch_SimulateKeypress *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__buttonNr = 1, soap_flag__kind = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Switch_SimulateKeypress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Switch_SimulateKeypress, sizeof(struct dss__Switch_SimulateKeypress), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Switch_SimulateKeypress(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__buttonNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_buttonNr, "xsd:int"))
				{	soap_flag__buttonNr--;
					continue;
				}
			if (soap_flag__kind && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_kind, "xsd:string"))
				{	soap_flag__kind--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Switch_SimulateKeypress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Switch_SimulateKeypress, 0, sizeof(struct dss__Switch_SimulateKeypress), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__buttonNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Switch_SimulateKeypress * SOAP_FMAC6 soap_new_dss__Switch_SimulateKeypress(struct soap *soap, int n)
{	return soap_instantiate_dss__Switch_SimulateKeypress(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Switch_SimulateKeypress(struct soap *soap, struct dss__Switch_SimulateKeypress *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Switch_SimulateKeypress * SOAP_FMAC4 soap_instantiate_dss__Switch_SimulateKeypress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Switch_SimulateKeypress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Switch_SimulateKeypress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Switch_SimulateKeypress;
		if (size)
			*size = sizeof(struct dss__Switch_SimulateKeypress);
	}
	else
	{	cp->ptr = (void*)new struct dss__Switch_SimulateKeypress[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Switch_SimulateKeypress);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Switch_SimulateKeypress*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Switch_SimulateKeypress(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Switch_SimulateKeypress %p -> %p\n", q, p));
	*(struct dss__Switch_SimulateKeypress*)p = *(struct dss__Switch_SimulateKeypress*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Switch_SimulateKeypressResponse(struct soap *soap, struct dss__Switch_SimulateKeypressResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Switch_SimulateKeypressResponse(struct soap *soap, const struct dss__Switch_SimulateKeypressResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Switch_SimulateKeypressResponse(struct soap *soap, const struct dss__Switch_SimulateKeypressResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Switch_SimulateKeypressResponse);
	if (soap_out_dss__Switch_SimulateKeypressResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Switch_SimulateKeypressResponse(struct soap *soap, const char *tag, int id, const struct dss__Switch_SimulateKeypressResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Switch_SimulateKeypressResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Switch_SimulateKeypressResponse * SOAP_FMAC4 soap_get_dss__Switch_SimulateKeypressResponse(struct soap *soap, struct dss__Switch_SimulateKeypressResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Switch_SimulateKeypressResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Switch_SimulateKeypressResponse * SOAP_FMAC4 soap_in_dss__Switch_SimulateKeypressResponse(struct soap *soap, const char *tag, struct dss__Switch_SimulateKeypressResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Switch_SimulateKeypressResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Switch_SimulateKeypressResponse, sizeof(struct dss__Switch_SimulateKeypressResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Switch_SimulateKeypressResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Switch_SimulateKeypressResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Switch_SimulateKeypressResponse, 0, sizeof(struct dss__Switch_SimulateKeypressResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Switch_SimulateKeypressResponse * SOAP_FMAC6 soap_new_dss__Switch_SimulateKeypressResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Switch_SimulateKeypressResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Switch_SimulateKeypressResponse(struct soap *soap, struct dss__Switch_SimulateKeypressResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Switch_SimulateKeypressResponse * SOAP_FMAC4 soap_instantiate_dss__Switch_SimulateKeypressResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Switch_SimulateKeypressResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Switch_SimulateKeypressResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Switch_SimulateKeypressResponse;
		if (size)
			*size = sizeof(struct dss__Switch_SimulateKeypressResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Switch_SimulateKeypressResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Switch_SimulateKeypressResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Switch_SimulateKeypressResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Switch_SimulateKeypressResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Switch_SimulateKeypressResponse %p -> %p\n", q, p));
	*(struct dss__Switch_SimulateKeypressResponse*)p = *(struct dss__Switch_SimulateKeypressResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Switch_GetGroupID(struct soap *soap, struct dss__Switch_GetGroupID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Switch_GetGroupID(struct soap *soap, const struct dss__Switch_GetGroupID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Switch_GetGroupID(struct soap *soap, const struct dss__Switch_GetGroupID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Switch_GetGroupID);
	if (soap_out_dss__Switch_GetGroupID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Switch_GetGroupID(struct soap *soap, const char *tag, int id, const struct dss__Switch_GetGroupID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Switch_GetGroupID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Switch_GetGroupID * SOAP_FMAC4 soap_get_dss__Switch_GetGroupID(struct soap *soap, struct dss__Switch_GetGroupID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Switch_GetGroupID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Switch_GetGroupID * SOAP_FMAC4 soap_in_dss__Switch_GetGroupID(struct soap *soap, const char *tag, struct dss__Switch_GetGroupID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Switch_GetGroupID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Switch_GetGroupID, sizeof(struct dss__Switch_GetGroupID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Switch_GetGroupID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Switch_GetGroupID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Switch_GetGroupID, 0, sizeof(struct dss__Switch_GetGroupID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Switch_GetGroupID * SOAP_FMAC6 soap_new_dss__Switch_GetGroupID(struct soap *soap, int n)
{	return soap_instantiate_dss__Switch_GetGroupID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Switch_GetGroupID(struct soap *soap, struct dss__Switch_GetGroupID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Switch_GetGroupID * SOAP_FMAC4 soap_instantiate_dss__Switch_GetGroupID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Switch_GetGroupID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Switch_GetGroupID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Switch_GetGroupID;
		if (size)
			*size = sizeof(struct dss__Switch_GetGroupID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Switch_GetGroupID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Switch_GetGroupID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Switch_GetGroupID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Switch_GetGroupID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Switch_GetGroupID %p -> %p\n", q, p));
	*(struct dss__Switch_GetGroupID*)p = *(struct dss__Switch_GetGroupID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Switch_GetGroupIDResponse(struct soap *soap, struct dss__Switch_GetGroupIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Switch_GetGroupIDResponse(struct soap *soap, const struct dss__Switch_GetGroupIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Switch_GetGroupIDResponse(struct soap *soap, const struct dss__Switch_GetGroupIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Switch_GetGroupIDResponse);
	if (soap_out_dss__Switch_GetGroupIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Switch_GetGroupIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Switch_GetGroupIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Switch_GetGroupIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Switch_GetGroupIDResponse * SOAP_FMAC4 soap_get_dss__Switch_GetGroupIDResponse(struct soap *soap, struct dss__Switch_GetGroupIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Switch_GetGroupIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Switch_GetGroupIDResponse * SOAP_FMAC4 soap_in_dss__Switch_GetGroupIDResponse(struct soap *soap, const char *tag, struct dss__Switch_GetGroupIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Switch_GetGroupIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Switch_GetGroupIDResponse, sizeof(struct dss__Switch_GetGroupIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Switch_GetGroupIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Switch_GetGroupIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Switch_GetGroupIDResponse, 0, sizeof(struct dss__Switch_GetGroupIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Switch_GetGroupIDResponse * SOAP_FMAC6 soap_new_dss__Switch_GetGroupIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Switch_GetGroupIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Switch_GetGroupIDResponse(struct soap *soap, struct dss__Switch_GetGroupIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Switch_GetGroupIDResponse * SOAP_FMAC4 soap_instantiate_dss__Switch_GetGroupIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Switch_GetGroupIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Switch_GetGroupIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Switch_GetGroupIDResponse;
		if (size)
			*size = sizeof(struct dss__Switch_GetGroupIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Switch_GetGroupIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Switch_GetGroupIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Switch_GetGroupIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Switch_GetGroupIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Switch_GetGroupIDResponse %p -> %p\n", q, p));
	*(struct dss__Switch_GetGroupIDResponse*)p = *(struct dss__Switch_GetGroupIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetFunctionID(struct soap *soap, struct dss__Device_GetFunctionID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetFunctionID(struct soap *soap, const struct dss__Device_GetFunctionID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetFunctionID(struct soap *soap, const struct dss__Device_GetFunctionID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetFunctionID);
	if (soap_out_dss__Device_GetFunctionID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetFunctionID(struct soap *soap, const char *tag, int id, const struct dss__Device_GetFunctionID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetFunctionID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetFunctionID * SOAP_FMAC4 soap_get_dss__Device_GetFunctionID(struct soap *soap, struct dss__Device_GetFunctionID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetFunctionID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetFunctionID * SOAP_FMAC4 soap_in_dss__Device_GetFunctionID(struct soap *soap, const char *tag, struct dss__Device_GetFunctionID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetFunctionID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetFunctionID, sizeof(struct dss__Device_GetFunctionID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetFunctionID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetFunctionID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetFunctionID, 0, sizeof(struct dss__Device_GetFunctionID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetFunctionID * SOAP_FMAC6 soap_new_dss__Device_GetFunctionID(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetFunctionID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetFunctionID(struct soap *soap, struct dss__Device_GetFunctionID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetFunctionID * SOAP_FMAC4 soap_instantiate_dss__Device_GetFunctionID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetFunctionID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetFunctionID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetFunctionID;
		if (size)
			*size = sizeof(struct dss__Device_GetFunctionID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetFunctionID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetFunctionID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetFunctionID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetFunctionID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetFunctionID %p -> %p\n", q, p));
	*(struct dss__Device_GetFunctionID*)p = *(struct dss__Device_GetFunctionID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetFunctionIDResponse(struct soap *soap, struct dss__Device_GetFunctionIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetFunctionIDResponse(struct soap *soap, const struct dss__Device_GetFunctionIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetFunctionIDResponse(struct soap *soap, const struct dss__Device_GetFunctionIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetFunctionIDResponse);
	if (soap_out_dss__Device_GetFunctionIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetFunctionIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_GetFunctionIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetFunctionIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetFunctionIDResponse * SOAP_FMAC4 soap_get_dss__Device_GetFunctionIDResponse(struct soap *soap, struct dss__Device_GetFunctionIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetFunctionIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetFunctionIDResponse * SOAP_FMAC4 soap_in_dss__Device_GetFunctionIDResponse(struct soap *soap, const char *tag, struct dss__Device_GetFunctionIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetFunctionIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetFunctionIDResponse, sizeof(struct dss__Device_GetFunctionIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetFunctionIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetFunctionIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetFunctionIDResponse, 0, sizeof(struct dss__Device_GetFunctionIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetFunctionIDResponse * SOAP_FMAC6 soap_new_dss__Device_GetFunctionIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetFunctionIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetFunctionIDResponse(struct soap *soap, struct dss__Device_GetFunctionIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetFunctionIDResponse * SOAP_FMAC4 soap_instantiate_dss__Device_GetFunctionIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetFunctionIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetFunctionIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetFunctionIDResponse;
		if (size)
			*size = sizeof(struct dss__Device_GetFunctionIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetFunctionIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetFunctionIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetFunctionIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetFunctionIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetFunctionIDResponse %p -> %p\n", q, p));
	*(struct dss__Device_GetFunctionIDResponse*)p = *(struct dss__Device_GetFunctionIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveDevice(struct soap *soap, struct dss__Group_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveDevice(struct soap *soap, const struct dss__Group_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveDevice(struct soap *soap, const struct dss__Group_RemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveDevice);
	if (soap_out_dss__Group_RemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveDevice * SOAP_FMAC4 soap_get_dss__Group_RemoveDevice(struct soap *soap, struct dss__Group_RemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveDevice * SOAP_FMAC4 soap_in_dss__Group_RemoveDevice(struct soap *soap, const char *tag, struct dss__Group_RemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveDevice, sizeof(struct dss__Group_RemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveDevice, 0, sizeof(struct dss__Group_RemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveDevice * SOAP_FMAC6 soap_new_dss__Group_RemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveDevice(struct soap *soap, struct dss__Group_RemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveDevice * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveDevice;
		if (size)
			*size = sizeof(struct dss__Group_RemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveDevice %p -> %p\n", q, p));
	*(struct dss__Group_RemoveDevice*)p = *(struct dss__Group_RemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveDeviceResponse(struct soap *soap, struct dss__Group_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveDeviceResponse(struct soap *soap, const struct dss__Group_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveDeviceResponse(struct soap *soap, const struct dss__Group_RemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveDeviceResponse);
	if (soap_out_dss__Group_RemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__Group_RemoveDeviceResponse(struct soap *soap, struct dss__Group_RemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__Group_RemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__Group_RemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveDeviceResponse, sizeof(struct dss__Group_RemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveDeviceResponse, 0, sizeof(struct dss__Group_RemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__Group_RemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveDeviceResponse(struct soap *soap, struct dss__Group_RemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Group_RemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Group_RemoveDeviceResponse*)p = *(struct dss__Group_RemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_AddDevice(struct soap *soap, struct dss__Group_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_AddDevice(struct soap *soap, const struct dss__Group_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_AddDevice(struct soap *soap, const struct dss__Group_AddDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_AddDevice);
	if (soap_out_dss__Group_AddDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_AddDevice(struct soap *soap, const char *tag, int id, const struct dss__Group_AddDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_AddDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_AddDevice * SOAP_FMAC4 soap_get_dss__Group_AddDevice(struct soap *soap, struct dss__Group_AddDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_AddDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_AddDevice * SOAP_FMAC4 soap_in_dss__Group_AddDevice(struct soap *soap, const char *tag, struct dss__Group_AddDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_AddDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_AddDevice, sizeof(struct dss__Group_AddDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_AddDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_AddDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_AddDevice, 0, sizeof(struct dss__Group_AddDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_AddDevice * SOAP_FMAC6 soap_new_dss__Group_AddDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_AddDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_AddDevice(struct soap *soap, struct dss__Group_AddDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_AddDevice * SOAP_FMAC4 soap_instantiate_dss__Group_AddDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_AddDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_AddDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_AddDevice;
		if (size)
			*size = sizeof(struct dss__Group_AddDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_AddDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_AddDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_AddDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_AddDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_AddDevice %p -> %p\n", q, p));
	*(struct dss__Group_AddDevice*)p = *(struct dss__Group_AddDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_AddDeviceResponse(struct soap *soap, struct dss__Group_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_AddDeviceResponse(struct soap *soap, const struct dss__Group_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_AddDeviceResponse(struct soap *soap, const struct dss__Group_AddDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_AddDeviceResponse);
	if (soap_out_dss__Group_AddDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_AddDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_AddDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_AddDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_AddDeviceResponse * SOAP_FMAC4 soap_get_dss__Group_AddDeviceResponse(struct soap *soap, struct dss__Group_AddDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_AddDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_AddDeviceResponse * SOAP_FMAC4 soap_in_dss__Group_AddDeviceResponse(struct soap *soap, const char *tag, struct dss__Group_AddDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_AddDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_AddDeviceResponse, sizeof(struct dss__Group_AddDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_AddDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_AddDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_AddDeviceResponse, 0, sizeof(struct dss__Group_AddDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_AddDeviceResponse * SOAP_FMAC6 soap_new_dss__Group_AddDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_AddDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_AddDeviceResponse(struct soap *soap, struct dss__Group_AddDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_AddDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Group_AddDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_AddDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_AddDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_AddDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Group_AddDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_AddDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_AddDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_AddDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_AddDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_AddDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Group_AddDeviceResponse*)p = *(struct dss__Group_AddDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveUserGroup(struct soap *soap, struct dss__Group_RemoveUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveUserGroup(struct soap *soap, const struct dss__Group_RemoveUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveUserGroup(struct soap *soap, const struct dss__Group_RemoveUserGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveUserGroup);
	if (soap_out_dss__Group_RemoveUserGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveUserGroup(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveUserGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveUserGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroup * SOAP_FMAC4 soap_get_dss__Group_RemoveUserGroup(struct soap *soap, struct dss__Group_RemoveUserGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveUserGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroup * SOAP_FMAC4 soap_in_dss__Group_RemoveUserGroup(struct soap *soap, const char *tag, struct dss__Group_RemoveUserGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveUserGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveUserGroup, sizeof(struct dss__Group_RemoveUserGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveUserGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveUserGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveUserGroup, 0, sizeof(struct dss__Group_RemoveUserGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveUserGroup * SOAP_FMAC6 soap_new_dss__Group_RemoveUserGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveUserGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveUserGroup(struct soap *soap, struct dss__Group_RemoveUserGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroup * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveUserGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveUserGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveUserGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroup;
		if (size)
			*size = sizeof(struct dss__Group_RemoveUserGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveUserGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveUserGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveUserGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveUserGroup %p -> %p\n", q, p));
	*(struct dss__Group_RemoveUserGroup*)p = *(struct dss__Group_RemoveUserGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_RemoveUserGroupResponse(struct soap *soap, struct dss__Group_RemoveUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_RemoveUserGroupResponse(struct soap *soap, const struct dss__Group_RemoveUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_RemoveUserGroupResponse(struct soap *soap, const struct dss__Group_RemoveUserGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_RemoveUserGroupResponse);
	if (soap_out_dss__Group_RemoveUserGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_RemoveUserGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_RemoveUserGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_RemoveUserGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC4 soap_get_dss__Group_RemoveUserGroupResponse(struct soap *soap, struct dss__Group_RemoveUserGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_RemoveUserGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC4 soap_in_dss__Group_RemoveUserGroupResponse(struct soap *soap, const char *tag, struct dss__Group_RemoveUserGroupResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_RemoveUserGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_RemoveUserGroupResponse, sizeof(struct dss__Group_RemoveUserGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_RemoveUserGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_RemoveUserGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_RemoveUserGroupResponse, 0, sizeof(struct dss__Group_RemoveUserGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC6 soap_new_dss__Group_RemoveUserGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_RemoveUserGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_RemoveUserGroupResponse(struct soap *soap, struct dss__Group_RemoveUserGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_RemoveUserGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Group_RemoveUserGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_RemoveUserGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_RemoveUserGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroupResponse;
		if (size)
			*size = sizeof(struct dss__Group_RemoveUserGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_RemoveUserGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_RemoveUserGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_RemoveUserGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_RemoveUserGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_RemoveUserGroupResponse %p -> %p\n", q, p));
	*(struct dss__Group_RemoveUserGroupResponse*)p = *(struct dss__Group_RemoveUserGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateUserGroup(struct soap *soap, struct dss__Apartment_AllocateUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateUserGroup(struct soap *soap, const struct dss__Apartment_AllocateUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateUserGroup(struct soap *soap, const struct dss__Apartment_AllocateUserGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateUserGroup);
	if (soap_out_dss__Apartment_AllocateUserGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateUserGroup(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateUserGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC4 soap_get_dss__Apartment_AllocateUserGroup(struct soap *soap, struct dss__Apartment_AllocateUserGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateUserGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC4 soap_in_dss__Apartment_AllocateUserGroup(struct soap *soap, const char *tag, struct dss__Apartment_AllocateUserGroup *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateUserGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroup, sizeof(struct dss__Apartment_AllocateUserGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateUserGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateUserGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateUserGroup, 0, sizeof(struct dss__Apartment_AllocateUserGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC6 soap_new_dss__Apartment_AllocateUserGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateUserGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateUserGroup(struct soap *soap, struct dss__Apartment_AllocateUserGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroup * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateUserGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateUserGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateUserGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroup;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateUserGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateUserGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateUserGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateUserGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateUserGroup %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateUserGroup*)p = *(struct dss__Apartment_AllocateUserGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, struct dss__Apartment_AllocateUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const struct dss__Apartment_AllocateUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const struct dss__Apartment_AllocateUserGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse);
	if (soap_out_dss__Apartment_AllocateUserGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateUserGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC4 soap_get_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, struct dss__Apartment_AllocateUserGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateUserGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC4 soap_in_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, const char *tag, struct dss__Apartment_AllocateUserGroupResponse *a, const char *type)
{
	short soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateUserGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse, sizeof(struct dss__Apartment_AllocateUserGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateUserGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupID", &a->groupID, "xsd:int"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateUserGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse, 0, sizeof(struct dss__Apartment_AllocateUserGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC6 soap_new_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateUserGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, struct dss__Apartment_AllocateUserGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateUserGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateUserGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateUserGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroupResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateUserGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateUserGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateUserGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateUserGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateUserGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateUserGroupResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateUserGroupResponse*)p = *(struct dss__Apartment_AllocateUserGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_SetName(struct soap *soap, struct dss__Zone_SetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_SetName(struct soap *soap, const struct dss__Zone_SetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_SetName(struct soap *soap, const struct dss__Zone_SetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_SetName);
	if (soap_out_dss__Zone_SetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_SetName(struct soap *soap, const char *tag, int id, const struct dss__Zone_SetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_SetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_SetName * SOAP_FMAC4 soap_get_dss__Zone_SetName(struct soap *soap, struct dss__Zone_SetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_SetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_SetName * SOAP_FMAC4 soap_in_dss__Zone_SetName(struct soap *soap, const char *tag, struct dss__Zone_SetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_SetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_SetName, sizeof(struct dss__Zone_SetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_SetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_SetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_SetName, 0, sizeof(struct dss__Zone_SetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_SetName * SOAP_FMAC6 soap_new_dss__Zone_SetName(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_SetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_SetName(struct soap *soap, struct dss__Zone_SetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_SetName * SOAP_FMAC4 soap_instantiate_dss__Zone_SetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_SetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_SetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_SetName;
		if (size)
			*size = sizeof(struct dss__Zone_SetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_SetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_SetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_SetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_SetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_SetName %p -> %p\n", q, p));
	*(struct dss__Zone_SetName*)p = *(struct dss__Zone_SetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_SetNameResponse(struct soap *soap, struct dss__Zone_SetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_SetNameResponse(struct soap *soap, const struct dss__Zone_SetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_SetNameResponse(struct soap *soap, const struct dss__Zone_SetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_SetNameResponse);
	if (soap_out_dss__Zone_SetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_SetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Zone_SetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_SetNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_SetNameResponse * SOAP_FMAC4 soap_get_dss__Zone_SetNameResponse(struct soap *soap, struct dss__Zone_SetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_SetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_SetNameResponse * SOAP_FMAC4 soap_in_dss__Zone_SetNameResponse(struct soap *soap, const char *tag, struct dss__Zone_SetNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_SetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_SetNameResponse, sizeof(struct dss__Zone_SetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_SetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_SetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_SetNameResponse, 0, sizeof(struct dss__Zone_SetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_SetNameResponse * SOAP_FMAC6 soap_new_dss__Zone_SetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_SetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_SetNameResponse(struct soap *soap, struct dss__Zone_SetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_SetNameResponse * SOAP_FMAC4 soap_instantiate_dss__Zone_SetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_SetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_SetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_SetNameResponse;
		if (size)
			*size = sizeof(struct dss__Zone_SetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_SetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_SetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_SetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_SetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_SetNameResponse %p -> %p\n", q, p));
	*(struct dss__Zone_SetNameResponse*)p = *(struct dss__Zone_SetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_RemoveDevice(struct soap *soap, struct dss__Zone_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_RemoveDevice(struct soap *soap, const struct dss__Zone_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_RemoveDevice(struct soap *soap, const struct dss__Zone_RemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_RemoveDevice);
	if (soap_out_dss__Zone_RemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_RemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__Zone_RemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_RemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_RemoveDevice * SOAP_FMAC4 soap_get_dss__Zone_RemoveDevice(struct soap *soap, struct dss__Zone_RemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_RemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_RemoveDevice * SOAP_FMAC4 soap_in_dss__Zone_RemoveDevice(struct soap *soap, const char *tag, struct dss__Zone_RemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_RemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_RemoveDevice, sizeof(struct dss__Zone_RemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_RemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_RemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_RemoveDevice, 0, sizeof(struct dss__Zone_RemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_RemoveDevice * SOAP_FMAC6 soap_new_dss__Zone_RemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_RemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_RemoveDevice(struct soap *soap, struct dss__Zone_RemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_RemoveDevice * SOAP_FMAC4 soap_instantiate_dss__Zone_RemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_RemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_RemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDevice;
		if (size)
			*size = sizeof(struct dss__Zone_RemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_RemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_RemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_RemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_RemoveDevice %p -> %p\n", q, p));
	*(struct dss__Zone_RemoveDevice*)p = *(struct dss__Zone_RemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_RemoveDeviceResponse(struct soap *soap, struct dss__Zone_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_RemoveDeviceResponse(struct soap *soap, const struct dss__Zone_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_RemoveDeviceResponse(struct soap *soap, const struct dss__Zone_RemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_RemoveDeviceResponse);
	if (soap_out_dss__Zone_RemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_RemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Zone_RemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_RemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__Zone_RemoveDeviceResponse(struct soap *soap, struct dss__Zone_RemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_RemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__Zone_RemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__Zone_RemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_RemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_RemoveDeviceResponse, sizeof(struct dss__Zone_RemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_RemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_RemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_RemoveDeviceResponse, 0, sizeof(struct dss__Zone_RemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__Zone_RemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_RemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_RemoveDeviceResponse(struct soap *soap, struct dss__Zone_RemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Zone_RemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_RemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_RemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Zone_RemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_RemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_RemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_RemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_RemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Zone_RemoveDeviceResponse*)p = *(struct dss__Zone_RemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_AddDevice(struct soap *soap, struct dss__Zone_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_AddDevice(struct soap *soap, const struct dss__Zone_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_AddDevice(struct soap *soap, const struct dss__Zone_AddDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_AddDevice);
	if (soap_out_dss__Zone_AddDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_AddDevice(struct soap *soap, const char *tag, int id, const struct dss__Zone_AddDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_AddDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_AddDevice * SOAP_FMAC4 soap_get_dss__Zone_AddDevice(struct soap *soap, struct dss__Zone_AddDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_AddDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_AddDevice * SOAP_FMAC4 soap_in_dss__Zone_AddDevice(struct soap *soap, const char *tag, struct dss__Zone_AddDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_AddDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_AddDevice, sizeof(struct dss__Zone_AddDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_AddDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_AddDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_AddDevice, 0, sizeof(struct dss__Zone_AddDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_AddDevice * SOAP_FMAC6 soap_new_dss__Zone_AddDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_AddDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_AddDevice(struct soap *soap, struct dss__Zone_AddDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_AddDevice * SOAP_FMAC4 soap_instantiate_dss__Zone_AddDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_AddDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_AddDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_AddDevice;
		if (size)
			*size = sizeof(struct dss__Zone_AddDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_AddDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_AddDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_AddDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_AddDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_AddDevice %p -> %p\n", q, p));
	*(struct dss__Zone_AddDevice*)p = *(struct dss__Zone_AddDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_AddDeviceResponse(struct soap *soap, struct dss__Zone_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_AddDeviceResponse(struct soap *soap, const struct dss__Zone_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_AddDeviceResponse(struct soap *soap, const struct dss__Zone_AddDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_AddDeviceResponse);
	if (soap_out_dss__Zone_AddDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_AddDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Zone_AddDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_AddDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_AddDeviceResponse * SOAP_FMAC4 soap_get_dss__Zone_AddDeviceResponse(struct soap *soap, struct dss__Zone_AddDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_AddDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_AddDeviceResponse * SOAP_FMAC4 soap_in_dss__Zone_AddDeviceResponse(struct soap *soap, const char *tag, struct dss__Zone_AddDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_AddDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_AddDeviceResponse, sizeof(struct dss__Zone_AddDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_AddDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_AddDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_AddDeviceResponse, 0, sizeof(struct dss__Zone_AddDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_AddDeviceResponse * SOAP_FMAC6 soap_new_dss__Zone_AddDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_AddDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_AddDeviceResponse(struct soap *soap, struct dss__Zone_AddDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_AddDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Zone_AddDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_AddDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_AddDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_AddDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Zone_AddDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_AddDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_AddDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_AddDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_AddDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_AddDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Zone_AddDeviceResponse*)p = *(struct dss__Zone_AddDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_DeleteZone(struct soap *soap, struct dss__Apartment_DeleteZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_DeleteZone(struct soap *soap, const struct dss__Apartment_DeleteZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_DeleteZone(struct soap *soap, const struct dss__Apartment_DeleteZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_DeleteZone);
	if (soap_out_dss__Apartment_DeleteZone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_DeleteZone(struct soap *soap, const char *tag, int id, const struct dss__Apartment_DeleteZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_DeleteZone), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_DeleteZone * SOAP_FMAC4 soap_get_dss__Apartment_DeleteZone(struct soap *soap, struct dss__Apartment_DeleteZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_DeleteZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_DeleteZone * SOAP_FMAC4 soap_in_dss__Apartment_DeleteZone(struct soap *soap, const char *tag, struct dss__Apartment_DeleteZone *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_DeleteZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_DeleteZone, sizeof(struct dss__Apartment_DeleteZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_DeleteZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_DeleteZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_DeleteZone, 0, sizeof(struct dss__Apartment_DeleteZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_DeleteZone * SOAP_FMAC6 soap_new_dss__Apartment_DeleteZone(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_DeleteZone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_DeleteZone(struct soap *soap, struct dss__Apartment_DeleteZone *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_DeleteZone * SOAP_FMAC4 soap_instantiate_dss__Apartment_DeleteZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_DeleteZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_DeleteZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteZone;
		if (size)
			*size = sizeof(struct dss__Apartment_DeleteZone);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteZone[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_DeleteZone);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_DeleteZone*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_DeleteZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_DeleteZone %p -> %p\n", q, p));
	*(struct dss__Apartment_DeleteZone*)p = *(struct dss__Apartment_DeleteZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_DeleteZoneResponse(struct soap *soap, struct dss__Apartment_DeleteZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_DeleteZoneResponse(struct soap *soap, const struct dss__Apartment_DeleteZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_DeleteZoneResponse(struct soap *soap, const struct dss__Apartment_DeleteZoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_DeleteZoneResponse);
	if (soap_out_dss__Apartment_DeleteZoneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_DeleteZoneResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_DeleteZoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_DeleteZoneResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_DeleteZoneResponse * SOAP_FMAC4 soap_get_dss__Apartment_DeleteZoneResponse(struct soap *soap, struct dss__Apartment_DeleteZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_DeleteZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_DeleteZoneResponse * SOAP_FMAC4 soap_in_dss__Apartment_DeleteZoneResponse(struct soap *soap, const char *tag, struct dss__Apartment_DeleteZoneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_DeleteZoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_DeleteZoneResponse, sizeof(struct dss__Apartment_DeleteZoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_DeleteZoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_DeleteZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_DeleteZoneResponse, 0, sizeof(struct dss__Apartment_DeleteZoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_DeleteZoneResponse * SOAP_FMAC6 soap_new_dss__Apartment_DeleteZoneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_DeleteZoneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_DeleteZoneResponse(struct soap *soap, struct dss__Apartment_DeleteZoneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_DeleteZoneResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_DeleteZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_DeleteZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_DeleteZoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteZoneResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_DeleteZoneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_DeleteZoneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_DeleteZoneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_DeleteZoneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_DeleteZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_DeleteZoneResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_DeleteZoneResponse*)p = *(struct dss__Apartment_DeleteZoneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateZone(struct soap *soap, struct dss__Apartment_AllocateZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateZone(struct soap *soap, const struct dss__Apartment_AllocateZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateZone(struct soap *soap, const struct dss__Apartment_AllocateZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateZone);
	if (soap_out_dss__Apartment_AllocateZone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateZone(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateZone), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateZone * SOAP_FMAC4 soap_get_dss__Apartment_AllocateZone(struct soap *soap, struct dss__Apartment_AllocateZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateZone * SOAP_FMAC4 soap_in_dss__Apartment_AllocateZone(struct soap *soap, const char *tag, struct dss__Apartment_AllocateZone *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateZone, sizeof(struct dss__Apartment_AllocateZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateZone, 0, sizeof(struct dss__Apartment_AllocateZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateZone * SOAP_FMAC6 soap_new_dss__Apartment_AllocateZone(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateZone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateZone(struct soap *soap, struct dss__Apartment_AllocateZone *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateZone * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateZone;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateZone);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateZone[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateZone);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateZone*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateZone %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateZone*)p = *(struct dss__Apartment_AllocateZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_AllocateZoneResponse(struct soap *soap, struct dss__Apartment_AllocateZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_AllocateZoneResponse(struct soap *soap, const struct dss__Apartment_AllocateZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_AllocateZoneResponse(struct soap *soap, const struct dss__Apartment_AllocateZoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_AllocateZoneResponse);
	if (soap_out_dss__Apartment_AllocateZoneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_AllocateZoneResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_AllocateZoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_AllocateZoneResponse), type))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_AllocateZoneResponse * SOAP_FMAC4 soap_get_dss__Apartment_AllocateZoneResponse(struct soap *soap, struct dss__Apartment_AllocateZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_AllocateZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_AllocateZoneResponse * SOAP_FMAC4 soap_in_dss__Apartment_AllocateZoneResponse(struct soap *soap, const char *tag, struct dss__Apartment_AllocateZoneResponse *a, const char *type)
{
	short soap_flag_zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_AllocateZoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_AllocateZoneResponse, sizeof(struct dss__Apartment_AllocateZoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_AllocateZoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zoneID", &a->zoneID, "xsd:int"))
				{	soap_flag_zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_AllocateZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_AllocateZoneResponse, 0, sizeof(struct dss__Apartment_AllocateZoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_AllocateZoneResponse * SOAP_FMAC6 soap_new_dss__Apartment_AllocateZoneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_AllocateZoneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_AllocateZoneResponse(struct soap *soap, struct dss__Apartment_AllocateZoneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_AllocateZoneResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_AllocateZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_AllocateZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_AllocateZoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateZoneResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_AllocateZoneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_AllocateZoneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_AllocateZoneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_AllocateZoneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_AllocateZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_AllocateZoneResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_AllocateZoneResponse*)p = *(struct dss__Apartment_AllocateZoneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetName(struct soap *soap, struct dss__Modulator_GetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_modulatorID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetName(struct soap *soap, const struct dss__Modulator_GetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetName(struct soap *soap, const struct dss__Modulator_GetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetName);
	if (soap_out_dss__Modulator_GetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetName(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "modulatorID", -1, &a->_modulatorID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetName * SOAP_FMAC4 soap_get_dss__Modulator_GetName(struct soap *soap, struct dss__Modulator_GetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetName * SOAP_FMAC4 soap_in_dss__Modulator_GetName(struct soap *soap, const char *tag, struct dss__Modulator_GetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__modulatorID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetName, sizeof(struct dss__Modulator_GetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__modulatorID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_modulatorID, "xsd:int"))
				{	soap_flag__modulatorID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetName, 0, sizeof(struct dss__Modulator_GetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__modulatorID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetName * SOAP_FMAC6 soap_new_dss__Modulator_GetName(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetName(struct soap *soap, struct dss__Modulator_GetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetName * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetName;
		if (size)
			*size = sizeof(struct dss__Modulator_GetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetName %p -> %p\n", q, p));
	*(struct dss__Modulator_GetName*)p = *(struct dss__Modulator_GetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetNameResponse(struct soap *soap, struct dss__Modulator_GetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetNameResponse(struct soap *soap, const struct dss__Modulator_GetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetNameResponse(struct soap *soap, const struct dss__Modulator_GetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetNameResponse);
	if (soap_out_dss__Modulator_GetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetNameResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetNameResponse * SOAP_FMAC4 soap_get_dss__Modulator_GetNameResponse(struct soap *soap, struct dss__Modulator_GetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetNameResponse * SOAP_FMAC4 soap_in_dss__Modulator_GetNameResponse(struct soap *soap, const char *tag, struct dss__Modulator_GetNameResponse *a, const char *type)
{
	short soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetNameResponse, sizeof(struct dss__Modulator_GetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetNameResponse, 0, sizeof(struct dss__Modulator_GetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetNameResponse * SOAP_FMAC6 soap_new_dss__Modulator_GetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetNameResponse(struct soap *soap, struct dss__Modulator_GetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetNameResponse * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetNameResponse;
		if (size)
			*size = sizeof(struct dss__Modulator_GetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetNameResponse %p -> %p\n", q, p));
	*(struct dss__Modulator_GetNameResponse*)p = *(struct dss__Modulator_GetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetDSID(struct soap *soap, struct dss__Modulator_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_modulatorID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetDSID(struct soap *soap, const struct dss__Modulator_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetDSID(struct soap *soap, const struct dss__Modulator_GetDSID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetDSID);
	if (soap_out_dss__Modulator_GetDSID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetDSID(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetDSID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetDSID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "modulatorID", -1, &a->_modulatorID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetDSID * SOAP_FMAC4 soap_get_dss__Modulator_GetDSID(struct soap *soap, struct dss__Modulator_GetDSID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetDSID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetDSID * SOAP_FMAC4 soap_in_dss__Modulator_GetDSID(struct soap *soap, const char *tag, struct dss__Modulator_GetDSID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__modulatorID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetDSID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetDSID, sizeof(struct dss__Modulator_GetDSID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetDSID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__modulatorID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_modulatorID, "xsd:int"))
				{	soap_flag__modulatorID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetDSID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetDSID, 0, sizeof(struct dss__Modulator_GetDSID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__modulatorID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetDSID * SOAP_FMAC6 soap_new_dss__Modulator_GetDSID(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetDSID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetDSID(struct soap *soap, struct dss__Modulator_GetDSID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetDSID * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetDSID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetDSID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetDSID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSID;
		if (size)
			*size = sizeof(struct dss__Modulator_GetDSID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetDSID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetDSID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetDSID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetDSID %p -> %p\n", q, p));
	*(struct dss__Modulator_GetDSID*)p = *(struct dss__Modulator_GetDSID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetDSIDResponse(struct soap *soap, struct dss__Modulator_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__unsignedInt(soap, &a->dsid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetDSIDResponse(struct soap *soap, const struct dss__Modulator_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetDSIDResponse(struct soap *soap, const struct dss__Modulator_GetDSIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetDSIDResponse);
	if (soap_out_dss__Modulator_GetDSIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetDSIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetDSIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetDSIDResponse), type))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "dsid", -1, &a->dsid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC4 soap_get_dss__Modulator_GetDSIDResponse(struct soap *soap, struct dss__Modulator_GetDSIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetDSIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC4 soap_in_dss__Modulator_GetDSIDResponse(struct soap *soap, const char *tag, struct dss__Modulator_GetDSIDResponse *a, const char *type)
{
	short soap_flag_dsid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetDSIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetDSIDResponse, sizeof(struct dss__Modulator_GetDSIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetDSIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dsid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, "dsid", &a->dsid, "xsd:unsignedInt"))
				{	soap_flag_dsid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetDSIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetDSIDResponse, 0, sizeof(struct dss__Modulator_GetDSIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dsid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC6 soap_new_dss__Modulator_GetDSIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetDSIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetDSIDResponse(struct soap *soap, struct dss__Modulator_GetDSIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetDSIDResponse * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetDSIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetDSIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetDSIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSIDResponse;
		if (size)
			*size = sizeof(struct dss__Modulator_GetDSIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetDSIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetDSIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetDSIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetDSIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetDSIDResponse %p -> %p\n", q, p));
	*(struct dss__Modulator_GetDSIDResponse*)p = *(struct dss__Modulator_GetDSIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetModulatorIDs(struct soap *soap, struct dss__Apartment_GetModulatorIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetModulatorIDs(struct soap *soap, const struct dss__Apartment_GetModulatorIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetModulatorIDs(struct soap *soap, const struct dss__Apartment_GetModulatorIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetModulatorIDs);
	if (soap_out_dss__Apartment_GetModulatorIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetModulatorIDs(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetModulatorIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC4 soap_get_dss__Apartment_GetModulatorIDs(struct soap *soap, struct dss__Apartment_GetModulatorIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetModulatorIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC4 soap_in_dss__Apartment_GetModulatorIDs(struct soap *soap, const char *tag, struct dss__Apartment_GetModulatorIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetModulatorIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDs, sizeof(struct dss__Apartment_GetModulatorIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetModulatorIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetModulatorIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetModulatorIDs, 0, sizeof(struct dss__Apartment_GetModulatorIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC6 soap_new_dss__Apartment_GetModulatorIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetModulatorIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetModulatorIDs(struct soap *soap, struct dss__Apartment_GetModulatorIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDs * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetModulatorIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetModulatorIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetModulatorIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDs;
		if (size)
			*size = sizeof(struct dss__Apartment_GetModulatorIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetModulatorIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetModulatorIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetModulatorIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetModulatorIDs %p -> %p\n", q, p));
	*(struct dss__Apartment_GetModulatorIDs*)p = *(struct dss__Apartment_GetModulatorIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, struct dss__Apartment_GetModulatorIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfint(soap, &a->ids);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const struct dss__Apartment_GetModulatorIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const struct dss__Apartment_GetModulatorIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse);
	if (soap_out_dss__Apartment_GetModulatorIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetModulatorIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, struct dss__Apartment_GetModulatorIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetModulatorIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetModulatorIDsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetModulatorIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse, sizeof(struct dss__Apartment_GetModulatorIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetModulatorIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "ids", &a->ids, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetModulatorIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse, 0, sizeof(struct dss__Apartment_GetModulatorIDsResponse), 0, soap_copy_dss__Apartment_GetModulatorIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetModulatorIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, struct dss__Apartment_GetModulatorIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetModulatorIDsResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetModulatorIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetModulatorIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDsResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetModulatorIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetModulatorIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetModulatorIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetModulatorIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetModulatorIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetModulatorIDsResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetModulatorIDsResponse*)p = *(struct dss__Apartment_GetModulatorIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetPowerConsumption(struct soap *soap, struct dss__Modulator_GetPowerConsumption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_modulatorID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetPowerConsumption(struct soap *soap, const struct dss__Modulator_GetPowerConsumption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetPowerConsumption(struct soap *soap, const struct dss__Modulator_GetPowerConsumption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetPowerConsumption);
	if (soap_out_dss__Modulator_GetPowerConsumption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetPowerConsumption(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetPowerConsumption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetPowerConsumption), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "modulatorID", -1, &a->_modulatorID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetPowerConsumption * SOAP_FMAC4 soap_get_dss__Modulator_GetPowerConsumption(struct soap *soap, struct dss__Modulator_GetPowerConsumption *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetPowerConsumption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetPowerConsumption * SOAP_FMAC4 soap_in_dss__Modulator_GetPowerConsumption(struct soap *soap, const char *tag, struct dss__Modulator_GetPowerConsumption *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__modulatorID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetPowerConsumption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetPowerConsumption, sizeof(struct dss__Modulator_GetPowerConsumption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetPowerConsumption(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__modulatorID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_modulatorID, "xsd:int"))
				{	soap_flag__modulatorID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetPowerConsumption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetPowerConsumption, 0, sizeof(struct dss__Modulator_GetPowerConsumption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__modulatorID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetPowerConsumption * SOAP_FMAC6 soap_new_dss__Modulator_GetPowerConsumption(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetPowerConsumption(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetPowerConsumption(struct soap *soap, struct dss__Modulator_GetPowerConsumption *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetPowerConsumption * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetPowerConsumption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetPowerConsumption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetPowerConsumption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetPowerConsumption;
		if (size)
			*size = sizeof(struct dss__Modulator_GetPowerConsumption);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetPowerConsumption[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetPowerConsumption);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetPowerConsumption*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetPowerConsumption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetPowerConsumption %p -> %p\n", q, p));
	*(struct dss__Modulator_GetPowerConsumption*)p = *(struct dss__Modulator_GetPowerConsumption*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, struct dss__Modulator_GetPowerConsumptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__unsignedInt(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, const struct dss__Modulator_GetPowerConsumptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, const struct dss__Modulator_GetPowerConsumptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse);
	if (soap_out_dss__Modulator_GetPowerConsumptionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, const char *tag, int id, const struct dss__Modulator_GetPowerConsumptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse), type))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Modulator_GetPowerConsumptionResponse * SOAP_FMAC4 soap_get_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, struct dss__Modulator_GetPowerConsumptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Modulator_GetPowerConsumptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Modulator_GetPowerConsumptionResponse * SOAP_FMAC4 soap_in_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, const char *tag, struct dss__Modulator_GetPowerConsumptionResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Modulator_GetPowerConsumptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse, sizeof(struct dss__Modulator_GetPowerConsumptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Modulator_GetPowerConsumptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, "result", &a->result, "xsd:unsignedInt"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Modulator_GetPowerConsumptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse, 0, sizeof(struct dss__Modulator_GetPowerConsumptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Modulator_GetPowerConsumptionResponse * SOAP_FMAC6 soap_new_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Modulator_GetPowerConsumptionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, struct dss__Modulator_GetPowerConsumptionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Modulator_GetPowerConsumptionResponse * SOAP_FMAC4 soap_instantiate_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Modulator_GetPowerConsumptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Modulator_GetPowerConsumptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Modulator_GetPowerConsumptionResponse;
		if (size)
			*size = sizeof(struct dss__Modulator_GetPowerConsumptionResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Modulator_GetPowerConsumptionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Modulator_GetPowerConsumptionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Modulator_GetPowerConsumptionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Modulator_GetPowerConsumptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Modulator_GetPowerConsumptionResponse %p -> %p\n", q, p));
	*(struct dss__Modulator_GetPowerConsumptionResponse*)p = *(struct dss__Modulator_GetPowerConsumptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetDSID(struct soap *soap, struct dss__Device_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetDSID(struct soap *soap, const struct dss__Device_GetDSID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetDSID(struct soap *soap, const struct dss__Device_GetDSID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetDSID);
	if (soap_out_dss__Device_GetDSID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetDSID(struct soap *soap, const char *tag, int id, const struct dss__Device_GetDSID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetDSID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetDSID * SOAP_FMAC4 soap_get_dss__Device_GetDSID(struct soap *soap, struct dss__Device_GetDSID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetDSID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetDSID * SOAP_FMAC4 soap_in_dss__Device_GetDSID(struct soap *soap, const char *tag, struct dss__Device_GetDSID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetDSID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetDSID, sizeof(struct dss__Device_GetDSID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetDSID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetDSID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetDSID, 0, sizeof(struct dss__Device_GetDSID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetDSID * SOAP_FMAC6 soap_new_dss__Device_GetDSID(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetDSID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetDSID(struct soap *soap, struct dss__Device_GetDSID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetDSID * SOAP_FMAC4 soap_instantiate_dss__Device_GetDSID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetDSID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetDSID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetDSID;
		if (size)
			*size = sizeof(struct dss__Device_GetDSID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetDSID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetDSID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetDSID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetDSID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetDSID %p -> %p\n", q, p));
	*(struct dss__Device_GetDSID*)p = *(struct dss__Device_GetDSID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetDSIDResponse(struct soap *soap, struct dss__Device_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__unsignedInt(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetDSIDResponse(struct soap *soap, const struct dss__Device_GetDSIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetDSIDResponse(struct soap *soap, const struct dss__Device_GetDSIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetDSIDResponse);
	if (soap_out_dss__Device_GetDSIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetDSIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_GetDSIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetDSIDResponse), type))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetDSIDResponse * SOAP_FMAC4 soap_get_dss__Device_GetDSIDResponse(struct soap *soap, struct dss__Device_GetDSIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetDSIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetDSIDResponse * SOAP_FMAC4 soap_in_dss__Device_GetDSIDResponse(struct soap *soap, const char *tag, struct dss__Device_GetDSIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetDSIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetDSIDResponse, sizeof(struct dss__Device_GetDSIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetDSIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, "result", &a->result, "xsd:unsignedInt"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetDSIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetDSIDResponse, 0, sizeof(struct dss__Device_GetDSIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetDSIDResponse * SOAP_FMAC6 soap_new_dss__Device_GetDSIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetDSIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetDSIDResponse(struct soap *soap, struct dss__Device_GetDSIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetDSIDResponse * SOAP_FMAC4 soap_instantiate_dss__Device_GetDSIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetDSIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetDSIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetDSIDResponse;
		if (size)
			*size = sizeof(struct dss__Device_GetDSIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetDSIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetDSIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetDSIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetDSIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetDSIDResponse %p -> %p\n", q, p));
	*(struct dss__Device_GetDSIDResponse*)p = *(struct dss__Device_GetDSIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetZoneID(struct soap *soap, struct dss__Device_GetZoneID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetZoneID(struct soap *soap, const struct dss__Device_GetZoneID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetZoneID(struct soap *soap, const struct dss__Device_GetZoneID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetZoneID);
	if (soap_out_dss__Device_GetZoneID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetZoneID(struct soap *soap, const char *tag, int id, const struct dss__Device_GetZoneID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetZoneID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetZoneID * SOAP_FMAC4 soap_get_dss__Device_GetZoneID(struct soap *soap, struct dss__Device_GetZoneID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetZoneID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetZoneID * SOAP_FMAC4 soap_in_dss__Device_GetZoneID(struct soap *soap, const char *tag, struct dss__Device_GetZoneID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetZoneID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetZoneID, sizeof(struct dss__Device_GetZoneID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetZoneID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetZoneID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetZoneID, 0, sizeof(struct dss__Device_GetZoneID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetZoneID * SOAP_FMAC6 soap_new_dss__Device_GetZoneID(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetZoneID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetZoneID(struct soap *soap, struct dss__Device_GetZoneID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetZoneID * SOAP_FMAC4 soap_instantiate_dss__Device_GetZoneID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetZoneID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetZoneID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetZoneID;
		if (size)
			*size = sizeof(struct dss__Device_GetZoneID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetZoneID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetZoneID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetZoneID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetZoneID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetZoneID %p -> %p\n", q, p));
	*(struct dss__Device_GetZoneID*)p = *(struct dss__Device_GetZoneID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetZoneIDResponse(struct soap *soap, struct dss__Device_GetZoneIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetZoneIDResponse(struct soap *soap, const struct dss__Device_GetZoneIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetZoneIDResponse(struct soap *soap, const struct dss__Device_GetZoneIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetZoneIDResponse);
	if (soap_out_dss__Device_GetZoneIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetZoneIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_GetZoneIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetZoneIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetZoneIDResponse * SOAP_FMAC4 soap_get_dss__Device_GetZoneIDResponse(struct soap *soap, struct dss__Device_GetZoneIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetZoneIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetZoneIDResponse * SOAP_FMAC4 soap_in_dss__Device_GetZoneIDResponse(struct soap *soap, const char *tag, struct dss__Device_GetZoneIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetZoneIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetZoneIDResponse, sizeof(struct dss__Device_GetZoneIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetZoneIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetZoneIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetZoneIDResponse, 0, sizeof(struct dss__Device_GetZoneIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetZoneIDResponse * SOAP_FMAC6 soap_new_dss__Device_GetZoneIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetZoneIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetZoneIDResponse(struct soap *soap, struct dss__Device_GetZoneIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetZoneIDResponse * SOAP_FMAC4 soap_instantiate_dss__Device_GetZoneIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetZoneIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetZoneIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetZoneIDResponse;
		if (size)
			*size = sizeof(struct dss__Device_GetZoneIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetZoneIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetZoneIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetZoneIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetZoneIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetZoneIDResponse %p -> %p\n", q, p));
	*(struct dss__Device_GetZoneIDResponse*)p = *(struct dss__Device_GetZoneIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetName(struct soap *soap, struct dss__Device_GetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetName(struct soap *soap, const struct dss__Device_GetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetName(struct soap *soap, const struct dss__Device_GetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetName);
	if (soap_out_dss__Device_GetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetName(struct soap *soap, const char *tag, int id, const struct dss__Device_GetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetName * SOAP_FMAC4 soap_get_dss__Device_GetName(struct soap *soap, struct dss__Device_GetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetName * SOAP_FMAC4 soap_in_dss__Device_GetName(struct soap *soap, const char *tag, struct dss__Device_GetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetName, sizeof(struct dss__Device_GetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetName, 0, sizeof(struct dss__Device_GetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetName * SOAP_FMAC6 soap_new_dss__Device_GetName(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetName(struct soap *soap, struct dss__Device_GetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetName * SOAP_FMAC4 soap_instantiate_dss__Device_GetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetName;
		if (size)
			*size = sizeof(struct dss__Device_GetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetName %p -> %p\n", q, p));
	*(struct dss__Device_GetName*)p = *(struct dss__Device_GetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetNameResponse(struct soap *soap, struct dss__Device_GetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetNameResponse(struct soap *soap, const struct dss__Device_GetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetNameResponse(struct soap *soap, const struct dss__Device_GetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetNameResponse);
	if (soap_out_dss__Device_GetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_GetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetNameResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetNameResponse * SOAP_FMAC4 soap_get_dss__Device_GetNameResponse(struct soap *soap, struct dss__Device_GetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetNameResponse * SOAP_FMAC4 soap_in_dss__Device_GetNameResponse(struct soap *soap, const char *tag, struct dss__Device_GetNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetNameResponse, sizeof(struct dss__Device_GetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetNameResponse, 0, sizeof(struct dss__Device_GetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetNameResponse * SOAP_FMAC6 soap_new_dss__Device_GetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetNameResponse(struct soap *soap, struct dss__Device_GetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetNameResponse * SOAP_FMAC4 soap_instantiate_dss__Device_GetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetNameResponse;
		if (size)
			*size = sizeof(struct dss__Device_GetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetNameResponse %p -> %p\n", q, p));
	*(struct dss__Device_GetNameResponse*)p = *(struct dss__Device_GetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_SaveScene(struct soap *soap, struct dss__Device_SaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_SaveScene(struct soap *soap, const struct dss__Device_SaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_SaveScene(struct soap *soap, const struct dss__Device_SaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_SaveScene);
	if (soap_out_dss__Device_SaveScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_SaveScene(struct soap *soap, const char *tag, int id, const struct dss__Device_SaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_SaveScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_SaveScene * SOAP_FMAC4 soap_get_dss__Device_SaveScene(struct soap *soap, struct dss__Device_SaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_SaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_SaveScene * SOAP_FMAC4 soap_in_dss__Device_SaveScene(struct soap *soap, const char *tag, struct dss__Device_SaveScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_SaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_SaveScene, sizeof(struct dss__Device_SaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_SaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_SaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_SaveScene, 0, sizeof(struct dss__Device_SaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_SaveScene * SOAP_FMAC6 soap_new_dss__Device_SaveScene(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_SaveScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_SaveScene(struct soap *soap, struct dss__Device_SaveScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_SaveScene * SOAP_FMAC4 soap_instantiate_dss__Device_SaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_SaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_SaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_SaveScene;
		if (size)
			*size = sizeof(struct dss__Device_SaveScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_SaveScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_SaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_SaveScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_SaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_SaveScene %p -> %p\n", q, p));
	*(struct dss__Device_SaveScene*)p = *(struct dss__Device_SaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_SaveSceneResponse(struct soap *soap, struct dss__Device_SaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_SaveSceneResponse(struct soap *soap, const struct dss__Device_SaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_SaveSceneResponse(struct soap *soap, const struct dss__Device_SaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_SaveSceneResponse);
	if (soap_out_dss__Device_SaveSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_SaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_SaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_SaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_SaveSceneResponse * SOAP_FMAC4 soap_get_dss__Device_SaveSceneResponse(struct soap *soap, struct dss__Device_SaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_SaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_SaveSceneResponse * SOAP_FMAC4 soap_in_dss__Device_SaveSceneResponse(struct soap *soap, const char *tag, struct dss__Device_SaveSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_SaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_SaveSceneResponse, sizeof(struct dss__Device_SaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_SaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_SaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_SaveSceneResponse, 0, sizeof(struct dss__Device_SaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_SaveSceneResponse * SOAP_FMAC6 soap_new_dss__Device_SaveSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_SaveSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_SaveSceneResponse(struct soap *soap, struct dss__Device_SaveSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_SaveSceneResponse * SOAP_FMAC4 soap_instantiate_dss__Device_SaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_SaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_SaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_SaveSceneResponse;
		if (size)
			*size = sizeof(struct dss__Device_SaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_SaveSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_SaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_SaveSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_SaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_SaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__Device_SaveSceneResponse*)p = *(struct dss__Device_SaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_CallScene(struct soap *soap, struct dss__Device_CallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_CallScene(struct soap *soap, const struct dss__Device_CallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_CallScene(struct soap *soap, const struct dss__Device_CallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_CallScene);
	if (soap_out_dss__Device_CallScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_CallScene(struct soap *soap, const char *tag, int id, const struct dss__Device_CallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_CallScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_CallScene * SOAP_FMAC4 soap_get_dss__Device_CallScene(struct soap *soap, struct dss__Device_CallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_CallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_CallScene * SOAP_FMAC4 soap_in_dss__Device_CallScene(struct soap *soap, const char *tag, struct dss__Device_CallScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_CallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_CallScene, sizeof(struct dss__Device_CallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_CallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_CallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_CallScene, 0, sizeof(struct dss__Device_CallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_CallScene * SOAP_FMAC6 soap_new_dss__Device_CallScene(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_CallScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_CallScene(struct soap *soap, struct dss__Device_CallScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_CallScene * SOAP_FMAC4 soap_instantiate_dss__Device_CallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_CallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_CallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_CallScene;
		if (size)
			*size = sizeof(struct dss__Device_CallScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_CallScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_CallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_CallScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_CallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_CallScene %p -> %p\n", q, p));
	*(struct dss__Device_CallScene*)p = *(struct dss__Device_CallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_CallSceneResponse(struct soap *soap, struct dss__Device_CallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_CallSceneResponse(struct soap *soap, const struct dss__Device_CallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_CallSceneResponse(struct soap *soap, const struct dss__Device_CallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_CallSceneResponse);
	if (soap_out_dss__Device_CallSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_CallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_CallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_CallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_CallSceneResponse * SOAP_FMAC4 soap_get_dss__Device_CallSceneResponse(struct soap *soap, struct dss__Device_CallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_CallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_CallSceneResponse * SOAP_FMAC4 soap_in_dss__Device_CallSceneResponse(struct soap *soap, const char *tag, struct dss__Device_CallSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_CallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_CallSceneResponse, sizeof(struct dss__Device_CallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_CallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_CallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_CallSceneResponse, 0, sizeof(struct dss__Device_CallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_CallSceneResponse * SOAP_FMAC6 soap_new_dss__Device_CallSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_CallSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_CallSceneResponse(struct soap *soap, struct dss__Device_CallSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_CallSceneResponse * SOAP_FMAC4 soap_instantiate_dss__Device_CallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_CallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_CallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_CallSceneResponse;
		if (size)
			*size = sizeof(struct dss__Device_CallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_CallSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_CallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_CallSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_CallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_CallSceneResponse %p -> %p\n", q, p));
	*(struct dss__Device_CallSceneResponse*)p = *(struct dss__Device_CallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetValue(struct soap *soap, struct dss__Device_GetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetValue(struct soap *soap, const struct dss__Device_GetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetValue(struct soap *soap, const struct dss__Device_GetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetValue);
	if (soap_out_dss__Device_GetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetValue(struct soap *soap, const char *tag, int id, const struct dss__Device_GetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetValue * SOAP_FMAC4 soap_get_dss__Device_GetValue(struct soap *soap, struct dss__Device_GetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetValue * SOAP_FMAC4 soap_in_dss__Device_GetValue(struct soap *soap, const char *tag, struct dss__Device_GetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetValue, sizeof(struct dss__Device_GetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetValue, 0, sizeof(struct dss__Device_GetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetValue * SOAP_FMAC6 soap_new_dss__Device_GetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetValue(struct soap *soap, struct dss__Device_GetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetValue * SOAP_FMAC4 soap_instantiate_dss__Device_GetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetValue;
		if (size)
			*size = sizeof(struct dss__Device_GetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetValue %p -> %p\n", q, p));
	*(struct dss__Device_GetValue*)p = *(struct dss__Device_GetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_GetValueResponse(struct soap *soap, struct dss__Device_GetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_GetValueResponse(struct soap *soap, const struct dss__Device_GetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_GetValueResponse(struct soap *soap, const struct dss__Device_GetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_GetValueResponse);
	if (soap_out_dss__Device_GetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_GetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_GetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_GetValueResponse), type))
		return soap->error;
	if (soap_out_double(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_GetValueResponse * SOAP_FMAC4 soap_get_dss__Device_GetValueResponse(struct soap *soap, struct dss__Device_GetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_GetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_GetValueResponse * SOAP_FMAC4 soap_in_dss__Device_GetValueResponse(struct soap *soap, const char *tag, struct dss__Device_GetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_GetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_GetValueResponse, sizeof(struct dss__Device_GetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_GetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "result", &a->result, "xsd:double"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_GetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_GetValueResponse, 0, sizeof(struct dss__Device_GetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_GetValueResponse * SOAP_FMAC6 soap_new_dss__Device_GetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_GetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_GetValueResponse(struct soap *soap, struct dss__Device_GetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_GetValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_GetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_GetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_GetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_GetValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_GetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_GetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_GetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_GetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_GetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_GetValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_GetValueResponse*)p = *(struct dss__Device_GetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_SetValue(struct soap *soap, struct dss__Device_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_SetValue(struct soap *soap, const struct dss__Device_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_SetValue(struct soap *soap, const struct dss__Device_SetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_SetValue);
	if (soap_out_dss__Device_SetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_SetValue(struct soap *soap, const char *tag, int id, const struct dss__Device_SetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_SetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_SetValue * SOAP_FMAC4 soap_get_dss__Device_SetValue(struct soap *soap, struct dss__Device_SetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_SetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_SetValue * SOAP_FMAC4 soap_in_dss__Device_SetValue(struct soap *soap, const char *tag, struct dss__Device_SetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_SetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_SetValue, sizeof(struct dss__Device_SetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_SetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_SetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_SetValue, 0, sizeof(struct dss__Device_SetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_SetValue * SOAP_FMAC6 soap_new_dss__Device_SetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_SetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_SetValue(struct soap *soap, struct dss__Device_SetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_SetValue * SOAP_FMAC4 soap_instantiate_dss__Device_SetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_SetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_SetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_SetValue;
		if (size)
			*size = sizeof(struct dss__Device_SetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_SetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_SetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_SetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_SetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_SetValue %p -> %p\n", q, p));
	*(struct dss__Device_SetValue*)p = *(struct dss__Device_SetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_SetValueResponse(struct soap *soap, struct dss__Device_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_SetValueResponse(struct soap *soap, const struct dss__Device_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_SetValueResponse(struct soap *soap, const struct dss__Device_SetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_SetValueResponse);
	if (soap_out_dss__Device_SetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_SetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_SetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_SetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_SetValueResponse * SOAP_FMAC4 soap_get_dss__Device_SetValueResponse(struct soap *soap, struct dss__Device_SetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_SetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_SetValueResponse * SOAP_FMAC4 soap_in_dss__Device_SetValueResponse(struct soap *soap, const char *tag, struct dss__Device_SetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_SetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_SetValueResponse, sizeof(struct dss__Device_SetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_SetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_SetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_SetValueResponse, 0, sizeof(struct dss__Device_SetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_SetValueResponse * SOAP_FMAC6 soap_new_dss__Device_SetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_SetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_SetValueResponse(struct soap *soap, struct dss__Device_SetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_SetValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_SetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_SetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_SetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_SetValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_SetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_SetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_SetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_SetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_SetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_SetValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_SetValueResponse*)p = *(struct dss__Device_SetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_EndDim(struct soap *soap, struct dss__Device_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_EndDim(struct soap *soap, const struct dss__Device_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_EndDim(struct soap *soap, const struct dss__Device_EndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_EndDim);
	if (soap_out_dss__Device_EndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_EndDim(struct soap *soap, const char *tag, int id, const struct dss__Device_EndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_EndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_EndDim * SOAP_FMAC4 soap_get_dss__Device_EndDim(struct soap *soap, struct dss__Device_EndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_EndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_EndDim * SOAP_FMAC4 soap_in_dss__Device_EndDim(struct soap *soap, const char *tag, struct dss__Device_EndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_EndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_EndDim, sizeof(struct dss__Device_EndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_EndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_EndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_EndDim, 0, sizeof(struct dss__Device_EndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_EndDim * SOAP_FMAC6 soap_new_dss__Device_EndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_EndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_EndDim(struct soap *soap, struct dss__Device_EndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_EndDim * SOAP_FMAC4 soap_instantiate_dss__Device_EndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_EndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_EndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_EndDim;
		if (size)
			*size = sizeof(struct dss__Device_EndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_EndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_EndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_EndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_EndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_EndDim %p -> %p\n", q, p));
	*(struct dss__Device_EndDim*)p = *(struct dss__Device_EndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_EndDimResponse(struct soap *soap, struct dss__Device_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_EndDimResponse(struct soap *soap, const struct dss__Device_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_EndDimResponse(struct soap *soap, const struct dss__Device_EndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_EndDimResponse);
	if (soap_out_dss__Device_EndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_EndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_EndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_EndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_EndDimResponse * SOAP_FMAC4 soap_get_dss__Device_EndDimResponse(struct soap *soap, struct dss__Device_EndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_EndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_EndDimResponse * SOAP_FMAC4 soap_in_dss__Device_EndDimResponse(struct soap *soap, const char *tag, struct dss__Device_EndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_EndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_EndDimResponse, sizeof(struct dss__Device_EndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_EndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_EndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_EndDimResponse, 0, sizeof(struct dss__Device_EndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_EndDimResponse * SOAP_FMAC6 soap_new_dss__Device_EndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_EndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_EndDimResponse(struct soap *soap, struct dss__Device_EndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_EndDimResponse * SOAP_FMAC4 soap_instantiate_dss__Device_EndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_EndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_EndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_EndDimResponse;
		if (size)
			*size = sizeof(struct dss__Device_EndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_EndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_EndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_EndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_EndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_EndDimResponse %p -> %p\n", q, p));
	*(struct dss__Device_EndDimResponse*)p = *(struct dss__Device_EndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_StartDim(struct soap *soap, struct dss__Device_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_StartDim(struct soap *soap, const struct dss__Device_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_StartDim(struct soap *soap, const struct dss__Device_StartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_StartDim);
	if (soap_out_dss__Device_StartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_StartDim(struct soap *soap, const char *tag, int id, const struct dss__Device_StartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_StartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_StartDim * SOAP_FMAC4 soap_get_dss__Device_StartDim(struct soap *soap, struct dss__Device_StartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_StartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_StartDim * SOAP_FMAC4 soap_in_dss__Device_StartDim(struct soap *soap, const char *tag, struct dss__Device_StartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_StartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_StartDim, sizeof(struct dss__Device_StartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_StartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_StartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_StartDim, 0, sizeof(struct dss__Device_StartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_StartDim * SOAP_FMAC6 soap_new_dss__Device_StartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_StartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_StartDim(struct soap *soap, struct dss__Device_StartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_StartDim * SOAP_FMAC4 soap_instantiate_dss__Device_StartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_StartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_StartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_StartDim;
		if (size)
			*size = sizeof(struct dss__Device_StartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_StartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_StartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_StartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_StartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_StartDim %p -> %p\n", q, p));
	*(struct dss__Device_StartDim*)p = *(struct dss__Device_StartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_StartDimResponse(struct soap *soap, struct dss__Device_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_StartDimResponse(struct soap *soap, const struct dss__Device_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_StartDimResponse(struct soap *soap, const struct dss__Device_StartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_StartDimResponse);
	if (soap_out_dss__Device_StartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_StartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_StartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_StartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_StartDimResponse * SOAP_FMAC4 soap_get_dss__Device_StartDimResponse(struct soap *soap, struct dss__Device_StartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_StartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_StartDimResponse * SOAP_FMAC4 soap_in_dss__Device_StartDimResponse(struct soap *soap, const char *tag, struct dss__Device_StartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_StartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_StartDimResponse, sizeof(struct dss__Device_StartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_StartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_StartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_StartDimResponse, 0, sizeof(struct dss__Device_StartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_StartDimResponse * SOAP_FMAC6 soap_new_dss__Device_StartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_StartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_StartDimResponse(struct soap *soap, struct dss__Device_StartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_StartDimResponse * SOAP_FMAC4 soap_instantiate_dss__Device_StartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_StartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_StartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_StartDimResponse;
		if (size)
			*size = sizeof(struct dss__Device_StartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_StartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_StartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_StartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_StartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_StartDimResponse %p -> %p\n", q, p));
	*(struct dss__Device_StartDimResponse*)p = *(struct dss__Device_StartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_Disable(struct soap *soap, struct dss__Device_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_Disable(struct soap *soap, const struct dss__Device_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_Disable(struct soap *soap, const struct dss__Device_Disable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_Disable);
	if (soap_out_dss__Device_Disable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_Disable(struct soap *soap, const char *tag, int id, const struct dss__Device_Disable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_Disable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_Disable * SOAP_FMAC4 soap_get_dss__Device_Disable(struct soap *soap, struct dss__Device_Disable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_Disable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_Disable * SOAP_FMAC4 soap_in_dss__Device_Disable(struct soap *soap, const char *tag, struct dss__Device_Disable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_Disable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_Disable, sizeof(struct dss__Device_Disable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_Disable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_Disable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_Disable, 0, sizeof(struct dss__Device_Disable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_Disable * SOAP_FMAC6 soap_new_dss__Device_Disable(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_Disable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_Disable(struct soap *soap, struct dss__Device_Disable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_Disable * SOAP_FMAC4 soap_instantiate_dss__Device_Disable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_Disable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_Disable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_Disable;
		if (size)
			*size = sizeof(struct dss__Device_Disable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_Disable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_Disable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_Disable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_Disable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_Disable %p -> %p\n", q, p));
	*(struct dss__Device_Disable*)p = *(struct dss__Device_Disable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_DisableResponse(struct soap *soap, struct dss__Device_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_DisableResponse(struct soap *soap, const struct dss__Device_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_DisableResponse(struct soap *soap, const struct dss__Device_DisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_DisableResponse);
	if (soap_out_dss__Device_DisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_DisableResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_DisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_DisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_DisableResponse * SOAP_FMAC4 soap_get_dss__Device_DisableResponse(struct soap *soap, struct dss__Device_DisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_DisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_DisableResponse * SOAP_FMAC4 soap_in_dss__Device_DisableResponse(struct soap *soap, const char *tag, struct dss__Device_DisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_DisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_DisableResponse, sizeof(struct dss__Device_DisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_DisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_DisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_DisableResponse, 0, sizeof(struct dss__Device_DisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_DisableResponse * SOAP_FMAC6 soap_new_dss__Device_DisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_DisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_DisableResponse(struct soap *soap, struct dss__Device_DisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_DisableResponse * SOAP_FMAC4 soap_instantiate_dss__Device_DisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_DisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_DisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_DisableResponse;
		if (size)
			*size = sizeof(struct dss__Device_DisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_DisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_DisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_DisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_DisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_DisableResponse %p -> %p\n", q, p));
	*(struct dss__Device_DisableResponse*)p = *(struct dss__Device_DisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_Enable(struct soap *soap, struct dss__Device_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_Enable(struct soap *soap, const struct dss__Device_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_Enable(struct soap *soap, const struct dss__Device_Enable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_Enable);
	if (soap_out_dss__Device_Enable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_Enable(struct soap *soap, const char *tag, int id, const struct dss__Device_Enable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_Enable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_Enable * SOAP_FMAC4 soap_get_dss__Device_Enable(struct soap *soap, struct dss__Device_Enable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_Enable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_Enable * SOAP_FMAC4 soap_in_dss__Device_Enable(struct soap *soap, const char *tag, struct dss__Device_Enable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_Enable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_Enable, sizeof(struct dss__Device_Enable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_Enable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_Enable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_Enable, 0, sizeof(struct dss__Device_Enable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_Enable * SOAP_FMAC6 soap_new_dss__Device_Enable(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_Enable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_Enable(struct soap *soap, struct dss__Device_Enable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_Enable * SOAP_FMAC4 soap_instantiate_dss__Device_Enable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_Enable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_Enable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_Enable;
		if (size)
			*size = sizeof(struct dss__Device_Enable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_Enable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_Enable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_Enable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_Enable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_Enable %p -> %p\n", q, p));
	*(struct dss__Device_Enable*)p = *(struct dss__Device_Enable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_EnableResponse(struct soap *soap, struct dss__Device_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_EnableResponse(struct soap *soap, const struct dss__Device_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_EnableResponse(struct soap *soap, const struct dss__Device_EnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_EnableResponse);
	if (soap_out_dss__Device_EnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_EnableResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_EnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_EnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_EnableResponse * SOAP_FMAC4 soap_get_dss__Device_EnableResponse(struct soap *soap, struct dss__Device_EnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_EnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_EnableResponse * SOAP_FMAC4 soap_in_dss__Device_EnableResponse(struct soap *soap, const char *tag, struct dss__Device_EnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_EnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_EnableResponse, sizeof(struct dss__Device_EnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_EnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_EnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_EnableResponse, 0, sizeof(struct dss__Device_EnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_EnableResponse * SOAP_FMAC6 soap_new_dss__Device_EnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_EnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_EnableResponse(struct soap *soap, struct dss__Device_EnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_EnableResponse * SOAP_FMAC4 soap_instantiate_dss__Device_EnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_EnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_EnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_EnableResponse;
		if (size)
			*size = sizeof(struct dss__Device_EnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_EnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_EnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_EnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_EnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_EnableResponse %p -> %p\n", q, p));
	*(struct dss__Device_EnableResponse*)p = *(struct dss__Device_EnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_DecreaseValue(struct soap *soap, struct dss__Device_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_DecreaseValue(struct soap *soap, const struct dss__Device_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_DecreaseValue(struct soap *soap, const struct dss__Device_DecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_DecreaseValue);
	if (soap_out_dss__Device_DecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_DecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Device_DecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_DecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_DecreaseValue * SOAP_FMAC4 soap_get_dss__Device_DecreaseValue(struct soap *soap, struct dss__Device_DecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_DecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_DecreaseValue * SOAP_FMAC4 soap_in_dss__Device_DecreaseValue(struct soap *soap, const char *tag, struct dss__Device_DecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_DecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_DecreaseValue, sizeof(struct dss__Device_DecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_DecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_DecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_DecreaseValue, 0, sizeof(struct dss__Device_DecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_DecreaseValue * SOAP_FMAC6 soap_new_dss__Device_DecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_DecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_DecreaseValue(struct soap *soap, struct dss__Device_DecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_DecreaseValue * SOAP_FMAC4 soap_instantiate_dss__Device_DecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_DecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_DecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValue;
		if (size)
			*size = sizeof(struct dss__Device_DecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_DecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_DecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_DecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_DecreaseValue %p -> %p\n", q, p));
	*(struct dss__Device_DecreaseValue*)p = *(struct dss__Device_DecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_DecreaseValueResponse(struct soap *soap, struct dss__Device_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_DecreaseValueResponse(struct soap *soap, const struct dss__Device_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_DecreaseValueResponse(struct soap *soap, const struct dss__Device_DecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_DecreaseValueResponse);
	if (soap_out_dss__Device_DecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_DecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_DecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_DecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_DecreaseValueResponse * SOAP_FMAC4 soap_get_dss__Device_DecreaseValueResponse(struct soap *soap, struct dss__Device_DecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_DecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_DecreaseValueResponse * SOAP_FMAC4 soap_in_dss__Device_DecreaseValueResponse(struct soap *soap, const char *tag, struct dss__Device_DecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_DecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_DecreaseValueResponse, sizeof(struct dss__Device_DecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_DecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_DecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_DecreaseValueResponse, 0, sizeof(struct dss__Device_DecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_DecreaseValueResponse * SOAP_FMAC6 soap_new_dss__Device_DecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_DecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_DecreaseValueResponse(struct soap *soap, struct dss__Device_DecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_DecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_DecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_DecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_DecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_DecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_DecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_DecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_DecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_DecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_DecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_DecreaseValueResponse*)p = *(struct dss__Device_DecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_IncreaseValue(struct soap *soap, struct dss__Device_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_IncreaseValue(struct soap *soap, const struct dss__Device_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_IncreaseValue(struct soap *soap, const struct dss__Device_IncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_IncreaseValue);
	if (soap_out_dss__Device_IncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_IncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Device_IncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_IncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_IncreaseValue * SOAP_FMAC4 soap_get_dss__Device_IncreaseValue(struct soap *soap, struct dss__Device_IncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_IncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_IncreaseValue * SOAP_FMAC4 soap_in_dss__Device_IncreaseValue(struct soap *soap, const char *tag, struct dss__Device_IncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_IncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_IncreaseValue, sizeof(struct dss__Device_IncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_IncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_IncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_IncreaseValue, 0, sizeof(struct dss__Device_IncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_IncreaseValue * SOAP_FMAC6 soap_new_dss__Device_IncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_IncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_IncreaseValue(struct soap *soap, struct dss__Device_IncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_IncreaseValue * SOAP_FMAC4 soap_instantiate_dss__Device_IncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_IncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_IncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValue;
		if (size)
			*size = sizeof(struct dss__Device_IncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_IncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_IncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_IncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_IncreaseValue %p -> %p\n", q, p));
	*(struct dss__Device_IncreaseValue*)p = *(struct dss__Device_IncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_IncreaseValueResponse(struct soap *soap, struct dss__Device_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_IncreaseValueResponse(struct soap *soap, const struct dss__Device_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_IncreaseValueResponse(struct soap *soap, const struct dss__Device_IncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_IncreaseValueResponse);
	if (soap_out_dss__Device_IncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_IncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_IncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_IncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_IncreaseValueResponse * SOAP_FMAC4 soap_get_dss__Device_IncreaseValueResponse(struct soap *soap, struct dss__Device_IncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_IncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_IncreaseValueResponse * SOAP_FMAC4 soap_in_dss__Device_IncreaseValueResponse(struct soap *soap, const char *tag, struct dss__Device_IncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_IncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_IncreaseValueResponse, sizeof(struct dss__Device_IncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_IncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_IncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_IncreaseValueResponse, 0, sizeof(struct dss__Device_IncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_IncreaseValueResponse * SOAP_FMAC6 soap_new_dss__Device_IncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_IncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_IncreaseValueResponse(struct soap *soap, struct dss__Device_IncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_IncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Device_IncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_IncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_IncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Device_IncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_IncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_IncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_IncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_IncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_IncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Device_IncreaseValueResponse*)p = *(struct dss__Device_IncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOff(struct soap *soap, struct dss__Device_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOff(struct soap *soap, const struct dss__Device_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOff(struct soap *soap, const struct dss__Device_TurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOff);
	if (soap_out_dss__Device_TurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOff(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOff * SOAP_FMAC4 soap_get_dss__Device_TurnOff(struct soap *soap, struct dss__Device_TurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOff * SOAP_FMAC4 soap_in_dss__Device_TurnOff(struct soap *soap, const char *tag, struct dss__Device_TurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOff, sizeof(struct dss__Device_TurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOff, 0, sizeof(struct dss__Device_TurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOff * SOAP_FMAC6 soap_new_dss__Device_TurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOff(struct soap *soap, struct dss__Device_TurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOff * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOff;
		if (size)
			*size = sizeof(struct dss__Device_TurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOff %p -> %p\n", q, p));
	*(struct dss__Device_TurnOff*)p = *(struct dss__Device_TurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOffResponse(struct soap *soap, struct dss__Device_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOffResponse(struct soap *soap, const struct dss__Device_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOffResponse(struct soap *soap, const struct dss__Device_TurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOffResponse);
	if (soap_out_dss__Device_TurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOffResponse * SOAP_FMAC4 soap_get_dss__Device_TurnOffResponse(struct soap *soap, struct dss__Device_TurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOffResponse * SOAP_FMAC4 soap_in_dss__Device_TurnOffResponse(struct soap *soap, const char *tag, struct dss__Device_TurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOffResponse, sizeof(struct dss__Device_TurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOffResponse, 0, sizeof(struct dss__Device_TurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOffResponse * SOAP_FMAC6 soap_new_dss__Device_TurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOffResponse(struct soap *soap, struct dss__Device_TurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOffResponse;
		if (size)
			*size = sizeof(struct dss__Device_TurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOffResponse %p -> %p\n", q, p));
	*(struct dss__Device_TurnOffResponse*)p = *(struct dss__Device_TurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOn(struct soap *soap, struct dss__Device_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_xsd__unsignedInt(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOn(struct soap *soap, const struct dss__Device_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOn(struct soap *soap, const struct dss__Device_TurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOn);
	if (soap_out_dss__Device_TurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOn(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOn * SOAP_FMAC4 soap_get_dss__Device_TurnOn(struct soap *soap, struct dss__Device_TurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOn * SOAP_FMAC4 soap_in_dss__Device_TurnOn(struct soap *soap, const char *tag, struct dss__Device_TurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOn, sizeof(struct dss__Device_TurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, NULL, &a->_deviceID, "xsd:unsignedInt"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOn, 0, sizeof(struct dss__Device_TurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOn * SOAP_FMAC6 soap_new_dss__Device_TurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOn(struct soap *soap, struct dss__Device_TurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOn * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOn;
		if (size)
			*size = sizeof(struct dss__Device_TurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOn %p -> %p\n", q, p));
	*(struct dss__Device_TurnOn*)p = *(struct dss__Device_TurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Device_TurnOnResponse(struct soap *soap, struct dss__Device_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Device_TurnOnResponse(struct soap *soap, const struct dss__Device_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Device_TurnOnResponse(struct soap *soap, const struct dss__Device_TurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Device_TurnOnResponse);
	if (soap_out_dss__Device_TurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Device_TurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__Device_TurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Device_TurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Device_TurnOnResponse * SOAP_FMAC4 soap_get_dss__Device_TurnOnResponse(struct soap *soap, struct dss__Device_TurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Device_TurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Device_TurnOnResponse * SOAP_FMAC4 soap_in_dss__Device_TurnOnResponse(struct soap *soap, const char *tag, struct dss__Device_TurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Device_TurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Device_TurnOnResponse, sizeof(struct dss__Device_TurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Device_TurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Device_TurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Device_TurnOnResponse, 0, sizeof(struct dss__Device_TurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Device_TurnOnResponse * SOAP_FMAC6 soap_new_dss__Device_TurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Device_TurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Device_TurnOnResponse(struct soap *soap, struct dss__Device_TurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Device_TurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__Device_TurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Device_TurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Device_TurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Device_TurnOnResponse;
		if (size)
			*size = sizeof(struct dss__Device_TurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Device_TurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Device_TurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Device_TurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Device_TurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Device_TurnOnResponse %p -> %p\n", q, p));
	*(struct dss__Device_TurnOnResponse*)p = *(struct dss__Device_TurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_SaveScene(struct soap *soap, struct dss__Group_SaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_SaveScene(struct soap *soap, const struct dss__Group_SaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_SaveScene(struct soap *soap, const struct dss__Group_SaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_SaveScene);
	if (soap_out_dss__Group_SaveScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_SaveScene(struct soap *soap, const char *tag, int id, const struct dss__Group_SaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_SaveScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_SaveScene * SOAP_FMAC4 soap_get_dss__Group_SaveScene(struct soap *soap, struct dss__Group_SaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_SaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_SaveScene * SOAP_FMAC4 soap_in_dss__Group_SaveScene(struct soap *soap, const char *tag, struct dss__Group_SaveScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_SaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_SaveScene, sizeof(struct dss__Group_SaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_SaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_SaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_SaveScene, 0, sizeof(struct dss__Group_SaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_SaveScene * SOAP_FMAC6 soap_new_dss__Group_SaveScene(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_SaveScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_SaveScene(struct soap *soap, struct dss__Group_SaveScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_SaveScene * SOAP_FMAC4 soap_instantiate_dss__Group_SaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_SaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_SaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_SaveScene;
		if (size)
			*size = sizeof(struct dss__Group_SaveScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_SaveScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_SaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_SaveScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_SaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_SaveScene %p -> %p\n", q, p));
	*(struct dss__Group_SaveScene*)p = *(struct dss__Group_SaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_SaveSceneResponse(struct soap *soap, struct dss__Group_SaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_SaveSceneResponse(struct soap *soap, const struct dss__Group_SaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_SaveSceneResponse(struct soap *soap, const struct dss__Group_SaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_SaveSceneResponse);
	if (soap_out_dss__Group_SaveSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_SaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_SaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_SaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_SaveSceneResponse * SOAP_FMAC4 soap_get_dss__Group_SaveSceneResponse(struct soap *soap, struct dss__Group_SaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_SaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_SaveSceneResponse * SOAP_FMAC4 soap_in_dss__Group_SaveSceneResponse(struct soap *soap, const char *tag, struct dss__Group_SaveSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_SaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_SaveSceneResponse, sizeof(struct dss__Group_SaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_SaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_SaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_SaveSceneResponse, 0, sizeof(struct dss__Group_SaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_SaveSceneResponse * SOAP_FMAC6 soap_new_dss__Group_SaveSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_SaveSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_SaveSceneResponse(struct soap *soap, struct dss__Group_SaveSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_SaveSceneResponse * SOAP_FMAC4 soap_instantiate_dss__Group_SaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_SaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_SaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_SaveSceneResponse;
		if (size)
			*size = sizeof(struct dss__Group_SaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_SaveSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_SaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_SaveSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_SaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_SaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__Group_SaveSceneResponse*)p = *(struct dss__Group_SaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_CallScene(struct soap *soap, struct dss__Group_CallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_CallScene(struct soap *soap, const struct dss__Group_CallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_CallScene(struct soap *soap, const struct dss__Group_CallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_CallScene);
	if (soap_out_dss__Group_CallScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_CallScene(struct soap *soap, const char *tag, int id, const struct dss__Group_CallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_CallScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_CallScene * SOAP_FMAC4 soap_get_dss__Group_CallScene(struct soap *soap, struct dss__Group_CallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_CallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_CallScene * SOAP_FMAC4 soap_in_dss__Group_CallScene(struct soap *soap, const char *tag, struct dss__Group_CallScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_CallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_CallScene, sizeof(struct dss__Group_CallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_CallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_CallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_CallScene, 0, sizeof(struct dss__Group_CallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_CallScene * SOAP_FMAC6 soap_new_dss__Group_CallScene(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_CallScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_CallScene(struct soap *soap, struct dss__Group_CallScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_CallScene * SOAP_FMAC4 soap_instantiate_dss__Group_CallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_CallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_CallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_CallScene;
		if (size)
			*size = sizeof(struct dss__Group_CallScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_CallScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_CallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_CallScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_CallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_CallScene %p -> %p\n", q, p));
	*(struct dss__Group_CallScene*)p = *(struct dss__Group_CallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_CallSceneResponse(struct soap *soap, struct dss__Group_CallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_CallSceneResponse(struct soap *soap, const struct dss__Group_CallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_CallSceneResponse(struct soap *soap, const struct dss__Group_CallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_CallSceneResponse);
	if (soap_out_dss__Group_CallSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_CallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_CallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_CallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_CallSceneResponse * SOAP_FMAC4 soap_get_dss__Group_CallSceneResponse(struct soap *soap, struct dss__Group_CallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_CallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_CallSceneResponse * SOAP_FMAC4 soap_in_dss__Group_CallSceneResponse(struct soap *soap, const char *tag, struct dss__Group_CallSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_CallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_CallSceneResponse, sizeof(struct dss__Group_CallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_CallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_CallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_CallSceneResponse, 0, sizeof(struct dss__Group_CallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_CallSceneResponse * SOAP_FMAC6 soap_new_dss__Group_CallSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_CallSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_CallSceneResponse(struct soap *soap, struct dss__Group_CallSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_CallSceneResponse * SOAP_FMAC4 soap_instantiate_dss__Group_CallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_CallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_CallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_CallSceneResponse;
		if (size)
			*size = sizeof(struct dss__Group_CallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_CallSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_CallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_CallSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_CallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_CallSceneResponse %p -> %p\n", q, p));
	*(struct dss__Group_CallSceneResponse*)p = *(struct dss__Group_CallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_SetValue(struct soap *soap, struct dss__Group_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_SetValue(struct soap *soap, const struct dss__Group_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_SetValue(struct soap *soap, const struct dss__Group_SetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_SetValue);
	if (soap_out_dss__Group_SetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_SetValue(struct soap *soap, const char *tag, int id, const struct dss__Group_SetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_SetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_SetValue * SOAP_FMAC4 soap_get_dss__Group_SetValue(struct soap *soap, struct dss__Group_SetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_SetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_SetValue * SOAP_FMAC4 soap_in_dss__Group_SetValue(struct soap *soap, const char *tag, struct dss__Group_SetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_SetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_SetValue, sizeof(struct dss__Group_SetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_SetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_SetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_SetValue, 0, sizeof(struct dss__Group_SetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_SetValue * SOAP_FMAC6 soap_new_dss__Group_SetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_SetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_SetValue(struct soap *soap, struct dss__Group_SetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_SetValue * SOAP_FMAC4 soap_instantiate_dss__Group_SetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_SetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_SetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_SetValue;
		if (size)
			*size = sizeof(struct dss__Group_SetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_SetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_SetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_SetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_SetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_SetValue %p -> %p\n", q, p));
	*(struct dss__Group_SetValue*)p = *(struct dss__Group_SetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_SetValueResponse(struct soap *soap, struct dss__Group_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_SetValueResponse(struct soap *soap, const struct dss__Group_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_SetValueResponse(struct soap *soap, const struct dss__Group_SetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_SetValueResponse);
	if (soap_out_dss__Group_SetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_SetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_SetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_SetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_SetValueResponse * SOAP_FMAC4 soap_get_dss__Group_SetValueResponse(struct soap *soap, struct dss__Group_SetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_SetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_SetValueResponse * SOAP_FMAC4 soap_in_dss__Group_SetValueResponse(struct soap *soap, const char *tag, struct dss__Group_SetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_SetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_SetValueResponse, sizeof(struct dss__Group_SetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_SetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_SetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_SetValueResponse, 0, sizeof(struct dss__Group_SetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_SetValueResponse * SOAP_FMAC6 soap_new_dss__Group_SetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_SetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_SetValueResponse(struct soap *soap, struct dss__Group_SetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_SetValueResponse * SOAP_FMAC4 soap_instantiate_dss__Group_SetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_SetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_SetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_SetValueResponse;
		if (size)
			*size = sizeof(struct dss__Group_SetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_SetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_SetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_SetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_SetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_SetValueResponse %p -> %p\n", q, p));
	*(struct dss__Group_SetValueResponse*)p = *(struct dss__Group_SetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_EndDim(struct soap *soap, struct dss__Group_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_EndDim(struct soap *soap, const struct dss__Group_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_EndDim(struct soap *soap, const struct dss__Group_EndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_EndDim);
	if (soap_out_dss__Group_EndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_EndDim(struct soap *soap, const char *tag, int id, const struct dss__Group_EndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_EndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_EndDim * SOAP_FMAC4 soap_get_dss__Group_EndDim(struct soap *soap, struct dss__Group_EndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_EndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_EndDim * SOAP_FMAC4 soap_in_dss__Group_EndDim(struct soap *soap, const char *tag, struct dss__Group_EndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_EndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_EndDim, sizeof(struct dss__Group_EndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_EndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_EndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_EndDim, 0, sizeof(struct dss__Group_EndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_EndDim * SOAP_FMAC6 soap_new_dss__Group_EndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_EndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_EndDim(struct soap *soap, struct dss__Group_EndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_EndDim * SOAP_FMAC4 soap_instantiate_dss__Group_EndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_EndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_EndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_EndDim;
		if (size)
			*size = sizeof(struct dss__Group_EndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_EndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_EndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_EndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_EndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_EndDim %p -> %p\n", q, p));
	*(struct dss__Group_EndDim*)p = *(struct dss__Group_EndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_EndDimResponse(struct soap *soap, struct dss__Group_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_EndDimResponse(struct soap *soap, const struct dss__Group_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_EndDimResponse(struct soap *soap, const struct dss__Group_EndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_EndDimResponse);
	if (soap_out_dss__Group_EndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_EndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_EndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_EndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_EndDimResponse * SOAP_FMAC4 soap_get_dss__Group_EndDimResponse(struct soap *soap, struct dss__Group_EndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_EndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_EndDimResponse * SOAP_FMAC4 soap_in_dss__Group_EndDimResponse(struct soap *soap, const char *tag, struct dss__Group_EndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_EndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_EndDimResponse, sizeof(struct dss__Group_EndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_EndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_EndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_EndDimResponse, 0, sizeof(struct dss__Group_EndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_EndDimResponse * SOAP_FMAC6 soap_new_dss__Group_EndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_EndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_EndDimResponse(struct soap *soap, struct dss__Group_EndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_EndDimResponse * SOAP_FMAC4 soap_instantiate_dss__Group_EndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_EndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_EndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_EndDimResponse;
		if (size)
			*size = sizeof(struct dss__Group_EndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_EndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_EndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_EndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_EndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_EndDimResponse %p -> %p\n", q, p));
	*(struct dss__Group_EndDimResponse*)p = *(struct dss__Group_EndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_StartDim(struct soap *soap, struct dss__Group_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_StartDim(struct soap *soap, const struct dss__Group_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_StartDim(struct soap *soap, const struct dss__Group_StartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_StartDim);
	if (soap_out_dss__Group_StartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_StartDim(struct soap *soap, const char *tag, int id, const struct dss__Group_StartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_StartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_StartDim * SOAP_FMAC4 soap_get_dss__Group_StartDim(struct soap *soap, struct dss__Group_StartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_StartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_StartDim * SOAP_FMAC4 soap_in_dss__Group_StartDim(struct soap *soap, const char *tag, struct dss__Group_StartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_StartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_StartDim, sizeof(struct dss__Group_StartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_StartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_StartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_StartDim, 0, sizeof(struct dss__Group_StartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_StartDim * SOAP_FMAC6 soap_new_dss__Group_StartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_StartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_StartDim(struct soap *soap, struct dss__Group_StartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_StartDim * SOAP_FMAC4 soap_instantiate_dss__Group_StartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_StartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_StartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_StartDim;
		if (size)
			*size = sizeof(struct dss__Group_StartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_StartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_StartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_StartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_StartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_StartDim %p -> %p\n", q, p));
	*(struct dss__Group_StartDim*)p = *(struct dss__Group_StartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_StartDimResponse(struct soap *soap, struct dss__Group_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_StartDimResponse(struct soap *soap, const struct dss__Group_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_StartDimResponse(struct soap *soap, const struct dss__Group_StartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_StartDimResponse);
	if (soap_out_dss__Group_StartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_StartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_StartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_StartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_StartDimResponse * SOAP_FMAC4 soap_get_dss__Group_StartDimResponse(struct soap *soap, struct dss__Group_StartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_StartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_StartDimResponse * SOAP_FMAC4 soap_in_dss__Group_StartDimResponse(struct soap *soap, const char *tag, struct dss__Group_StartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_StartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_StartDimResponse, sizeof(struct dss__Group_StartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_StartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_StartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_StartDimResponse, 0, sizeof(struct dss__Group_StartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_StartDimResponse * SOAP_FMAC6 soap_new_dss__Group_StartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_StartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_StartDimResponse(struct soap *soap, struct dss__Group_StartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_StartDimResponse * SOAP_FMAC4 soap_instantiate_dss__Group_StartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_StartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_StartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_StartDimResponse;
		if (size)
			*size = sizeof(struct dss__Group_StartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_StartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_StartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_StartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_StartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_StartDimResponse %p -> %p\n", q, p));
	*(struct dss__Group_StartDimResponse*)p = *(struct dss__Group_StartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_Disable(struct soap *soap, struct dss__Group_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_Disable(struct soap *soap, const struct dss__Group_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_Disable(struct soap *soap, const struct dss__Group_Disable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_Disable);
	if (soap_out_dss__Group_Disable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_Disable(struct soap *soap, const char *tag, int id, const struct dss__Group_Disable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_Disable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_Disable * SOAP_FMAC4 soap_get_dss__Group_Disable(struct soap *soap, struct dss__Group_Disable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_Disable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_Disable * SOAP_FMAC4 soap_in_dss__Group_Disable(struct soap *soap, const char *tag, struct dss__Group_Disable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_Disable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_Disable, sizeof(struct dss__Group_Disable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_Disable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_Disable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_Disable, 0, sizeof(struct dss__Group_Disable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_Disable * SOAP_FMAC6 soap_new_dss__Group_Disable(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_Disable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_Disable(struct soap *soap, struct dss__Group_Disable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_Disable * SOAP_FMAC4 soap_instantiate_dss__Group_Disable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_Disable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_Disable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_Disable;
		if (size)
			*size = sizeof(struct dss__Group_Disable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_Disable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_Disable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_Disable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_Disable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_Disable %p -> %p\n", q, p));
	*(struct dss__Group_Disable*)p = *(struct dss__Group_Disable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_DisableResponse(struct soap *soap, struct dss__Group_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_DisableResponse(struct soap *soap, const struct dss__Group_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_DisableResponse(struct soap *soap, const struct dss__Group_DisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_DisableResponse);
	if (soap_out_dss__Group_DisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_DisableResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_DisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_DisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_DisableResponse * SOAP_FMAC4 soap_get_dss__Group_DisableResponse(struct soap *soap, struct dss__Group_DisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_DisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_DisableResponse * SOAP_FMAC4 soap_in_dss__Group_DisableResponse(struct soap *soap, const char *tag, struct dss__Group_DisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_DisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_DisableResponse, sizeof(struct dss__Group_DisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_DisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_DisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_DisableResponse, 0, sizeof(struct dss__Group_DisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_DisableResponse * SOAP_FMAC6 soap_new_dss__Group_DisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_DisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_DisableResponse(struct soap *soap, struct dss__Group_DisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_DisableResponse * SOAP_FMAC4 soap_instantiate_dss__Group_DisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_DisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_DisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_DisableResponse;
		if (size)
			*size = sizeof(struct dss__Group_DisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_DisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_DisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_DisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_DisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_DisableResponse %p -> %p\n", q, p));
	*(struct dss__Group_DisableResponse*)p = *(struct dss__Group_DisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_Enable(struct soap *soap, struct dss__Group_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_Enable(struct soap *soap, const struct dss__Group_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_Enable(struct soap *soap, const struct dss__Group_Enable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_Enable);
	if (soap_out_dss__Group_Enable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_Enable(struct soap *soap, const char *tag, int id, const struct dss__Group_Enable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_Enable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_Enable * SOAP_FMAC4 soap_get_dss__Group_Enable(struct soap *soap, struct dss__Group_Enable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_Enable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_Enable * SOAP_FMAC4 soap_in_dss__Group_Enable(struct soap *soap, const char *tag, struct dss__Group_Enable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_Enable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_Enable, sizeof(struct dss__Group_Enable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_Enable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_Enable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_Enable, 0, sizeof(struct dss__Group_Enable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_Enable * SOAP_FMAC6 soap_new_dss__Group_Enable(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_Enable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_Enable(struct soap *soap, struct dss__Group_Enable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_Enable * SOAP_FMAC4 soap_instantiate_dss__Group_Enable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_Enable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_Enable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_Enable;
		if (size)
			*size = sizeof(struct dss__Group_Enable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_Enable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_Enable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_Enable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_Enable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_Enable %p -> %p\n", q, p));
	*(struct dss__Group_Enable*)p = *(struct dss__Group_Enable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_EnableResponse(struct soap *soap, struct dss__Group_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_EnableResponse(struct soap *soap, const struct dss__Group_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_EnableResponse(struct soap *soap, const struct dss__Group_EnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_EnableResponse);
	if (soap_out_dss__Group_EnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_EnableResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_EnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_EnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_EnableResponse * SOAP_FMAC4 soap_get_dss__Group_EnableResponse(struct soap *soap, struct dss__Group_EnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_EnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_EnableResponse * SOAP_FMAC4 soap_in_dss__Group_EnableResponse(struct soap *soap, const char *tag, struct dss__Group_EnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_EnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_EnableResponse, sizeof(struct dss__Group_EnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_EnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_EnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_EnableResponse, 0, sizeof(struct dss__Group_EnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_EnableResponse * SOAP_FMAC6 soap_new_dss__Group_EnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_EnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_EnableResponse(struct soap *soap, struct dss__Group_EnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_EnableResponse * SOAP_FMAC4 soap_instantiate_dss__Group_EnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_EnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_EnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_EnableResponse;
		if (size)
			*size = sizeof(struct dss__Group_EnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_EnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_EnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_EnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_EnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_EnableResponse %p -> %p\n", q, p));
	*(struct dss__Group_EnableResponse*)p = *(struct dss__Group_EnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_DecreaseValue(struct soap *soap, struct dss__Group_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_DecreaseValue(struct soap *soap, const struct dss__Group_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_DecreaseValue(struct soap *soap, const struct dss__Group_DecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_DecreaseValue);
	if (soap_out_dss__Group_DecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_DecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Group_DecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_DecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_DecreaseValue * SOAP_FMAC4 soap_get_dss__Group_DecreaseValue(struct soap *soap, struct dss__Group_DecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_DecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_DecreaseValue * SOAP_FMAC4 soap_in_dss__Group_DecreaseValue(struct soap *soap, const char *tag, struct dss__Group_DecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_DecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_DecreaseValue, sizeof(struct dss__Group_DecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_DecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_DecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_DecreaseValue, 0, sizeof(struct dss__Group_DecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_DecreaseValue * SOAP_FMAC6 soap_new_dss__Group_DecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_DecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_DecreaseValue(struct soap *soap, struct dss__Group_DecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_DecreaseValue * SOAP_FMAC4 soap_instantiate_dss__Group_DecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_DecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_DecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_DecreaseValue;
		if (size)
			*size = sizeof(struct dss__Group_DecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_DecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_DecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_DecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_DecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_DecreaseValue %p -> %p\n", q, p));
	*(struct dss__Group_DecreaseValue*)p = *(struct dss__Group_DecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_DecreaseValueResponse(struct soap *soap, struct dss__Group_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_DecreaseValueResponse(struct soap *soap, const struct dss__Group_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_DecreaseValueResponse(struct soap *soap, const struct dss__Group_DecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_DecreaseValueResponse);
	if (soap_out_dss__Group_DecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_DecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_DecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_DecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_DecreaseValueResponse * SOAP_FMAC4 soap_get_dss__Group_DecreaseValueResponse(struct soap *soap, struct dss__Group_DecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_DecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_DecreaseValueResponse * SOAP_FMAC4 soap_in_dss__Group_DecreaseValueResponse(struct soap *soap, const char *tag, struct dss__Group_DecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_DecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_DecreaseValueResponse, sizeof(struct dss__Group_DecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_DecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_DecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_DecreaseValueResponse, 0, sizeof(struct dss__Group_DecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_DecreaseValueResponse * SOAP_FMAC6 soap_new_dss__Group_DecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_DecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_DecreaseValueResponse(struct soap *soap, struct dss__Group_DecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_DecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Group_DecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_DecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_DecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_DecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Group_DecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_DecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_DecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_DecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_DecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_DecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Group_DecreaseValueResponse*)p = *(struct dss__Group_DecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_IncreaseValue(struct soap *soap, struct dss__Group_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_IncreaseValue(struct soap *soap, const struct dss__Group_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_IncreaseValue(struct soap *soap, const struct dss__Group_IncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_IncreaseValue);
	if (soap_out_dss__Group_IncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_IncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Group_IncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_IncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_IncreaseValue * SOAP_FMAC4 soap_get_dss__Group_IncreaseValue(struct soap *soap, struct dss__Group_IncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_IncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_IncreaseValue * SOAP_FMAC4 soap_in_dss__Group_IncreaseValue(struct soap *soap, const char *tag, struct dss__Group_IncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_IncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_IncreaseValue, sizeof(struct dss__Group_IncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_IncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_IncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_IncreaseValue, 0, sizeof(struct dss__Group_IncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_IncreaseValue * SOAP_FMAC6 soap_new_dss__Group_IncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_IncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_IncreaseValue(struct soap *soap, struct dss__Group_IncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_IncreaseValue * SOAP_FMAC4 soap_instantiate_dss__Group_IncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_IncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_IncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_IncreaseValue;
		if (size)
			*size = sizeof(struct dss__Group_IncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_IncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_IncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_IncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_IncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_IncreaseValue %p -> %p\n", q, p));
	*(struct dss__Group_IncreaseValue*)p = *(struct dss__Group_IncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_IncreaseValueResponse(struct soap *soap, struct dss__Group_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_IncreaseValueResponse(struct soap *soap, const struct dss__Group_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_IncreaseValueResponse(struct soap *soap, const struct dss__Group_IncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_IncreaseValueResponse);
	if (soap_out_dss__Group_IncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_IncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_IncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_IncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_IncreaseValueResponse * SOAP_FMAC4 soap_get_dss__Group_IncreaseValueResponse(struct soap *soap, struct dss__Group_IncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_IncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_IncreaseValueResponse * SOAP_FMAC4 soap_in_dss__Group_IncreaseValueResponse(struct soap *soap, const char *tag, struct dss__Group_IncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_IncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_IncreaseValueResponse, sizeof(struct dss__Group_IncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_IncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_IncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_IncreaseValueResponse, 0, sizeof(struct dss__Group_IncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_IncreaseValueResponse * SOAP_FMAC6 soap_new_dss__Group_IncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_IncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_IncreaseValueResponse(struct soap *soap, struct dss__Group_IncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_IncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Group_IncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_IncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_IncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_IncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Group_IncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_IncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_IncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_IncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_IncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_IncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Group_IncreaseValueResponse*)p = *(struct dss__Group_IncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_TurnOff(struct soap *soap, struct dss__Group_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_TurnOff(struct soap *soap, const struct dss__Group_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_TurnOff(struct soap *soap, const struct dss__Group_TurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_TurnOff);
	if (soap_out_dss__Group_TurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_TurnOff(struct soap *soap, const char *tag, int id, const struct dss__Group_TurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_TurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_TurnOff * SOAP_FMAC4 soap_get_dss__Group_TurnOff(struct soap *soap, struct dss__Group_TurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_TurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_TurnOff * SOAP_FMAC4 soap_in_dss__Group_TurnOff(struct soap *soap, const char *tag, struct dss__Group_TurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_TurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_TurnOff, sizeof(struct dss__Group_TurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_TurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_TurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_TurnOff, 0, sizeof(struct dss__Group_TurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_TurnOff * SOAP_FMAC6 soap_new_dss__Group_TurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_TurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_TurnOff(struct soap *soap, struct dss__Group_TurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_TurnOff * SOAP_FMAC4 soap_instantiate_dss__Group_TurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_TurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_TurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_TurnOff;
		if (size)
			*size = sizeof(struct dss__Group_TurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_TurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_TurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_TurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_TurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_TurnOff %p -> %p\n", q, p));
	*(struct dss__Group_TurnOff*)p = *(struct dss__Group_TurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_TurnOffResponse(struct soap *soap, struct dss__Group_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_TurnOffResponse(struct soap *soap, const struct dss__Group_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_TurnOffResponse(struct soap *soap, const struct dss__Group_TurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_TurnOffResponse);
	if (soap_out_dss__Group_TurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_TurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_TurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_TurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_TurnOffResponse * SOAP_FMAC4 soap_get_dss__Group_TurnOffResponse(struct soap *soap, struct dss__Group_TurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_TurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_TurnOffResponse * SOAP_FMAC4 soap_in_dss__Group_TurnOffResponse(struct soap *soap, const char *tag, struct dss__Group_TurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_TurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_TurnOffResponse, sizeof(struct dss__Group_TurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_TurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_TurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_TurnOffResponse, 0, sizeof(struct dss__Group_TurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_TurnOffResponse * SOAP_FMAC6 soap_new_dss__Group_TurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_TurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_TurnOffResponse(struct soap *soap, struct dss__Group_TurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_TurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__Group_TurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_TurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_TurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_TurnOffResponse;
		if (size)
			*size = sizeof(struct dss__Group_TurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_TurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_TurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_TurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_TurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_TurnOffResponse %p -> %p\n", q, p));
	*(struct dss__Group_TurnOffResponse*)p = *(struct dss__Group_TurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_TurnOn(struct soap *soap, struct dss__Group_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_TurnOn(struct soap *soap, const struct dss__Group_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_TurnOn(struct soap *soap, const struct dss__Group_TurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_TurnOn);
	if (soap_out_dss__Group_TurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_TurnOn(struct soap *soap, const char *tag, int id, const struct dss__Group_TurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_TurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_TurnOn * SOAP_FMAC4 soap_get_dss__Group_TurnOn(struct soap *soap, struct dss__Group_TurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_TurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_TurnOn * SOAP_FMAC4 soap_in_dss__Group_TurnOn(struct soap *soap, const char *tag, struct dss__Group_TurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_TurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_TurnOn, sizeof(struct dss__Group_TurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_TurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_TurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_TurnOn, 0, sizeof(struct dss__Group_TurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_TurnOn * SOAP_FMAC6 soap_new_dss__Group_TurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_TurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_TurnOn(struct soap *soap, struct dss__Group_TurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_TurnOn * SOAP_FMAC4 soap_instantiate_dss__Group_TurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_TurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_TurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_TurnOn;
		if (size)
			*size = sizeof(struct dss__Group_TurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_TurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_TurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_TurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_TurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_TurnOn %p -> %p\n", q, p));
	*(struct dss__Group_TurnOn*)p = *(struct dss__Group_TurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Group_TurnOnResponse(struct soap *soap, struct dss__Group_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Group_TurnOnResponse(struct soap *soap, const struct dss__Group_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Group_TurnOnResponse(struct soap *soap, const struct dss__Group_TurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Group_TurnOnResponse);
	if (soap_out_dss__Group_TurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Group_TurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__Group_TurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Group_TurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Group_TurnOnResponse * SOAP_FMAC4 soap_get_dss__Group_TurnOnResponse(struct soap *soap, struct dss__Group_TurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Group_TurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Group_TurnOnResponse * SOAP_FMAC4 soap_in_dss__Group_TurnOnResponse(struct soap *soap, const char *tag, struct dss__Group_TurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Group_TurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Group_TurnOnResponse, sizeof(struct dss__Group_TurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Group_TurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Group_TurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Group_TurnOnResponse, 0, sizeof(struct dss__Group_TurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Group_TurnOnResponse * SOAP_FMAC6 soap_new_dss__Group_TurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Group_TurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Group_TurnOnResponse(struct soap *soap, struct dss__Group_TurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Group_TurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__Group_TurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Group_TurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Group_TurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Group_TurnOnResponse;
		if (size)
			*size = sizeof(struct dss__Group_TurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Group_TurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Group_TurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Group_TurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Group_TurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Group_TurnOnResponse %p -> %p\n", q, p));
	*(struct dss__Group_TurnOnResponse*)p = *(struct dss__Group_TurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_SaveScene(struct soap *soap, struct dss__Set_SaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_SaveScene(struct soap *soap, const struct dss__Set_SaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_SaveScene(struct soap *soap, const struct dss__Set_SaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_SaveScene);
	if (soap_out_dss__Set_SaveScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_SaveScene(struct soap *soap, const char *tag, int id, const struct dss__Set_SaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_SaveScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_SaveScene * SOAP_FMAC4 soap_get_dss__Set_SaveScene(struct soap *soap, struct dss__Set_SaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_SaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_SaveScene * SOAP_FMAC4 soap_in_dss__Set_SaveScene(struct soap *soap, const char *tag, struct dss__Set_SaveScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_SaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_SaveScene, sizeof(struct dss__Set_SaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_SaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_SaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_SaveScene, 0, sizeof(struct dss__Set_SaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_SaveScene * SOAP_FMAC6 soap_new_dss__Set_SaveScene(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_SaveScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_SaveScene(struct soap *soap, struct dss__Set_SaveScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_SaveScene * SOAP_FMAC4 soap_instantiate_dss__Set_SaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_SaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_SaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_SaveScene;
		if (size)
			*size = sizeof(struct dss__Set_SaveScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_SaveScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_SaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_SaveScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_SaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_SaveScene %p -> %p\n", q, p));
	*(struct dss__Set_SaveScene*)p = *(struct dss__Set_SaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_SaveSceneResponse(struct soap *soap, struct dss__Set_SaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_SaveSceneResponse(struct soap *soap, const struct dss__Set_SaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_SaveSceneResponse(struct soap *soap, const struct dss__Set_SaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_SaveSceneResponse);
	if (soap_out_dss__Set_SaveSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_SaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_SaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_SaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_SaveSceneResponse * SOAP_FMAC4 soap_get_dss__Set_SaveSceneResponse(struct soap *soap, struct dss__Set_SaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_SaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_SaveSceneResponse * SOAP_FMAC4 soap_in_dss__Set_SaveSceneResponse(struct soap *soap, const char *tag, struct dss__Set_SaveSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_SaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_SaveSceneResponse, sizeof(struct dss__Set_SaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_SaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_SaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_SaveSceneResponse, 0, sizeof(struct dss__Set_SaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_SaveSceneResponse * SOAP_FMAC6 soap_new_dss__Set_SaveSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_SaveSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_SaveSceneResponse(struct soap *soap, struct dss__Set_SaveSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_SaveSceneResponse * SOAP_FMAC4 soap_instantiate_dss__Set_SaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_SaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_SaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_SaveSceneResponse;
		if (size)
			*size = sizeof(struct dss__Set_SaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_SaveSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_SaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_SaveSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_SaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_SaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__Set_SaveSceneResponse*)p = *(struct dss__Set_SaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_CallScene(struct soap *soap, struct dss__Set_CallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_CallScene(struct soap *soap, const struct dss__Set_CallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_CallScene(struct soap *soap, const struct dss__Set_CallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_CallScene);
	if (soap_out_dss__Set_CallScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_CallScene(struct soap *soap, const char *tag, int id, const struct dss__Set_CallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_CallScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_CallScene * SOAP_FMAC4 soap_get_dss__Set_CallScene(struct soap *soap, struct dss__Set_CallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_CallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_CallScene * SOAP_FMAC4 soap_in_dss__Set_CallScene(struct soap *soap, const char *tag, struct dss__Set_CallScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_CallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_CallScene, sizeof(struct dss__Set_CallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_CallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_CallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_CallScene, 0, sizeof(struct dss__Set_CallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_CallScene * SOAP_FMAC6 soap_new_dss__Set_CallScene(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_CallScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_CallScene(struct soap *soap, struct dss__Set_CallScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_CallScene * SOAP_FMAC4 soap_instantiate_dss__Set_CallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_CallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_CallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_CallScene;
		if (size)
			*size = sizeof(struct dss__Set_CallScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_CallScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_CallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_CallScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_CallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_CallScene %p -> %p\n", q, p));
	*(struct dss__Set_CallScene*)p = *(struct dss__Set_CallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_CallSceneResponse(struct soap *soap, struct dss__Set_CallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_CallSceneResponse(struct soap *soap, const struct dss__Set_CallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_CallSceneResponse(struct soap *soap, const struct dss__Set_CallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_CallSceneResponse);
	if (soap_out_dss__Set_CallSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_CallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_CallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_CallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_CallSceneResponse * SOAP_FMAC4 soap_get_dss__Set_CallSceneResponse(struct soap *soap, struct dss__Set_CallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_CallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_CallSceneResponse * SOAP_FMAC4 soap_in_dss__Set_CallSceneResponse(struct soap *soap, const char *tag, struct dss__Set_CallSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_CallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_CallSceneResponse, sizeof(struct dss__Set_CallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_CallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_CallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_CallSceneResponse, 0, sizeof(struct dss__Set_CallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_CallSceneResponse * SOAP_FMAC6 soap_new_dss__Set_CallSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_CallSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_CallSceneResponse(struct soap *soap, struct dss__Set_CallSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_CallSceneResponse * SOAP_FMAC4 soap_instantiate_dss__Set_CallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_CallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_CallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_CallSceneResponse;
		if (size)
			*size = sizeof(struct dss__Set_CallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_CallSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_CallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_CallSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_CallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_CallSceneResponse %p -> %p\n", q, p));
	*(struct dss__Set_CallSceneResponse*)p = *(struct dss__Set_CallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_SetValue(struct soap *soap, struct dss__Set_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_SetValue(struct soap *soap, const struct dss__Set_SetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_SetValue(struct soap *soap, const struct dss__Set_SetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_SetValue);
	if (soap_out_dss__Set_SetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_SetValue(struct soap *soap, const char *tag, int id, const struct dss__Set_SetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_SetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_SetValue * SOAP_FMAC4 soap_get_dss__Set_SetValue(struct soap *soap, struct dss__Set_SetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_SetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_SetValue * SOAP_FMAC4 soap_in_dss__Set_SetValue(struct soap *soap, const char *tag, struct dss__Set_SetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_SetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_SetValue, sizeof(struct dss__Set_SetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_SetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_SetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_SetValue, 0, sizeof(struct dss__Set_SetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_SetValue * SOAP_FMAC6 soap_new_dss__Set_SetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_SetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_SetValue(struct soap *soap, struct dss__Set_SetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_SetValue * SOAP_FMAC4 soap_instantiate_dss__Set_SetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_SetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_SetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_SetValue;
		if (size)
			*size = sizeof(struct dss__Set_SetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_SetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_SetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_SetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_SetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_SetValue %p -> %p\n", q, p));
	*(struct dss__Set_SetValue*)p = *(struct dss__Set_SetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_SetValueResponse(struct soap *soap, struct dss__Set_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_SetValueResponse(struct soap *soap, const struct dss__Set_SetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_SetValueResponse(struct soap *soap, const struct dss__Set_SetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_SetValueResponse);
	if (soap_out_dss__Set_SetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_SetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_SetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_SetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_SetValueResponse * SOAP_FMAC4 soap_get_dss__Set_SetValueResponse(struct soap *soap, struct dss__Set_SetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_SetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_SetValueResponse * SOAP_FMAC4 soap_in_dss__Set_SetValueResponse(struct soap *soap, const char *tag, struct dss__Set_SetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_SetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_SetValueResponse, sizeof(struct dss__Set_SetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_SetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_SetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_SetValueResponse, 0, sizeof(struct dss__Set_SetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_SetValueResponse * SOAP_FMAC6 soap_new_dss__Set_SetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_SetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_SetValueResponse(struct soap *soap, struct dss__Set_SetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_SetValueResponse * SOAP_FMAC4 soap_instantiate_dss__Set_SetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_SetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_SetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_SetValueResponse;
		if (size)
			*size = sizeof(struct dss__Set_SetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_SetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_SetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_SetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_SetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_SetValueResponse %p -> %p\n", q, p));
	*(struct dss__Set_SetValueResponse*)p = *(struct dss__Set_SetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_EndDim(struct soap *soap, struct dss__Set_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_EndDim(struct soap *soap, const struct dss__Set_EndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_EndDim(struct soap *soap, const struct dss__Set_EndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_EndDim);
	if (soap_out_dss__Set_EndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_EndDim(struct soap *soap, const char *tag, int id, const struct dss__Set_EndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_EndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_EndDim * SOAP_FMAC4 soap_get_dss__Set_EndDim(struct soap *soap, struct dss__Set_EndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_EndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_EndDim * SOAP_FMAC4 soap_in_dss__Set_EndDim(struct soap *soap, const char *tag, struct dss__Set_EndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_EndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_EndDim, sizeof(struct dss__Set_EndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_EndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_EndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_EndDim, 0, sizeof(struct dss__Set_EndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_EndDim * SOAP_FMAC6 soap_new_dss__Set_EndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_EndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_EndDim(struct soap *soap, struct dss__Set_EndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_EndDim * SOAP_FMAC4 soap_instantiate_dss__Set_EndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_EndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_EndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_EndDim;
		if (size)
			*size = sizeof(struct dss__Set_EndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_EndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_EndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_EndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_EndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_EndDim %p -> %p\n", q, p));
	*(struct dss__Set_EndDim*)p = *(struct dss__Set_EndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_EndDimResponse(struct soap *soap, struct dss__Set_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_EndDimResponse(struct soap *soap, const struct dss__Set_EndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_EndDimResponse(struct soap *soap, const struct dss__Set_EndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_EndDimResponse);
	if (soap_out_dss__Set_EndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_EndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_EndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_EndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_EndDimResponse * SOAP_FMAC4 soap_get_dss__Set_EndDimResponse(struct soap *soap, struct dss__Set_EndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_EndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_EndDimResponse * SOAP_FMAC4 soap_in_dss__Set_EndDimResponse(struct soap *soap, const char *tag, struct dss__Set_EndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_EndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_EndDimResponse, sizeof(struct dss__Set_EndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_EndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_EndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_EndDimResponse, 0, sizeof(struct dss__Set_EndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_EndDimResponse * SOAP_FMAC6 soap_new_dss__Set_EndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_EndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_EndDimResponse(struct soap *soap, struct dss__Set_EndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_EndDimResponse * SOAP_FMAC4 soap_instantiate_dss__Set_EndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_EndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_EndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_EndDimResponse;
		if (size)
			*size = sizeof(struct dss__Set_EndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_EndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_EndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_EndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_EndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_EndDimResponse %p -> %p\n", q, p));
	*(struct dss__Set_EndDimResponse*)p = *(struct dss__Set_EndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_StartDim(struct soap *soap, struct dss__Set_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_StartDim(struct soap *soap, const struct dss__Set_StartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_StartDim(struct soap *soap, const struct dss__Set_StartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_StartDim);
	if (soap_out_dss__Set_StartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_StartDim(struct soap *soap, const char *tag, int id, const struct dss__Set_StartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_StartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_StartDim * SOAP_FMAC4 soap_get_dss__Set_StartDim(struct soap *soap, struct dss__Set_StartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_StartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_StartDim * SOAP_FMAC4 soap_in_dss__Set_StartDim(struct soap *soap, const char *tag, struct dss__Set_StartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_StartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_StartDim, sizeof(struct dss__Set_StartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_StartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_StartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_StartDim, 0, sizeof(struct dss__Set_StartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_StartDim * SOAP_FMAC6 soap_new_dss__Set_StartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_StartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_StartDim(struct soap *soap, struct dss__Set_StartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_StartDim * SOAP_FMAC4 soap_instantiate_dss__Set_StartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_StartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_StartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_StartDim;
		if (size)
			*size = sizeof(struct dss__Set_StartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_StartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_StartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_StartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_StartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_StartDim %p -> %p\n", q, p));
	*(struct dss__Set_StartDim*)p = *(struct dss__Set_StartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_StartDimResponse(struct soap *soap, struct dss__Set_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_StartDimResponse(struct soap *soap, const struct dss__Set_StartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_StartDimResponse(struct soap *soap, const struct dss__Set_StartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_StartDimResponse);
	if (soap_out_dss__Set_StartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_StartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_StartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_StartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_StartDimResponse * SOAP_FMAC4 soap_get_dss__Set_StartDimResponse(struct soap *soap, struct dss__Set_StartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_StartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_StartDimResponse * SOAP_FMAC4 soap_in_dss__Set_StartDimResponse(struct soap *soap, const char *tag, struct dss__Set_StartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_StartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_StartDimResponse, sizeof(struct dss__Set_StartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_StartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_StartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_StartDimResponse, 0, sizeof(struct dss__Set_StartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_StartDimResponse * SOAP_FMAC6 soap_new_dss__Set_StartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_StartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_StartDimResponse(struct soap *soap, struct dss__Set_StartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_StartDimResponse * SOAP_FMAC4 soap_instantiate_dss__Set_StartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_StartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_StartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_StartDimResponse;
		if (size)
			*size = sizeof(struct dss__Set_StartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_StartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_StartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_StartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_StartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_StartDimResponse %p -> %p\n", q, p));
	*(struct dss__Set_StartDimResponse*)p = *(struct dss__Set_StartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Disable(struct soap *soap, struct dss__Set_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Disable(struct soap *soap, const struct dss__Set_Disable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Disable(struct soap *soap, const struct dss__Set_Disable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Disable);
	if (soap_out_dss__Set_Disable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Disable(struct soap *soap, const char *tag, int id, const struct dss__Set_Disable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Disable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Disable * SOAP_FMAC4 soap_get_dss__Set_Disable(struct soap *soap, struct dss__Set_Disable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Disable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Disable * SOAP_FMAC4 soap_in_dss__Set_Disable(struct soap *soap, const char *tag, struct dss__Set_Disable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Disable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Disable, sizeof(struct dss__Set_Disable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Disable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Disable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Disable, 0, sizeof(struct dss__Set_Disable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Disable * SOAP_FMAC6 soap_new_dss__Set_Disable(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Disable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Disable(struct soap *soap, struct dss__Set_Disable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Disable * SOAP_FMAC4 soap_instantiate_dss__Set_Disable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Disable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Disable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Disable;
		if (size)
			*size = sizeof(struct dss__Set_Disable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Disable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Disable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Disable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Disable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Disable %p -> %p\n", q, p));
	*(struct dss__Set_Disable*)p = *(struct dss__Set_Disable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_DisableResponse(struct soap *soap, struct dss__Set_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_DisableResponse(struct soap *soap, const struct dss__Set_DisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_DisableResponse(struct soap *soap, const struct dss__Set_DisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_DisableResponse);
	if (soap_out_dss__Set_DisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_DisableResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_DisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_DisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_DisableResponse * SOAP_FMAC4 soap_get_dss__Set_DisableResponse(struct soap *soap, struct dss__Set_DisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_DisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_DisableResponse * SOAP_FMAC4 soap_in_dss__Set_DisableResponse(struct soap *soap, const char *tag, struct dss__Set_DisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_DisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_DisableResponse, sizeof(struct dss__Set_DisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_DisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_DisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_DisableResponse, 0, sizeof(struct dss__Set_DisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_DisableResponse * SOAP_FMAC6 soap_new_dss__Set_DisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_DisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_DisableResponse(struct soap *soap, struct dss__Set_DisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_DisableResponse * SOAP_FMAC4 soap_instantiate_dss__Set_DisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_DisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_DisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_DisableResponse;
		if (size)
			*size = sizeof(struct dss__Set_DisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_DisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_DisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_DisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_DisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_DisableResponse %p -> %p\n", q, p));
	*(struct dss__Set_DisableResponse*)p = *(struct dss__Set_DisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Enable(struct soap *soap, struct dss__Set_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Enable(struct soap *soap, const struct dss__Set_Enable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Enable(struct soap *soap, const struct dss__Set_Enable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Enable);
	if (soap_out_dss__Set_Enable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Enable(struct soap *soap, const char *tag, int id, const struct dss__Set_Enable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Enable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Enable * SOAP_FMAC4 soap_get_dss__Set_Enable(struct soap *soap, struct dss__Set_Enable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Enable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Enable * SOAP_FMAC4 soap_in_dss__Set_Enable(struct soap *soap, const char *tag, struct dss__Set_Enable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Enable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Enable, sizeof(struct dss__Set_Enable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Enable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Enable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Enable, 0, sizeof(struct dss__Set_Enable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Enable * SOAP_FMAC6 soap_new_dss__Set_Enable(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Enable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Enable(struct soap *soap, struct dss__Set_Enable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Enable * SOAP_FMAC4 soap_instantiate_dss__Set_Enable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Enable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Enable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Enable;
		if (size)
			*size = sizeof(struct dss__Set_Enable);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Enable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Enable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Enable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Enable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Enable %p -> %p\n", q, p));
	*(struct dss__Set_Enable*)p = *(struct dss__Set_Enable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_EnableResponse(struct soap *soap, struct dss__Set_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_EnableResponse(struct soap *soap, const struct dss__Set_EnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_EnableResponse(struct soap *soap, const struct dss__Set_EnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_EnableResponse);
	if (soap_out_dss__Set_EnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_EnableResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_EnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_EnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_EnableResponse * SOAP_FMAC4 soap_get_dss__Set_EnableResponse(struct soap *soap, struct dss__Set_EnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_EnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_EnableResponse * SOAP_FMAC4 soap_in_dss__Set_EnableResponse(struct soap *soap, const char *tag, struct dss__Set_EnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_EnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_EnableResponse, sizeof(struct dss__Set_EnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_EnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_EnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_EnableResponse, 0, sizeof(struct dss__Set_EnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_EnableResponse * SOAP_FMAC6 soap_new_dss__Set_EnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_EnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_EnableResponse(struct soap *soap, struct dss__Set_EnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_EnableResponse * SOAP_FMAC4 soap_instantiate_dss__Set_EnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_EnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_EnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_EnableResponse;
		if (size)
			*size = sizeof(struct dss__Set_EnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_EnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_EnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_EnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_EnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_EnableResponse %p -> %p\n", q, p));
	*(struct dss__Set_EnableResponse*)p = *(struct dss__Set_EnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_DecreaseValue(struct soap *soap, struct dss__Set_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_DecreaseValue(struct soap *soap, const struct dss__Set_DecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_DecreaseValue(struct soap *soap, const struct dss__Set_DecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_DecreaseValue);
	if (soap_out_dss__Set_DecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_DecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Set_DecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_DecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_DecreaseValue * SOAP_FMAC4 soap_get_dss__Set_DecreaseValue(struct soap *soap, struct dss__Set_DecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_DecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_DecreaseValue * SOAP_FMAC4 soap_in_dss__Set_DecreaseValue(struct soap *soap, const char *tag, struct dss__Set_DecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_DecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_DecreaseValue, sizeof(struct dss__Set_DecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_DecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_DecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_DecreaseValue, 0, sizeof(struct dss__Set_DecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_DecreaseValue * SOAP_FMAC6 soap_new_dss__Set_DecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_DecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_DecreaseValue(struct soap *soap, struct dss__Set_DecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_DecreaseValue * SOAP_FMAC4 soap_instantiate_dss__Set_DecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_DecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_DecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValue;
		if (size)
			*size = sizeof(struct dss__Set_DecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_DecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_DecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_DecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_DecreaseValue %p -> %p\n", q, p));
	*(struct dss__Set_DecreaseValue*)p = *(struct dss__Set_DecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_DecreaseValueResponse(struct soap *soap, struct dss__Set_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_DecreaseValueResponse(struct soap *soap, const struct dss__Set_DecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_DecreaseValueResponse(struct soap *soap, const struct dss__Set_DecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_DecreaseValueResponse);
	if (soap_out_dss__Set_DecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_DecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_DecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_DecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_DecreaseValueResponse * SOAP_FMAC4 soap_get_dss__Set_DecreaseValueResponse(struct soap *soap, struct dss__Set_DecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_DecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_DecreaseValueResponse * SOAP_FMAC4 soap_in_dss__Set_DecreaseValueResponse(struct soap *soap, const char *tag, struct dss__Set_DecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_DecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_DecreaseValueResponse, sizeof(struct dss__Set_DecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_DecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_DecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_DecreaseValueResponse, 0, sizeof(struct dss__Set_DecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_DecreaseValueResponse * SOAP_FMAC6 soap_new_dss__Set_DecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_DecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_DecreaseValueResponse(struct soap *soap, struct dss__Set_DecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_DecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Set_DecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_DecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_DecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Set_DecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_DecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_DecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_DecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_DecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_DecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Set_DecreaseValueResponse*)p = *(struct dss__Set_DecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_IncreaseValue(struct soap *soap, struct dss__Set_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_IncreaseValue(struct soap *soap, const struct dss__Set_IncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_IncreaseValue(struct soap *soap, const struct dss__Set_IncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_IncreaseValue);
	if (soap_out_dss__Set_IncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_IncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__Set_IncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_IncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_IncreaseValue * SOAP_FMAC4 soap_get_dss__Set_IncreaseValue(struct soap *soap, struct dss__Set_IncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_IncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_IncreaseValue * SOAP_FMAC4 soap_in_dss__Set_IncreaseValue(struct soap *soap, const char *tag, struct dss__Set_IncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_IncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_IncreaseValue, sizeof(struct dss__Set_IncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_IncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_IncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_IncreaseValue, 0, sizeof(struct dss__Set_IncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_IncreaseValue * SOAP_FMAC6 soap_new_dss__Set_IncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_IncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_IncreaseValue(struct soap *soap, struct dss__Set_IncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_IncreaseValue * SOAP_FMAC4 soap_instantiate_dss__Set_IncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_IncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_IncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValue;
		if (size)
			*size = sizeof(struct dss__Set_IncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_IncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_IncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_IncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_IncreaseValue %p -> %p\n", q, p));
	*(struct dss__Set_IncreaseValue*)p = *(struct dss__Set_IncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_IncreaseValueResponse(struct soap *soap, struct dss__Set_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_IncreaseValueResponse(struct soap *soap, const struct dss__Set_IncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_IncreaseValueResponse(struct soap *soap, const struct dss__Set_IncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_IncreaseValueResponse);
	if (soap_out_dss__Set_IncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_IncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_IncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_IncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_IncreaseValueResponse * SOAP_FMAC4 soap_get_dss__Set_IncreaseValueResponse(struct soap *soap, struct dss__Set_IncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_IncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_IncreaseValueResponse * SOAP_FMAC4 soap_in_dss__Set_IncreaseValueResponse(struct soap *soap, const char *tag, struct dss__Set_IncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_IncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_IncreaseValueResponse, sizeof(struct dss__Set_IncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_IncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_IncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_IncreaseValueResponse, 0, sizeof(struct dss__Set_IncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_IncreaseValueResponse * SOAP_FMAC6 soap_new_dss__Set_IncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_IncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_IncreaseValueResponse(struct soap *soap, struct dss__Set_IncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_IncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__Set_IncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_IncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_IncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__Set_IncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_IncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_IncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_IncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_IncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_IncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__Set_IncreaseValueResponse*)p = *(struct dss__Set_IncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOff(struct soap *soap, struct dss__Set_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOff(struct soap *soap, const struct dss__Set_TurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOff(struct soap *soap, const struct dss__Set_TurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOff);
	if (soap_out_dss__Set_TurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOff(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOff * SOAP_FMAC4 soap_get_dss__Set_TurnOff(struct soap *soap, struct dss__Set_TurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOff * SOAP_FMAC4 soap_in_dss__Set_TurnOff(struct soap *soap, const char *tag, struct dss__Set_TurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOff, sizeof(struct dss__Set_TurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOff, 0, sizeof(struct dss__Set_TurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOff * SOAP_FMAC6 soap_new_dss__Set_TurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOff(struct soap *soap, struct dss__Set_TurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOff * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOff;
		if (size)
			*size = sizeof(struct dss__Set_TurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOff %p -> %p\n", q, p));
	*(struct dss__Set_TurnOff*)p = *(struct dss__Set_TurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOffResponse(struct soap *soap, struct dss__Set_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOffResponse(struct soap *soap, const struct dss__Set_TurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOffResponse(struct soap *soap, const struct dss__Set_TurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOffResponse);
	if (soap_out_dss__Set_TurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOffResponse * SOAP_FMAC4 soap_get_dss__Set_TurnOffResponse(struct soap *soap, struct dss__Set_TurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOffResponse * SOAP_FMAC4 soap_in_dss__Set_TurnOffResponse(struct soap *soap, const char *tag, struct dss__Set_TurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOffResponse, sizeof(struct dss__Set_TurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOffResponse, 0, sizeof(struct dss__Set_TurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOffResponse * SOAP_FMAC6 soap_new_dss__Set_TurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOffResponse(struct soap *soap, struct dss__Set_TurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOffResponse;
		if (size)
			*size = sizeof(struct dss__Set_TurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOffResponse %p -> %p\n", q, p));
	*(struct dss__Set_TurnOffResponse*)p = *(struct dss__Set_TurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOn(struct soap *soap, struct dss__Set_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOn(struct soap *soap, const struct dss__Set_TurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOn(struct soap *soap, const struct dss__Set_TurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOn);
	if (soap_out_dss__Set_TurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOn(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOn * SOAP_FMAC4 soap_get_dss__Set_TurnOn(struct soap *soap, struct dss__Set_TurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOn * SOAP_FMAC4 soap_in_dss__Set_TurnOn(struct soap *soap, const char *tag, struct dss__Set_TurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOn, sizeof(struct dss__Set_TurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOn, 0, sizeof(struct dss__Set_TurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOn * SOAP_FMAC6 soap_new_dss__Set_TurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOn(struct soap *soap, struct dss__Set_TurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOn * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOn;
		if (size)
			*size = sizeof(struct dss__Set_TurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOn %p -> %p\n", q, p));
	*(struct dss__Set_TurnOn*)p = *(struct dss__Set_TurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_TurnOnResponse(struct soap *soap, struct dss__Set_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_TurnOnResponse(struct soap *soap, const struct dss__Set_TurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_TurnOnResponse(struct soap *soap, const struct dss__Set_TurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_TurnOnResponse);
	if (soap_out_dss__Set_TurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_TurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_TurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_TurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_TurnOnResponse * SOAP_FMAC4 soap_get_dss__Set_TurnOnResponse(struct soap *soap, struct dss__Set_TurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_TurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_TurnOnResponse * SOAP_FMAC4 soap_in_dss__Set_TurnOnResponse(struct soap *soap, const char *tag, struct dss__Set_TurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_TurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_TurnOnResponse, sizeof(struct dss__Set_TurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_TurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_TurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_TurnOnResponse, 0, sizeof(struct dss__Set_TurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_TurnOnResponse * SOAP_FMAC6 soap_new_dss__Set_TurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_TurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_TurnOnResponse(struct soap *soap, struct dss__Set_TurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_TurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__Set_TurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_TurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_TurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_TurnOnResponse;
		if (size)
			*size = sizeof(struct dss__Set_TurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_TurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_TurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_TurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_TurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_TurnOnResponse %p -> %p\n", q, p));
	*(struct dss__Set_TurnOnResponse*)p = *(struct dss__Set_TurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetZoneIDs(struct soap *soap, struct dss__Apartment_GetZoneIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetZoneIDs(struct soap *soap, const struct dss__Apartment_GetZoneIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetZoneIDs(struct soap *soap, const struct dss__Apartment_GetZoneIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetZoneIDs);
	if (soap_out_dss__Apartment_GetZoneIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetZoneIDs(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetZoneIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetZoneIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneIDs * SOAP_FMAC4 soap_get_dss__Apartment_GetZoneIDs(struct soap *soap, struct dss__Apartment_GetZoneIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetZoneIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetZoneIDs * SOAP_FMAC4 soap_in_dss__Apartment_GetZoneIDs(struct soap *soap, const char *tag, struct dss__Apartment_GetZoneIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetZoneIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetZoneIDs, sizeof(struct dss__Apartment_GetZoneIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetZoneIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetZoneIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetZoneIDs, 0, sizeof(struct dss__Apartment_GetZoneIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetZoneIDs * SOAP_FMAC6 soap_new_dss__Apartment_GetZoneIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetZoneIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetZoneIDs(struct soap *soap, struct dss__Apartment_GetZoneIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneIDs * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetZoneIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetZoneIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetZoneIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneIDs;
		if (size)
			*size = sizeof(struct dss__Apartment_GetZoneIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetZoneIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetZoneIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetZoneIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetZoneIDs %p -> %p\n", q, p));
	*(struct dss__Apartment_GetZoneIDs*)p = *(struct dss__Apartment_GetZoneIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetZoneIDsResponse(struct soap *soap, struct dss__Apartment_GetZoneIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfint(soap, &a->zoneIDs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetZoneIDsResponse(struct soap *soap, const struct dss__Apartment_GetZoneIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->zoneIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetZoneIDsResponse(struct soap *soap, const struct dss__Apartment_GetZoneIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetZoneIDsResponse);
	if (soap_out_dss__Apartment_GetZoneIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetZoneIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetZoneIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetZoneIDsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "zoneIDs", -1, &a->zoneIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneIDsResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetZoneIDsResponse(struct soap *soap, struct dss__Apartment_GetZoneIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetZoneIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetZoneIDsResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetZoneIDsResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetZoneIDsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetZoneIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetZoneIDsResponse, sizeof(struct dss__Apartment_GetZoneIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetZoneIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "zoneIDs", &a->zoneIDs, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetZoneIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetZoneIDsResponse, 0, sizeof(struct dss__Apartment_GetZoneIDsResponse), 0, soap_copy_dss__Apartment_GetZoneIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetZoneIDsResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetZoneIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetZoneIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetZoneIDsResponse(struct soap *soap, struct dss__Apartment_GetZoneIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneIDsResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetZoneIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetZoneIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetZoneIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneIDsResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetZoneIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetZoneIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetZoneIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetZoneIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetZoneIDsResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetZoneIDsResponse*)p = *(struct dss__Apartment_GetZoneIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetZoneByName(struct soap *soap, struct dss__Apartment_GetZoneByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_zoneName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetZoneByName(struct soap *soap, const struct dss__Apartment_GetZoneByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_zoneName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetZoneByName(struct soap *soap, const struct dss__Apartment_GetZoneByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetZoneByName);
	if (soap_out_dss__Apartment_GetZoneByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetZoneByName(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetZoneByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetZoneByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "zoneName", -1, &a->_zoneName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneByName * SOAP_FMAC4 soap_get_dss__Apartment_GetZoneByName(struct soap *soap, struct dss__Apartment_GetZoneByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetZoneByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetZoneByName * SOAP_FMAC4 soap_in_dss__Apartment_GetZoneByName(struct soap *soap, const char *tag, struct dss__Apartment_GetZoneByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetZoneByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetZoneByName, sizeof(struct dss__Apartment_GetZoneByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetZoneByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_zoneName, "xsd:string"))
				{	soap_flag__zoneName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetZoneByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetZoneByName, 0, sizeof(struct dss__Apartment_GetZoneByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetZoneByName * SOAP_FMAC6 soap_new_dss__Apartment_GetZoneByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetZoneByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetZoneByName(struct soap *soap, struct dss__Apartment_GetZoneByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneByName * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetZoneByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetZoneByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetZoneByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneByName;
		if (size)
			*size = sizeof(struct dss__Apartment_GetZoneByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetZoneByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetZoneByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetZoneByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetZoneByName %p -> %p\n", q, p));
	*(struct dss__Apartment_GetZoneByName*)p = *(struct dss__Apartment_GetZoneByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetZoneByNameResponse(struct soap *soap, struct dss__Apartment_GetZoneByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetZoneByNameResponse(struct soap *soap, const struct dss__Apartment_GetZoneByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetZoneByNameResponse(struct soap *soap, const struct dss__Apartment_GetZoneByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetZoneByNameResponse);
	if (soap_out_dss__Apartment_GetZoneByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetZoneByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetZoneByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetZoneByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneByNameResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetZoneByNameResponse(struct soap *soap, struct dss__Apartment_GetZoneByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetZoneByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetZoneByNameResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetZoneByNameResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetZoneByNameResponse *a, const char *type)
{
	short soap_flag_zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetZoneByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetZoneByNameResponse, sizeof(struct dss__Apartment_GetZoneByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetZoneByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zoneID", &a->zoneID, "xsd:int"))
				{	soap_flag_zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetZoneByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetZoneByNameResponse, 0, sizeof(struct dss__Apartment_GetZoneByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetZoneByNameResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetZoneByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetZoneByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetZoneByNameResponse(struct soap *soap, struct dss__Apartment_GetZoneByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetZoneByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetZoneByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetZoneByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetZoneByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneByNameResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetZoneByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetZoneByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetZoneByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetZoneByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetZoneByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetZoneByNameResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetZoneByNameResponse*)p = *(struct dss__Apartment_GetZoneByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetGroupByName(struct soap *soap, struct dss__Apartment_GetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetGroupByName(struct soap *soap, const struct dss__Apartment_GetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetGroupByName(struct soap *soap, const struct dss__Apartment_GetGroupByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetGroupByName);
	if (soap_out_dss__Apartment_GetGroupByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetGroupByName(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetGroupByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetGroupByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByName * SOAP_FMAC4 soap_get_dss__Apartment_GetGroupByName(struct soap *soap, struct dss__Apartment_GetGroupByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetGroupByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByName * SOAP_FMAC4 soap_in_dss__Apartment_GetGroupByName(struct soap *soap, const char *tag, struct dss__Apartment_GetGroupByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetGroupByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetGroupByName, sizeof(struct dss__Apartment_GetGroupByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetGroupByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetGroupByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetGroupByName, 0, sizeof(struct dss__Apartment_GetGroupByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetGroupByName * SOAP_FMAC6 soap_new_dss__Apartment_GetGroupByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetGroupByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetGroupByName(struct soap *soap, struct dss__Apartment_GetGroupByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByName * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetGroupByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetGroupByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetGroupByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByName;
		if (size)
			*size = sizeof(struct dss__Apartment_GetGroupByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetGroupByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetGroupByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetGroupByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetGroupByName %p -> %p\n", q, p));
	*(struct dss__Apartment_GetGroupByName*)p = *(struct dss__Apartment_GetGroupByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetGroupByNameResponse(struct soap *soap, struct dss__Apartment_GetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const struct dss__Apartment_GetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const struct dss__Apartment_GetGroupByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse);
	if (soap_out_dss__Apartment_GetGroupByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetGroupByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetGroupByNameResponse(struct soap *soap, struct dss__Apartment_GetGroupByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetGroupByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetGroupByNameResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetGroupByNameResponse *a, const char *type)
{
	short soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetGroupByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse, sizeof(struct dss__Apartment_GetGroupByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetGroupByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupID", &a->groupID, "xsd:int"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetGroupByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse, 0, sizeof(struct dss__Apartment_GetGroupByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetGroupByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetGroupByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetGroupByNameResponse(struct soap *soap, struct dss__Apartment_GetGroupByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetGroupByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetGroupByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetGroupByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetGroupByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByNameResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetGroupByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetGroupByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetGroupByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetGroupByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetGroupByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetGroupByNameResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetGroupByNameResponse*)p = *(struct dss__Apartment_GetGroupByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_GetContainedDevices(struct soap *soap, struct dss__Set_GetContainedDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_GetContainedDevices(struct soap *soap, const struct dss__Set_GetContainedDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_GetContainedDevices(struct soap *soap, const struct dss__Set_GetContainedDevices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_GetContainedDevices);
	if (soap_out_dss__Set_GetContainedDevices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_GetContainedDevices(struct soap *soap, const char *tag, int id, const struct dss__Set_GetContainedDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_GetContainedDevices), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_GetContainedDevices * SOAP_FMAC4 soap_get_dss__Set_GetContainedDevices(struct soap *soap, struct dss__Set_GetContainedDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_GetContainedDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_GetContainedDevices * SOAP_FMAC4 soap_in_dss__Set_GetContainedDevices(struct soap *soap, const char *tag, struct dss__Set_GetContainedDevices *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_GetContainedDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_GetContainedDevices, sizeof(struct dss__Set_GetContainedDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_GetContainedDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_GetContainedDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_GetContainedDevices, 0, sizeof(struct dss__Set_GetContainedDevices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_GetContainedDevices * SOAP_FMAC6 soap_new_dss__Set_GetContainedDevices(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_GetContainedDevices(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_GetContainedDevices(struct soap *soap, struct dss__Set_GetContainedDevices *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_GetContainedDevices * SOAP_FMAC4 soap_instantiate_dss__Set_GetContainedDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_GetContainedDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_GetContainedDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_GetContainedDevices;
		if (size)
			*size = sizeof(struct dss__Set_GetContainedDevices);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_GetContainedDevices[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_GetContainedDevices);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_GetContainedDevices*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_GetContainedDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_GetContainedDevices %p -> %p\n", q, p));
	*(struct dss__Set_GetContainedDevices*)p = *(struct dss__Set_GetContainedDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_GetContainedDevicesResponse(struct soap *soap, struct dss__Set_GetContainedDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfint(soap, &a->deviceIDs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_GetContainedDevicesResponse(struct soap *soap, const struct dss__Set_GetContainedDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->deviceIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_GetContainedDevicesResponse(struct soap *soap, const struct dss__Set_GetContainedDevicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_GetContainedDevicesResponse);
	if (soap_out_dss__Set_GetContainedDevicesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_GetContainedDevicesResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_GetContainedDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_GetContainedDevicesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "deviceIDs", -1, &a->deviceIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_GetContainedDevicesResponse * SOAP_FMAC4 soap_get_dss__Set_GetContainedDevicesResponse(struct soap *soap, struct dss__Set_GetContainedDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_GetContainedDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_GetContainedDevicesResponse * SOAP_FMAC4 soap_in_dss__Set_GetContainedDevicesResponse(struct soap *soap, const char *tag, struct dss__Set_GetContainedDevicesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_GetContainedDevicesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_GetContainedDevicesResponse, sizeof(struct dss__Set_GetContainedDevicesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Set_GetContainedDevicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "deviceIDs", &a->deviceIDs, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_GetContainedDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_GetContainedDevicesResponse, 0, sizeof(struct dss__Set_GetContainedDevicesResponse), 0, soap_copy_dss__Set_GetContainedDevicesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_GetContainedDevicesResponse * SOAP_FMAC6 soap_new_dss__Set_GetContainedDevicesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_GetContainedDevicesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_GetContainedDevicesResponse(struct soap *soap, struct dss__Set_GetContainedDevicesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_GetContainedDevicesResponse * SOAP_FMAC4 soap_instantiate_dss__Set_GetContainedDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_GetContainedDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_GetContainedDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_GetContainedDevicesResponse;
		if (size)
			*size = sizeof(struct dss__Set_GetContainedDevicesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_GetContainedDevicesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_GetContainedDevicesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_GetContainedDevicesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_GetContainedDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_GetContainedDevicesResponse %p -> %p\n", q, p));
	*(struct dss__Set_GetContainedDevicesResponse*)p = *(struct dss__Set_GetContainedDevicesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_ByGroup(struct soap *soap, struct dss__Set_ByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_ByGroup(struct soap *soap, const struct dss__Set_ByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_ByGroup(struct soap *soap, const struct dss__Set_ByGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_ByGroup);
	if (soap_out_dss__Set_ByGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_ByGroup(struct soap *soap, const char *tag, int id, const struct dss__Set_ByGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_ByGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_ByGroup * SOAP_FMAC4 soap_get_dss__Set_ByGroup(struct soap *soap, struct dss__Set_ByGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_ByGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_ByGroup * SOAP_FMAC4 soap_in_dss__Set_ByGroup(struct soap *soap, const char *tag, struct dss__Set_ByGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_ByGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_ByGroup, sizeof(struct dss__Set_ByGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_ByGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_ByGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_ByGroup, 0, sizeof(struct dss__Set_ByGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_ByGroup * SOAP_FMAC6 soap_new_dss__Set_ByGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_ByGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_ByGroup(struct soap *soap, struct dss__Set_ByGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_ByGroup * SOAP_FMAC4 soap_instantiate_dss__Set_ByGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_ByGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_ByGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_ByGroup;
		if (size)
			*size = sizeof(struct dss__Set_ByGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_ByGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_ByGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_ByGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_ByGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_ByGroup %p -> %p\n", q, p));
	*(struct dss__Set_ByGroup*)p = *(struct dss__Set_ByGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_ByGroupResponse(struct soap *soap, struct dss__Set_ByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_ByGroupResponse(struct soap *soap, const struct dss__Set_ByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_ByGroupResponse(struct soap *soap, const struct dss__Set_ByGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_ByGroupResponse);
	if (soap_out_dss__Set_ByGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_ByGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_ByGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_ByGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_ByGroupResponse * SOAP_FMAC4 soap_get_dss__Set_ByGroupResponse(struct soap *soap, struct dss__Set_ByGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_ByGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_ByGroupResponse * SOAP_FMAC4 soap_in_dss__Set_ByGroupResponse(struct soap *soap, const char *tag, struct dss__Set_ByGroupResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_ByGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_ByGroupResponse, sizeof(struct dss__Set_ByGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_ByGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_ByGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_ByGroupResponse, 0, sizeof(struct dss__Set_ByGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_ByGroupResponse * SOAP_FMAC6 soap_new_dss__Set_ByGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_ByGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_ByGroupResponse(struct soap *soap, struct dss__Set_ByGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_ByGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Set_ByGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_ByGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_ByGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_ByGroupResponse;
		if (size)
			*size = sizeof(struct dss__Set_ByGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_ByGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_ByGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_ByGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_ByGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_ByGroupResponse %p -> %p\n", q, p));
	*(struct dss__Set_ByGroupResponse*)p = *(struct dss__Set_ByGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Remove(struct soap *soap, struct dss__Set_Remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_setIDToRemove);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Remove(struct soap *soap, const struct dss__Set_Remove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Remove(struct soap *soap, const struct dss__Set_Remove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Remove);
	if (soap_out_dss__Set_Remove(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Remove(struct soap *soap, const char *tag, int id, const struct dss__Set_Remove *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Remove), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "setIDToRemove", -1, &a->_setIDToRemove, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Remove * SOAP_FMAC4 soap_get_dss__Set_Remove(struct soap *soap, struct dss__Set_Remove *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Remove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Remove * SOAP_FMAC4 soap_in_dss__Set_Remove(struct soap *soap, const char *tag, struct dss__Set_Remove *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__setIDToRemove = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Remove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Remove, sizeof(struct dss__Set_Remove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Remove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__setIDToRemove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setIDToRemove, "xsd:int"))
				{	soap_flag__setIDToRemove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Remove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Remove, 0, sizeof(struct dss__Set_Remove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__setIDToRemove > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Remove * SOAP_FMAC6 soap_new_dss__Set_Remove(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Remove(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Remove(struct soap *soap, struct dss__Set_Remove *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Remove * SOAP_FMAC4 soap_instantiate_dss__Set_Remove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Remove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Remove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Remove;
		if (size)
			*size = sizeof(struct dss__Set_Remove);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Remove[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Remove);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Remove*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Remove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Remove %p -> %p\n", q, p));
	*(struct dss__Set_Remove*)p = *(struct dss__Set_Remove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_RemoveResponse(struct soap *soap, struct dss__Set_RemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_RemoveResponse(struct soap *soap, const struct dss__Set_RemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_RemoveResponse(struct soap *soap, const struct dss__Set_RemoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_RemoveResponse);
	if (soap_out_dss__Set_RemoveResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_RemoveResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_RemoveResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_RemoveResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_RemoveResponse * SOAP_FMAC4 soap_get_dss__Set_RemoveResponse(struct soap *soap, struct dss__Set_RemoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_RemoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_RemoveResponse * SOAP_FMAC4 soap_in_dss__Set_RemoveResponse(struct soap *soap, const char *tag, struct dss__Set_RemoveResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_RemoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_RemoveResponse, sizeof(struct dss__Set_RemoveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_RemoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_RemoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_RemoveResponse, 0, sizeof(struct dss__Set_RemoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_RemoveResponse * SOAP_FMAC6 soap_new_dss__Set_RemoveResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_RemoveResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_RemoveResponse(struct soap *soap, struct dss__Set_RemoveResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_RemoveResponse * SOAP_FMAC4 soap_instantiate_dss__Set_RemoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_RemoveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_RemoveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_RemoveResponse;
		if (size)
			*size = sizeof(struct dss__Set_RemoveResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_RemoveResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_RemoveResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_RemoveResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_RemoveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_RemoveResponse %p -> %p\n", q, p));
	*(struct dss__Set_RemoveResponse*)p = *(struct dss__Set_RemoveResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_Combine(struct soap *soap, struct dss__Set_Combine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID1);
	soap_default_int(soap, &a->_setID2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_Combine(struct soap *soap, const struct dss__Set_Combine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_Combine(struct soap *soap, const struct dss__Set_Combine *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_Combine);
	if (soap_out_dss__Set_Combine(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_Combine(struct soap *soap, const char *tag, int id, const struct dss__Set_Combine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_Combine), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID1", -1, &a->_setID1, ""))
		return soap->error;
	if (soap_out_int(soap, "setID2", -1, &a->_setID2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_Combine * SOAP_FMAC4 soap_get_dss__Set_Combine(struct soap *soap, struct dss__Set_Combine *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_Combine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_Combine * SOAP_FMAC4 soap_in_dss__Set_Combine(struct soap *soap, const char *tag, struct dss__Set_Combine *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID1 = 1, soap_flag__setID2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_Combine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_Combine, sizeof(struct dss__Set_Combine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_Combine(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID1, "xsd:int"))
				{	soap_flag__setID1--;
					continue;
				}
			if (soap_flag__setID2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID2, "xsd:int"))
				{	soap_flag__setID2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_Combine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_Combine, 0, sizeof(struct dss__Set_Combine), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID1 > 0 || soap_flag__setID2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_Combine * SOAP_FMAC6 soap_new_dss__Set_Combine(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_Combine(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_Combine(struct soap *soap, struct dss__Set_Combine *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_Combine * SOAP_FMAC4 soap_instantiate_dss__Set_Combine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_Combine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_Combine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_Combine;
		if (size)
			*size = sizeof(struct dss__Set_Combine);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_Combine[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_Combine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_Combine*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_Combine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_Combine %p -> %p\n", q, p));
	*(struct dss__Set_Combine*)p = *(struct dss__Set_Combine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_CombineResponse(struct soap *soap, struct dss__Set_CombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_CombineResponse(struct soap *soap, const struct dss__Set_CombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_CombineResponse(struct soap *soap, const struct dss__Set_CombineResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_CombineResponse);
	if (soap_out_dss__Set_CombineResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_CombineResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_CombineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_CombineResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_CombineResponse * SOAP_FMAC4 soap_get_dss__Set_CombineResponse(struct soap *soap, struct dss__Set_CombineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_CombineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_CombineResponse * SOAP_FMAC4 soap_in_dss__Set_CombineResponse(struct soap *soap, const char *tag, struct dss__Set_CombineResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_CombineResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_CombineResponse, sizeof(struct dss__Set_CombineResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_CombineResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_CombineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_CombineResponse, 0, sizeof(struct dss__Set_CombineResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_CombineResponse * SOAP_FMAC6 soap_new_dss__Set_CombineResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_CombineResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_CombineResponse(struct soap *soap, struct dss__Set_CombineResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_CombineResponse * SOAP_FMAC4 soap_instantiate_dss__Set_CombineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_CombineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_CombineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_CombineResponse;
		if (size)
			*size = sizeof(struct dss__Set_CombineResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_CombineResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_CombineResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_CombineResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_CombineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_CombineResponse %p -> %p\n", q, p));
	*(struct dss__Set_CombineResponse*)p = *(struct dss__Set_CombineResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_RemoveDevice(struct soap *soap, struct dss__Set_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_RemoveDevice(struct soap *soap, const struct dss__Set_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_RemoveDevice(struct soap *soap, const struct dss__Set_RemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_RemoveDevice);
	if (soap_out_dss__Set_RemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_RemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__Set_RemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_RemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_RemoveDevice * SOAP_FMAC4 soap_get_dss__Set_RemoveDevice(struct soap *soap, struct dss__Set_RemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_RemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_RemoveDevice * SOAP_FMAC4 soap_in_dss__Set_RemoveDevice(struct soap *soap, const char *tag, struct dss__Set_RemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_RemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_RemoveDevice, sizeof(struct dss__Set_RemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_RemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_RemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_RemoveDevice, 0, sizeof(struct dss__Set_RemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_RemoveDevice * SOAP_FMAC6 soap_new_dss__Set_RemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_RemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_RemoveDevice(struct soap *soap, struct dss__Set_RemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_RemoveDevice * SOAP_FMAC4 soap_instantiate_dss__Set_RemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_RemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_RemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_RemoveDevice;
		if (size)
			*size = sizeof(struct dss__Set_RemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_RemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_RemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_RemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_RemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_RemoveDevice %p -> %p\n", q, p));
	*(struct dss__Set_RemoveDevice*)p = *(struct dss__Set_RemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_RemoveDeviceResponse(struct soap *soap, struct dss__Set_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_RemoveDeviceResponse(struct soap *soap, const struct dss__Set_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_RemoveDeviceResponse(struct soap *soap, const struct dss__Set_RemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_RemoveDeviceResponse);
	if (soap_out_dss__Set_RemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_RemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_RemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_RemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__Set_RemoveDeviceResponse(struct soap *soap, struct dss__Set_RemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_RemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__Set_RemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__Set_RemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_RemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_RemoveDeviceResponse, sizeof(struct dss__Set_RemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_RemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_RemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_RemoveDeviceResponse, 0, sizeof(struct dss__Set_RemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__Set_RemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_RemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_RemoveDeviceResponse(struct soap *soap, struct dss__Set_RemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_RemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Set_RemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_RemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_RemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_RemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Set_RemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_RemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_RemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_RemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_RemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_RemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Set_RemoveDeviceResponse*)p = *(struct dss__Set_RemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByID(struct soap *soap, struct dss__Set_AddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_int(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByID(struct soap *soap, const struct dss__Set_AddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByID(struct soap *soap, const struct dss__Set_AddDeviceByID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByID);
	if (soap_out_dss__Set_AddDeviceByID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByID(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByID * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByID(struct soap *soap, struct dss__Set_AddDeviceByID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByID * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByID(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByID, sizeof(struct dss__Set_AddDeviceByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_deviceID, "xsd:int"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByID, 0, sizeof(struct dss__Set_AddDeviceByID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0 || soap_flag__deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByID * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByID(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByID(struct soap *soap, struct dss__Set_AddDeviceByID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByID * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByID;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByID);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByID %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByID*)p = *(struct dss__Set_AddDeviceByID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByIDResponse(struct soap *soap, struct dss__Set_AddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByIDResponse(struct soap *soap, const struct dss__Set_AddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByIDResponse(struct soap *soap, const struct dss__Set_AddDeviceByIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByIDResponse);
	if (soap_out_dss__Set_AddDeviceByIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByIDResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByIDResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByIDResponse(struct soap *soap, struct dss__Set_AddDeviceByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByIDResponse(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByIDResponse, sizeof(struct dss__Set_AddDeviceByIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByIDResponse, 0, sizeof(struct dss__Set_AddDeviceByIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByIDResponse(struct soap *soap, struct dss__Set_AddDeviceByIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByIDResponse * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByIDResponse;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByIDResponse %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByIDResponse*)p = *(struct dss__Set_AddDeviceByIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByName(struct soap *soap, struct dss__Set_AddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByName(struct soap *soap, const struct dss__Set_AddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByName(struct soap *soap, const struct dss__Set_AddDeviceByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByName);
	if (soap_out_dss__Set_AddDeviceByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByName(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByName * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByName(struct soap *soap, struct dss__Set_AddDeviceByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByName * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByName(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByName, sizeof(struct dss__Set_AddDeviceByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByName, 0, sizeof(struct dss__Set_AddDeviceByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByName * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByName(struct soap *soap, struct dss__Set_AddDeviceByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByName * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByName;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByName %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByName*)p = *(struct dss__Set_AddDeviceByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Set_AddDeviceByNameResponse(struct soap *soap, struct dss__Set_AddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Set_AddDeviceByNameResponse(struct soap *soap, const struct dss__Set_AddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Set_AddDeviceByNameResponse(struct soap *soap, const struct dss__Set_AddDeviceByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Set_AddDeviceByNameResponse);
	if (soap_out_dss__Set_AddDeviceByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Set_AddDeviceByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Set_AddDeviceByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Set_AddDeviceByNameResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC4 soap_get_dss__Set_AddDeviceByNameResponse(struct soap *soap, struct dss__Set_AddDeviceByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Set_AddDeviceByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC4 soap_in_dss__Set_AddDeviceByNameResponse(struct soap *soap, const char *tag, struct dss__Set_AddDeviceByNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Set_AddDeviceByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Set_AddDeviceByNameResponse, sizeof(struct dss__Set_AddDeviceByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Set_AddDeviceByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Set_AddDeviceByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Set_AddDeviceByNameResponse, 0, sizeof(struct dss__Set_AddDeviceByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC6 soap_new_dss__Set_AddDeviceByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Set_AddDeviceByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Set_AddDeviceByNameResponse(struct soap *soap, struct dss__Set_AddDeviceByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Set_AddDeviceByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Set_AddDeviceByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Set_AddDeviceByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Set_AddDeviceByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByNameResponse;
		if (size)
			*size = sizeof(struct dss__Set_AddDeviceByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Set_AddDeviceByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Set_AddDeviceByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Set_AddDeviceByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Set_AddDeviceByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Set_AddDeviceByNameResponse %p -> %p\n", q, p));
	*(struct dss__Set_AddDeviceByNameResponse*)p = *(struct dss__Set_AddDeviceByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDeviceIDByName(struct soap *soap, struct dss__Apartment_GetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDeviceIDByName(struct soap *soap, const struct dss__Apartment_GetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDeviceIDByName(struct soap *soap, const struct dss__Apartment_GetDeviceIDByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDeviceIDByName);
	if (soap_out_dss__Apartment_GetDeviceIDByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDeviceIDByName(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDeviceIDByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceName", -1, &a->_deviceName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC4 soap_get_dss__Apartment_GetDeviceIDByName(struct soap *soap, struct dss__Apartment_GetDeviceIDByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDeviceIDByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC4 soap_in_dss__Apartment_GetDeviceIDByName(struct soap *soap, const char *tag, struct dss__Apartment_GetDeviceIDByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDeviceIDByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByName, sizeof(struct dss__Apartment_GetDeviceIDByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDeviceIDByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceName, "xsd:string"))
				{	soap_flag__deviceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDeviceIDByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDeviceIDByName, 0, sizeof(struct dss__Apartment_GetDeviceIDByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC6 soap_new_dss__Apartment_GetDeviceIDByName(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDeviceIDByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDeviceIDByName(struct soap *soap, struct dss__Apartment_GetDeviceIDByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByName * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDeviceIDByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDeviceIDByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDeviceIDByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByName;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDeviceIDByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDeviceIDByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDeviceIDByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDeviceIDByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDeviceIDByName %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDeviceIDByName*)p = *(struct dss__Apartment_GetDeviceIDByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, struct dss__Apartment_GetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const struct dss__Apartment_GetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const struct dss__Apartment_GetDeviceIDByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse);
	if (soap_out_dss__Apartment_GetDeviceIDByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDeviceIDByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, struct dss__Apartment_GetDeviceIDByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDeviceIDByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetDeviceIDByNameResponse *a, const char *type)
{
	short soap_flag_deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDeviceIDByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse, sizeof(struct dss__Apartment_GetDeviceIDByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDeviceIDByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deviceID", &a->deviceID, "xsd:int"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDeviceIDByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse, 0, sizeof(struct dss__Apartment_GetDeviceIDByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, struct dss__Apartment_GetDeviceIDByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDeviceIDByNameResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDeviceIDByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDeviceIDByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByNameResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDeviceIDByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDeviceIDByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDeviceIDByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDeviceIDByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDeviceIDByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDeviceIDByNameResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDeviceIDByNameResponse*)p = *(struct dss__Apartment_GetDeviceIDByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDevices(struct soap *soap, struct dss__Apartment_GetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDevices(struct soap *soap, const struct dss__Apartment_GetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDevices(struct soap *soap, const struct dss__Apartment_GetDevices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDevices);
	if (soap_out_dss__Apartment_GetDevices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDevices(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDevices), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDevices * SOAP_FMAC4 soap_get_dss__Apartment_GetDevices(struct soap *soap, struct dss__Apartment_GetDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDevices * SOAP_FMAC4 soap_in_dss__Apartment_GetDevices(struct soap *soap, const char *tag, struct dss__Apartment_GetDevices *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDevices, sizeof(struct dss__Apartment_GetDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDevices, 0, sizeof(struct dss__Apartment_GetDevices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDevices * SOAP_FMAC6 soap_new_dss__Apartment_GetDevices(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDevices(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDevices(struct soap *soap, struct dss__Apartment_GetDevices *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDevices * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevices;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDevices);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevices[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDevices);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDevices*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDevices %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDevices*)p = *(struct dss__Apartment_GetDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_GetDevicesResponse(struct soap *soap, struct dss__Apartment_GetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_GetDevicesResponse(struct soap *soap, const struct dss__Apartment_GetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_GetDevicesResponse(struct soap *soap, const struct dss__Apartment_GetDevicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_GetDevicesResponse);
	if (soap_out_dss__Apartment_GetDevicesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_GetDevicesResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_GetDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_GetDevicesResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC4 soap_get_dss__Apartment_GetDevicesResponse(struct soap *soap, struct dss__Apartment_GetDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_GetDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC4 soap_in_dss__Apartment_GetDevicesResponse(struct soap *soap, const char *tag, struct dss__Apartment_GetDevicesResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_GetDevicesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_GetDevicesResponse, sizeof(struct dss__Apartment_GetDevicesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_GetDevicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_GetDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_GetDevicesResponse, 0, sizeof(struct dss__Apartment_GetDevicesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC6 soap_new_dss__Apartment_GetDevicesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_GetDevicesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_GetDevicesResponse(struct soap *soap, struct dss__Apartment_GetDevicesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_GetDevicesResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_GetDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_GetDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_GetDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevicesResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_GetDevicesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_GetDevicesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_GetDevicesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_GetDevicesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_GetDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_GetDevicesResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_GetDevicesResponse*)p = *(struct dss__Apartment_GetDevicesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateEmptySet(struct soap *soap, struct dss__Apartment_CreateEmptySet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateEmptySet(struct soap *soap, const struct dss__Apartment_CreateEmptySet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateEmptySet(struct soap *soap, const struct dss__Apartment_CreateEmptySet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateEmptySet);
	if (soap_out_dss__Apartment_CreateEmptySet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateEmptySet(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateEmptySet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateEmptySet), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySet * SOAP_FMAC4 soap_get_dss__Apartment_CreateEmptySet(struct soap *soap, struct dss__Apartment_CreateEmptySet *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateEmptySet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySet * SOAP_FMAC4 soap_in_dss__Apartment_CreateEmptySet(struct soap *soap, const char *tag, struct dss__Apartment_CreateEmptySet *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateEmptySet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateEmptySet, sizeof(struct dss__Apartment_CreateEmptySet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateEmptySet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateEmptySet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateEmptySet, 0, sizeof(struct dss__Apartment_CreateEmptySet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateEmptySet * SOAP_FMAC6 soap_new_dss__Apartment_CreateEmptySet(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateEmptySet(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateEmptySet(struct soap *soap, struct dss__Apartment_CreateEmptySet *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySet * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateEmptySet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateEmptySet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateEmptySet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySet;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateEmptySet);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySet[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateEmptySet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateEmptySet*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateEmptySet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateEmptySet %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateEmptySet*)p = *(struct dss__Apartment_CreateEmptySet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateEmptySetResponse(struct soap *soap, struct dss__Apartment_CreateEmptySetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const struct dss__Apartment_CreateEmptySetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const struct dss__Apartment_CreateEmptySetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse);
	if (soap_out_dss__Apartment_CreateEmptySetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateEmptySetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateEmptySetResponse(struct soap *soap, struct dss__Apartment_CreateEmptySetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateEmptySetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateEmptySetResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateEmptySetResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateEmptySetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse, sizeof(struct dss__Apartment_CreateEmptySetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateEmptySetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateEmptySetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse, 0, sizeof(struct dss__Apartment_CreateEmptySetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateEmptySetResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateEmptySetResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateEmptySetResponse(struct soap *soap, struct dss__Apartment_CreateEmptySetResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateEmptySetResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateEmptySetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateEmptySetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateEmptySetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySetResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateEmptySetResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateEmptySetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateEmptySetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateEmptySetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateEmptySetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateEmptySetResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateEmptySetResponse*)p = *(struct dss__Apartment_CreateEmptySetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__vectorTemplateOfstd__string(soap, &a->_names);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->_names);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNames *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames);
	if (soap_out_dss__Apartment_CreateSetFromDeviceNames(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "names", -1, &a->_names, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceNames *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames, sizeof(struct dss__Apartment_CreateSetFromDeviceNames), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, NULL, &a->_names, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceNames), 0, soap_copy_dss__Apartment_CreateSetFromDeviceNames);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNames * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNames;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceNames);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNames[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceNames);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceNames*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceNames %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceNames*)p = *(struct dss__Apartment_CreateSetFromDeviceNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceNamesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse);
	if (soap_out_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceNamesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceNamesResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceNamesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse, sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceNamesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNamesResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceNamesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceNamesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceNamesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceNamesResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceNamesResponse*)p = *(struct dss__Apartment_CreateSetFromDeviceNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__vectorTemplateOfint(soap, &a->_ids);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->_ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs);
	if (soap_out_dss__Apartment_CreateSetFromDeviceIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "ids", -1, &a->_ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceIDs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs, sizeof(struct dss__Apartment_CreateSetFromDeviceIDs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, NULL, &a->_ids, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceIDs), 0, soap_copy_dss__Apartment_CreateSetFromDeviceIDs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDs * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDs;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceIDs %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceIDs*)p = *(struct dss__Apartment_CreateSetFromDeviceIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromDeviceIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse);
	if (soap_out_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromDeviceIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromDeviceIDsResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromDeviceIDsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse, sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromDeviceIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse, 0, sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__Apartment_CreateSetFromDeviceIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromDeviceIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromDeviceIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDsResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromDeviceIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromDeviceIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromDeviceIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromDeviceIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromDeviceIDsResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromDeviceIDsResponse*)p = *(struct dss__Apartment_CreateSetFromDeviceIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromGroup(struct soap *soap, struct dss__Apartment_CreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromGroup(struct soap *soap, const struct dss__Apartment_CreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromGroup(struct soap *soap, const struct dss__Apartment_CreateSetFromGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromGroup);
	if (soap_out_dss__Apartment_CreateSetFromGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromGroup(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromGroup(struct soap *soap, struct dss__Apartment_CreateSetFromGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromGroup(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroup, sizeof(struct dss__Apartment_CreateSetFromGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromGroup, 0, sizeof(struct dss__Apartment_CreateSetFromGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromGroup(struct soap *soap, struct dss__Apartment_CreateSetFromGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroup * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroup;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromGroup %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromGroup*)p = *(struct dss__Apartment_CreateSetFromGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, struct dss__Apartment_CreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const struct dss__Apartment_CreateSetFromGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse);
	if (soap_out_dss__Apartment_CreateSetFromGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__Apartment_CreateSetFromGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC4 soap_get_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, struct dss__Apartment_CreateSetFromGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Apartment_CreateSetFromGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC4 soap_in_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, const char *tag, struct dss__Apartment_CreateSetFromGroupResponse *a, const char *type)
{
	short soap_flag_setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Apartment_CreateSetFromGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse, sizeof(struct dss__Apartment_CreateSetFromGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Apartment_CreateSetFromGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "setID", &a->setID, "xsd:int"))
				{	soap_flag_setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Apartment_CreateSetFromGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse, 0, sizeof(struct dss__Apartment_CreateSetFromGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC6 soap_new_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, struct dss__Apartment_CreateSetFromGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Apartment_CreateSetFromGroupResponse * SOAP_FMAC4 soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Apartment_CreateSetFromGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Apartment_CreateSetFromGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroupResponse;
		if (size)
			*size = sizeof(struct dss__Apartment_CreateSetFromGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Apartment_CreateSetFromGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Apartment_CreateSetFromGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Apartment_CreateSetFromGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Apartment_CreateSetFromGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Apartment_CreateSetFromGroupResponse %p -> %p\n", q, p));
	*(struct dss__Apartment_CreateSetFromGroupResponse*)p = *(struct dss__Apartment_CreateSetFromGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__FreeSet(struct soap *soap, struct dss__FreeSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_setID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__FreeSet(struct soap *soap, const struct dss__FreeSet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__FreeSet(struct soap *soap, const struct dss__FreeSet *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__FreeSet);
	if (soap_out_dss__FreeSet(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__FreeSet(struct soap *soap, const char *tag, int id, const struct dss__FreeSet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__FreeSet), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "setID", -1, &a->_setID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__FreeSet * SOAP_FMAC4 soap_get_dss__FreeSet(struct soap *soap, struct dss__FreeSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__FreeSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__FreeSet * SOAP_FMAC4 soap_in_dss__FreeSet(struct soap *soap, const char *tag, struct dss__FreeSet *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__FreeSet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__FreeSet, sizeof(struct dss__FreeSet), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__FreeSet(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_setID, "xsd:int"))
				{	soap_flag__setID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__FreeSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__FreeSet, 0, sizeof(struct dss__FreeSet), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__setID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__FreeSet * SOAP_FMAC6 soap_new_dss__FreeSet(struct soap *soap, int n)
{	return soap_instantiate_dss__FreeSet(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__FreeSet(struct soap *soap, struct dss__FreeSet *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__FreeSet * SOAP_FMAC4 soap_instantiate_dss__FreeSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__FreeSet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__FreeSet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__FreeSet;
		if (size)
			*size = sizeof(struct dss__FreeSet);
	}
	else
	{	cp->ptr = (void*)new struct dss__FreeSet[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__FreeSet);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__FreeSet*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__FreeSet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__FreeSet %p -> %p\n", q, p));
	*(struct dss__FreeSet*)p = *(struct dss__FreeSet*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__FreeSetResponse(struct soap *soap, struct dss__FreeSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__FreeSetResponse(struct soap *soap, const struct dss__FreeSetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__FreeSetResponse(struct soap *soap, const struct dss__FreeSetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__FreeSetResponse);
	if (soap_out_dss__FreeSetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__FreeSetResponse(struct soap *soap, const char *tag, int id, const struct dss__FreeSetResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__FreeSetResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__FreeSetResponse * SOAP_FMAC4 soap_get_dss__FreeSetResponse(struct soap *soap, struct dss__FreeSetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__FreeSetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__FreeSetResponse * SOAP_FMAC4 soap_in_dss__FreeSetResponse(struct soap *soap, const char *tag, struct dss__FreeSetResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__FreeSetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__FreeSetResponse, sizeof(struct dss__FreeSetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__FreeSetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__FreeSetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__FreeSetResponse, 0, sizeof(struct dss__FreeSetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__FreeSetResponse * SOAP_FMAC6 soap_new_dss__FreeSetResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__FreeSetResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__FreeSetResponse(struct soap *soap, struct dss__FreeSetResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__FreeSetResponse * SOAP_FMAC4 soap_instantiate_dss__FreeSetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__FreeSetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__FreeSetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__FreeSetResponse;
		if (size)
			*size = sizeof(struct dss__FreeSetResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__FreeSetResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__FreeSetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__FreeSetResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__FreeSetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__FreeSetResponse %p -> %p\n", q, p));
	*(struct dss__FreeSetResponse*)p = *(struct dss__FreeSetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOff(struct soap *soap, struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOff(struct soap *soap, const struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOff(struct soap *soap, const struct dss__SignOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOff);
	if (soap_out_dss__SignOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOff(struct soap *soap, const char *tag, int id, const struct dss__SignOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_get_dss__SignOff(struct soap *soap, struct dss__SignOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_in_dss__SignOff(struct soap *soap, const char *tag, struct dss__SignOff *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOff, sizeof(struct dss__SignOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOff, 0, sizeof(struct dss__SignOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SignOff * SOAP_FMAC6 soap_new_dss__SignOff(struct soap *soap, int n)
{	return soap_instantiate_dss__SignOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SignOff(struct soap *soap, struct dss__SignOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_instantiate_dss__SignOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SignOff;
		if (size)
			*size = sizeof(struct dss__SignOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__SignOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOff %p -> %p\n", q, p));
	*(struct dss__SignOff*)p = *(struct dss__SignOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOffResponse);
	if (soap_out_dss__SignOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOffResponse(struct soap *soap, const char *tag, int id, const struct dss__SignOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOffResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_get_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_in_dss__SignOffResponse(struct soap *soap, const char *tag, struct dss__SignOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOffResponse, sizeof(struct dss__SignOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOffResponse, 0, sizeof(struct dss__SignOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SignOffResponse * SOAP_FMAC6 soap_new_dss__SignOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SignOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_instantiate_dss__SignOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SignOffResponse;
		if (size)
			*size = sizeof(struct dss__SignOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SignOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOffResponse %p -> %p\n", q, p));
	*(struct dss__SignOffResponse*)p = *(struct dss__SignOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Authenticate(struct soap *soap, struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_userName);
	soap_default_string(soap, &a->_password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_userName);
	soap_serialize_string(soap, &a->_password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Authenticate);
	if (soap_out_dss__Authenticate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Authenticate(struct soap *soap, const char *tag, int id, const struct dss__Authenticate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Authenticate), type))
		return soap->error;
	if (soap_out_string(soap, "userName", -1, &a->_userName, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->_password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_get_dss__Authenticate(struct soap *soap, struct dss__Authenticate *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Authenticate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_in_dss__Authenticate(struct soap *soap, const char *tag, struct dss__Authenticate *a, const char *type)
{
	short soap_flag__userName = 1, soap_flag__password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Authenticate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Authenticate, sizeof(struct dss__Authenticate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Authenticate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__userName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_userName, "xsd:string"))
				{	soap_flag__userName--;
					continue;
				}
			if (soap_flag__password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_password, "xsd:string"))
				{	soap_flag__password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Authenticate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Authenticate, 0, sizeof(struct dss__Authenticate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Authenticate * SOAP_FMAC6 soap_new_dss__Authenticate(struct soap *soap, int n)
{	return soap_instantiate_dss__Authenticate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Authenticate(struct soap *soap, struct dss__Authenticate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_instantiate_dss__Authenticate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Authenticate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Authenticate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Authenticate;
		if (size)
			*size = sizeof(struct dss__Authenticate);
	}
	else
	{	cp->ptr = (void*)new struct dss__Authenticate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Authenticate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Authenticate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Authenticate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Authenticate %p -> %p\n", q, p));
	*(struct dss__Authenticate*)p = *(struct dss__Authenticate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__AuthenticateResponse);
	if (soap_out_dss__AuthenticateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__AuthenticateResponse(struct soap *soap, const char *tag, int id, const struct dss__AuthenticateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__AuthenticateResponse), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_get_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__AuthenticateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_in_dss__AuthenticateResponse(struct soap *soap, const char *tag, struct dss__AuthenticateResponse *a, const char *type)
{
	short soap_flag_token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__AuthenticateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__AuthenticateResponse, sizeof(struct dss__AuthenticateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__AuthenticateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "token", &a->token, "xsd:int"))
				{	soap_flag_token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__AuthenticateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__AuthenticateResponse, 0, sizeof(struct dss__AuthenticateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__AuthenticateResponse * SOAP_FMAC6 soap_new_dss__AuthenticateResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__AuthenticateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_instantiate_dss__AuthenticateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__AuthenticateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__AuthenticateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__AuthenticateResponse;
		if (size)
			*size = sizeof(struct dss__AuthenticateResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__AuthenticateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__AuthenticateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__AuthenticateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__AuthenticateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__AuthenticateResponse %p -> %p\n", q, p));
	*(struct dss__AuthenticateResponse*)p = *(struct dss__AuthenticateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Test(struct soap *soap, struct dss__Test *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->bla);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Test(struct soap *soap, const struct dss__Test *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->bla);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Test(struct soap *soap, const struct dss__Test *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Test);
	if (soap_out_dss__Test(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Test(struct soap *soap, const char *tag, int id, const struct dss__Test *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Test), type))
		return soap->error;
	if (soap_out_string(soap, "bla", -1, &a->bla, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Test * SOAP_FMAC4 soap_get_dss__Test(struct soap *soap, struct dss__Test *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Test(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Test * SOAP_FMAC4 soap_in_dss__Test(struct soap *soap, const char *tag, struct dss__Test *a, const char *type)
{
	short soap_flag_bla = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Test *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Test, sizeof(struct dss__Test), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Test(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bla && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bla", &a->bla, "xsd:string"))
				{	soap_flag_bla--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Test *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Test, 0, sizeof(struct dss__Test), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Test * SOAP_FMAC6 soap_new_dss__Test(struct soap *soap, int n)
{	return soap_instantiate_dss__Test(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Test(struct soap *soap, struct dss__Test *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Test * SOAP_FMAC4 soap_instantiate_dss__Test(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Test(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Test, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Test;
		if (size)
			*size = sizeof(struct dss__Test);
	}
	else
	{	cp->ptr = (void*)new struct dss__Test[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Test);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Test*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Test(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Test %p -> %p\n", q, p));
	*(struct dss__Test*)p = *(struct dss__Test*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__TestResponse(struct soap *soap, struct dss__TestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfint(soap, &a->ints);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__TestResponse(struct soap *soap, const struct dss__TestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->ints);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__TestResponse(struct soap *soap, const struct dss__TestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__TestResponse);
	if (soap_out_dss__TestResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__TestResponse(struct soap *soap, const char *tag, int id, const struct dss__TestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__TestResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "ints", -1, &a->ints, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__TestResponse * SOAP_FMAC4 soap_get_dss__TestResponse(struct soap *soap, struct dss__TestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__TestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__TestResponse * SOAP_FMAC4 soap_in_dss__TestResponse(struct soap *soap, const char *tag, struct dss__TestResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__TestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__TestResponse, sizeof(struct dss__TestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__TestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "ints", &a->ints, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__TestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__TestResponse, 0, sizeof(struct dss__TestResponse), 0, soap_copy_dss__TestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__TestResponse * SOAP_FMAC6 soap_new_dss__TestResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__TestResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__TestResponse(struct soap *soap, struct dss__TestResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__TestResponse * SOAP_FMAC4 soap_instantiate_dss__TestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__TestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__TestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__TestResponse;
		if (size)
			*size = sizeof(struct dss__TestResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__TestResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__TestResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__TestResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__TestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__TestResponse %p -> %p\n", q, p));
	*(struct dss__TestResponse*)p = *(struct dss__TestResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfint(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<int >;
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

/* End of soapC.cpp */
