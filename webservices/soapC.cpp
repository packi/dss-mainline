/* soapC.cpp
   Generated by gSOAP 2.7.15 from model_soap.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.15 2010-12-03 15:42:46 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_dss__Event:
		return soap_in_dss__Event(soap, NULL, NULL, "dss:Event");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_dss__StructureAddDeviceToZone:
		return soap_in_dss__StructureAddDeviceToZone(soap, NULL, NULL, "dss:StructureAddDeviceToZone");
	case SOAP_TYPE_dss__StructureAddDeviceToZoneResponse:
		return soap_in_dss__StructureAddDeviceToZoneResponse(soap, NULL, NULL, "dss:StructureAddDeviceToZoneResponse");
	case SOAP_TYPE_dss__PropertyGetChildren:
		return soap_in_dss__PropertyGetChildren(soap, NULL, NULL, "dss:PropertyGetChildren");
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		return soap_in_dss__PropertyGetChildrenResponse(soap, NULL, NULL, "dss:PropertyGetChildrenResponse");
	case SOAP_TYPE_dss__PropertyGetBool:
		return soap_in_dss__PropertyGetBool(soap, NULL, NULL, "dss:PropertyGetBool");
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		return soap_in_dss__PropertyGetBoolResponse(soap, NULL, NULL, "dss:PropertyGetBoolResponse");
	case SOAP_TYPE_dss__PropertyGetString:
		return soap_in_dss__PropertyGetString(soap, NULL, NULL, "dss:PropertyGetString");
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		return soap_in_dss__PropertyGetStringResponse(soap, NULL, NULL, "dss:PropertyGetStringResponse");
	case SOAP_TYPE_dss__PropertyGetInt:
		return soap_in_dss__PropertyGetInt(soap, NULL, NULL, "dss:PropertyGetInt");
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		return soap_in_dss__PropertyGetIntResponse(soap, NULL, NULL, "dss:PropertyGetIntResponse");
	case SOAP_TYPE_dss__PropertySetBool:
		return soap_in_dss__PropertySetBool(soap, NULL, NULL, "dss:PropertySetBool");
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		return soap_in_dss__PropertySetBoolResponse(soap, NULL, NULL, "dss:PropertySetBoolResponse");
	case SOAP_TYPE_dss__PropertySetString:
		return soap_in_dss__PropertySetString(soap, NULL, NULL, "dss:PropertySetString");
	case SOAP_TYPE_dss__PropertySetStringResponse:
		return soap_in_dss__PropertySetStringResponse(soap, NULL, NULL, "dss:PropertySetStringResponse");
	case SOAP_TYPE_dss__PropertySetInt:
		return soap_in_dss__PropertySetInt(soap, NULL, NULL, "dss:PropertySetInt");
	case SOAP_TYPE_dss__PropertySetIntResponse:
		return soap_in_dss__PropertySetIntResponse(soap, NULL, NULL, "dss:PropertySetIntResponse");
	case SOAP_TYPE_dss__PropertyGetType:
		return soap_in_dss__PropertyGetType(soap, NULL, NULL, "dss:PropertyGetType");
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		return soap_in_dss__PropertyGetTypeResponse(soap, NULL, NULL, "dss:PropertyGetTypeResponse");
	case SOAP_TYPE_dss__EventSubscribeTo:
		return soap_in_dss__EventSubscribeTo(soap, NULL, NULL, "dss:EventSubscribeTo");
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		return soap_in_dss__EventSubscribeToResponse(soap, NULL, NULL, "dss:EventSubscribeToResponse");
	case SOAP_TYPE_dss__EventWaitFor:
		return soap_in_dss__EventWaitFor(soap, NULL, NULL, "dss:EventWaitFor");
	case SOAP_TYPE_dss__EventWaitForResponse:
		return soap_in_dss__EventWaitForResponse(soap, NULL, NULL, "dss:EventWaitForResponse");
	case SOAP_TYPE_dss__EventRaise:
		return soap_in_dss__EventRaise(soap, NULL, NULL, "dss:EventRaise");
	case SOAP_TYPE_dss__EventRaiseResponse:
		return soap_in_dss__EventRaiseResponse(soap, NULL, NULL, "dss:EventRaiseResponse");
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		return soap_in_dss__DeviceGetFunctionID(soap, NULL, NULL, "dss:DeviceGetFunctionID");
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		return soap_in_dss__DeviceGetFunctionIDResponse(soap, NULL, NULL, "dss:DeviceGetFunctionIDResponse");
	case SOAP_TYPE_dss__GroupGetName:
		return soap_in_dss__GroupGetName(soap, NULL, NULL, "dss:GroupGetName");
	case SOAP_TYPE_dss__GroupGetNameResponse:
		return soap_in_dss__GroupGetNameResponse(soap, NULL, NULL, "dss:GroupGetNameResponse");
	case SOAP_TYPE_dss__GroupSetName:
		return soap_in_dss__GroupSetName(soap, NULL, NULL, "dss:GroupSetName");
	case SOAP_TYPE_dss__GroupSetNameResponse:
		return soap_in_dss__GroupSetNameResponse(soap, NULL, NULL, "dss:GroupSetNameResponse");
	case SOAP_TYPE_dss__ZoneGetName:
		return soap_in_dss__ZoneGetName(soap, NULL, NULL, "dss:ZoneGetName");
	case SOAP_TYPE_dss__ZoneGetNameResponse:
		return soap_in_dss__ZoneGetNameResponse(soap, NULL, NULL, "dss:ZoneGetNameResponse");
	case SOAP_TYPE_dss__ZoneSetName:
		return soap_in_dss__ZoneSetName(soap, NULL, NULL, "dss:ZoneSetName");
	case SOAP_TYPE_dss__ZoneSetNameResponse:
		return soap_in_dss__ZoneSetNameResponse(soap, NULL, NULL, "dss:ZoneSetNameResponse");
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		return soap_in_dss__ApartmentDeleteZone(soap, NULL, NULL, "dss:ApartmentDeleteZone");
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		return soap_in_dss__ApartmentDeleteZoneResponse(soap, NULL, NULL, "dss:ApartmentDeleteZoneResponse");
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		return soap_in_dss__ApartmentAllocateZone(soap, NULL, NULL, "dss:ApartmentAllocateZone");
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		return soap_in_dss__ApartmentAllocateZoneResponse(soap, NULL, NULL, "dss:ApartmentAllocateZoneResponse");
	case SOAP_TYPE_dss__DSMeterSetName:
		return soap_in_dss__DSMeterSetName(soap, NULL, NULL, "dss:DSMeterSetName");
	case SOAP_TYPE_dss__DSMeterSetNameResponse:
		return soap_in_dss__DSMeterSetNameResponse(soap, NULL, NULL, "dss:DSMeterSetNameResponse");
	case SOAP_TYPE_dss__DSMeterGetName:
		return soap_in_dss__DSMeterGetName(soap, NULL, NULL, "dss:DSMeterGetName");
	case SOAP_TYPE_dss__DSMeterGetNameResponse:
		return soap_in_dss__DSMeterGetNameResponse(soap, NULL, NULL, "dss:DSMeterGetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDs:
		return soap_in_dss__ApartmentGetDSMeterIDs(soap, NULL, NULL, "dss:ApartmentGetDSMeterIDs");
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse:
		return soap_in_dss__ApartmentGetDSMeterIDsResponse(soap, NULL, NULL, "dss:ApartmentGetDSMeterIDsResponse");
	case SOAP_TYPE_dss__DSMeterGetPowerConsumption:
		return soap_in_dss__DSMeterGetPowerConsumption(soap, NULL, NULL, "dss:DSMeterGetPowerConsumption");
	case SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse:
		return soap_in_dss__DSMeterGetPowerConsumptionResponse(soap, NULL, NULL, "dss:DSMeterGetPowerConsumptionResponse");
	case SOAP_TYPE_dss__DeviceGetIsLocked:
		return soap_in_dss__DeviceGetIsLocked(soap, NULL, NULL, "dss:DeviceGetIsLocked");
	case SOAP_TYPE_dss__DeviceGetIsLockedResponse:
		return soap_in_dss__DeviceGetIsLockedResponse(soap, NULL, NULL, "dss:DeviceGetIsLockedResponse");
	case SOAP_TYPE_dss__DeviceUnlock:
		return soap_in_dss__DeviceUnlock(soap, NULL, NULL, "dss:DeviceUnlock");
	case SOAP_TYPE_dss__DeviceUnlockResponse:
		return soap_in_dss__DeviceUnlockResponse(soap, NULL, NULL, "dss:DeviceUnlockResponse");
	case SOAP_TYPE_dss__DeviceLock:
		return soap_in_dss__DeviceLock(soap, NULL, NULL, "dss:DeviceLock");
	case SOAP_TYPE_dss__DeviceLockResponse:
		return soap_in_dss__DeviceLockResponse(soap, NULL, NULL, "dss:DeviceLockResponse");
	case SOAP_TYPE_dss__DeviceGetTags:
		return soap_in_dss__DeviceGetTags(soap, NULL, NULL, "dss:DeviceGetTags");
	case SOAP_TYPE_dss__DeviceGetTagsResponse:
		return soap_in_dss__DeviceGetTagsResponse(soap, NULL, NULL, "dss:DeviceGetTagsResponse");
	case SOAP_TYPE_dss__DeviceHasTag:
		return soap_in_dss__DeviceHasTag(soap, NULL, NULL, "dss:DeviceHasTag");
	case SOAP_TYPE_dss__DeviceHasTagResponse:
		return soap_in_dss__DeviceHasTagResponse(soap, NULL, NULL, "dss:DeviceHasTagResponse");
	case SOAP_TYPE_dss__DeviceRemoveTag:
		return soap_in_dss__DeviceRemoveTag(soap, NULL, NULL, "dss:DeviceRemoveTag");
	case SOAP_TYPE_dss__DeviceRemoveTagResponse:
		return soap_in_dss__DeviceRemoveTagResponse(soap, NULL, NULL, "dss:DeviceRemoveTagResponse");
	case SOAP_TYPE_dss__DeviceAddTag:
		return soap_in_dss__DeviceAddTag(soap, NULL, NULL, "dss:DeviceAddTag");
	case SOAP_TYPE_dss__DeviceAddTagResponse:
		return soap_in_dss__DeviceAddTagResponse(soap, NULL, NULL, "dss:DeviceAddTagResponse");
	case SOAP_TYPE_dss__DeviceGetZoneID:
		return soap_in_dss__DeviceGetZoneID(soap, NULL, NULL, "dss:DeviceGetZoneID");
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		return soap_in_dss__DeviceGetZoneIDResponse(soap, NULL, NULL, "dss:DeviceGetZoneIDResponse");
	case SOAP_TYPE_dss__DeviceSetName:
		return soap_in_dss__DeviceSetName(soap, NULL, NULL, "dss:DeviceSetName");
	case SOAP_TYPE_dss__DeviceSetNameResponse:
		return soap_in_dss__DeviceSetNameResponse(soap, NULL, NULL, "dss:DeviceSetNameResponse");
	case SOAP_TYPE_dss__DeviceGetName:
		return soap_in_dss__DeviceGetName(soap, NULL, NULL, "dss:DeviceGetName");
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		return soap_in_dss__DeviceGetNameResponse(soap, NULL, NULL, "dss:DeviceGetNameResponse");
	case SOAP_TYPE_dss__DeviceSaveScene:
		return soap_in_dss__DeviceSaveScene(soap, NULL, NULL, "dss:DeviceSaveScene");
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		return soap_in_dss__DeviceSaveSceneResponse(soap, NULL, NULL, "dss:DeviceSaveSceneResponse");
	case SOAP_TYPE_dss__DeviceCallScene:
		return soap_in_dss__DeviceCallScene(soap, NULL, NULL, "dss:DeviceCallScene");
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		return soap_in_dss__DeviceCallSceneResponse(soap, NULL, NULL, "dss:DeviceCallSceneResponse");
	case SOAP_TYPE_dss__DeviceGetConfigWord:
		return soap_in_dss__DeviceGetConfigWord(soap, NULL, NULL, "dss:DeviceGetConfigWord");
	case SOAP_TYPE_dss__DeviceGetConfigWordResponse:
		return soap_in_dss__DeviceGetConfigWordResponse(soap, NULL, NULL, "dss:DeviceGetConfigWordResponse");
	case SOAP_TYPE_dss__DeviceGetConfig:
		return soap_in_dss__DeviceGetConfig(soap, NULL, NULL, "dss:DeviceGetConfig");
	case SOAP_TYPE_dss__DeviceGetConfigResponse:
		return soap_in_dss__DeviceGetConfigResponse(soap, NULL, NULL, "dss:DeviceGetConfigResponse");
	case SOAP_TYPE_dss__DeviceSetConfig:
		return soap_in_dss__DeviceSetConfig(soap, NULL, NULL, "dss:DeviceSetConfig");
	case SOAP_TYPE_dss__DeviceSetConfigResponse:
		return soap_in_dss__DeviceSetConfigResponse(soap, NULL, NULL, "dss:DeviceSetConfigResponse");
	case SOAP_TYPE_dss__DeviceSetValue:
		return soap_in_dss__DeviceSetValue(soap, NULL, NULL, "dss:DeviceSetValue");
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		return soap_in_dss__DeviceSetValueResponse(soap, NULL, NULL, "dss:DeviceSetValueResponse");
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		return soap_in_dss__DeviceDecreaseValue(soap, NULL, NULL, "dss:DeviceDecreaseValue");
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		return soap_in_dss__DeviceDecreaseValueResponse(soap, NULL, NULL, "dss:DeviceDecreaseValueResponse");
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		return soap_in_dss__DeviceIncreaseValue(soap, NULL, NULL, "dss:DeviceIncreaseValue");
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		return soap_in_dss__DeviceIncreaseValueResponse(soap, NULL, NULL, "dss:DeviceIncreaseValueResponse");
	case SOAP_TYPE_dss__DeviceTurnOff:
		return soap_in_dss__DeviceTurnOff(soap, NULL, NULL, "dss:DeviceTurnOff");
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		return soap_in_dss__DeviceTurnOffResponse(soap, NULL, NULL, "dss:DeviceTurnOffResponse");
	case SOAP_TYPE_dss__DeviceTurnOn:
		return soap_in_dss__DeviceTurnOn(soap, NULL, NULL, "dss:DeviceTurnOn");
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		return soap_in_dss__DeviceTurnOnResponse(soap, NULL, NULL, "dss:DeviceTurnOnResponse");
	case SOAP_TYPE_dss__ZoneSaveScene:
		return soap_in_dss__ZoneSaveScene(soap, NULL, NULL, "dss:ZoneSaveScene");
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		return soap_in_dss__ZoneSaveSceneResponse(soap, NULL, NULL, "dss:ZoneSaveSceneResponse");
	case SOAP_TYPE_dss__ZoneCallScene:
		return soap_in_dss__ZoneCallScene(soap, NULL, NULL, "dss:ZoneCallScene");
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		return soap_in_dss__ZoneCallSceneResponse(soap, NULL, NULL, "dss:ZoneCallSceneResponse");
	case SOAP_TYPE_dss__ZoneSetValue:
		return soap_in_dss__ZoneSetValue(soap, NULL, NULL, "dss:ZoneSetValue");
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		return soap_in_dss__ZoneSetValueResponse(soap, NULL, NULL, "dss:ZoneSetValueResponse");
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		return soap_in_dss__ZoneDecreaseValue(soap, NULL, NULL, "dss:ZoneDecreaseValue");
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		return soap_in_dss__ZoneDecreaseValueResponse(soap, NULL, NULL, "dss:ZoneDecreaseValueResponse");
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		return soap_in_dss__ZoneIncreaseValue(soap, NULL, NULL, "dss:ZoneIncreaseValue");
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		return soap_in_dss__ZoneIncreaseValueResponse(soap, NULL, NULL, "dss:ZoneIncreaseValueResponse");
	case SOAP_TYPE_dss__ZoneTurnOff:
		return soap_in_dss__ZoneTurnOff(soap, NULL, NULL, "dss:ZoneTurnOff");
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		return soap_in_dss__ZoneTurnOffResponse(soap, NULL, NULL, "dss:ZoneTurnOffResponse");
	case SOAP_TYPE_dss__ZoneTurnOn:
		return soap_in_dss__ZoneTurnOn(soap, NULL, NULL, "dss:ZoneTurnOn");
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		return soap_in_dss__ZoneTurnOnResponse(soap, NULL, NULL, "dss:ZoneTurnOnResponse");
	case SOAP_TYPE_dss__CircuitRescan:
		return soap_in_dss__CircuitRescan(soap, NULL, NULL, "dss:CircuitRescan");
	case SOAP_TYPE_dss__CircuitRescanResponse:
		return soap_in_dss__CircuitRescanResponse(soap, NULL, NULL, "dss:CircuitRescanResponse");
	case SOAP_TYPE_dss__ApartmentRescan:
		return soap_in_dss__ApartmentRescan(soap, NULL, NULL, "dss:ApartmentRescan");
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		return soap_in_dss__ApartmentRescanResponse(soap, NULL, NULL, "dss:ApartmentRescanResponse");
	case SOAP_TYPE_dss__ApartmentSaveScene:
		return soap_in_dss__ApartmentSaveScene(soap, NULL, NULL, "dss:ApartmentSaveScene");
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		return soap_in_dss__ApartmentSaveSceneResponse(soap, NULL, NULL, "dss:ApartmentSaveSceneResponse");
	case SOAP_TYPE_dss__ApartmentCallScene:
		return soap_in_dss__ApartmentCallScene(soap, NULL, NULL, "dss:ApartmentCallScene");
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		return soap_in_dss__ApartmentCallSceneResponse(soap, NULL, NULL, "dss:ApartmentCallSceneResponse");
	case SOAP_TYPE_dss__ApartmentSetValue:
		return soap_in_dss__ApartmentSetValue(soap, NULL, NULL, "dss:ApartmentSetValue");
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		return soap_in_dss__ApartmentSetValueResponse(soap, NULL, NULL, "dss:ApartmentSetValueResponse");
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		return soap_in_dss__ApartmentDecreaseValue(soap, NULL, NULL, "dss:ApartmentDecreaseValue");
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		return soap_in_dss__ApartmentDecreaseValueResponse(soap, NULL, NULL, "dss:ApartmentDecreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		return soap_in_dss__ApartmentIncreaseValue(soap, NULL, NULL, "dss:ApartmentIncreaseValue");
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		return soap_in_dss__ApartmentIncreaseValueResponse(soap, NULL, NULL, "dss:ApartmentIncreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentTurnOff:
		return soap_in_dss__ApartmentTurnOff(soap, NULL, NULL, "dss:ApartmentTurnOff");
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		return soap_in_dss__ApartmentTurnOffResponse(soap, NULL, NULL, "dss:ApartmentTurnOffResponse");
	case SOAP_TYPE_dss__ApartmentTurnOn:
		return soap_in_dss__ApartmentTurnOn(soap, NULL, NULL, "dss:ApartmentTurnOn");
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		return soap_in_dss__ApartmentTurnOnResponse(soap, NULL, NULL, "dss:ApartmentTurnOnResponse");
	case SOAP_TYPE_dss__SetSaveScene:
		return soap_in_dss__SetSaveScene(soap, NULL, NULL, "dss:SetSaveScene");
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		return soap_in_dss__SetSaveSceneResponse(soap, NULL, NULL, "dss:SetSaveSceneResponse");
	case SOAP_TYPE_dss__SetCallScene:
		return soap_in_dss__SetCallScene(soap, NULL, NULL, "dss:SetCallScene");
	case SOAP_TYPE_dss__SetCallSceneResponse:
		return soap_in_dss__SetCallSceneResponse(soap, NULL, NULL, "dss:SetCallSceneResponse");
	case SOAP_TYPE_dss__SetSetValue:
		return soap_in_dss__SetSetValue(soap, NULL, NULL, "dss:SetSetValue");
	case SOAP_TYPE_dss__SetSetValueResponse:
		return soap_in_dss__SetSetValueResponse(soap, NULL, NULL, "dss:SetSetValueResponse");
	case SOAP_TYPE_dss__SetDecreaseValue:
		return soap_in_dss__SetDecreaseValue(soap, NULL, NULL, "dss:SetDecreaseValue");
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		return soap_in_dss__SetDecreaseValueResponse(soap, NULL, NULL, "dss:SetDecreaseValueResponse");
	case SOAP_TYPE_dss__SetIncreaseValue:
		return soap_in_dss__SetIncreaseValue(soap, NULL, NULL, "dss:SetIncreaseValue");
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		return soap_in_dss__SetIncreaseValueResponse(soap, NULL, NULL, "dss:SetIncreaseValueResponse");
	case SOAP_TYPE_dss__SetTurnOff:
		return soap_in_dss__SetTurnOff(soap, NULL, NULL, "dss:SetTurnOff");
	case SOAP_TYPE_dss__SetTurnOffResponse:
		return soap_in_dss__SetTurnOffResponse(soap, NULL, NULL, "dss:SetTurnOffResponse");
	case SOAP_TYPE_dss__SetTurnOn:
		return soap_in_dss__SetTurnOn(soap, NULL, NULL, "dss:SetTurnOn");
	case SOAP_TYPE_dss__SetTurnOnResponse:
		return soap_in_dss__SetTurnOnResponse(soap, NULL, NULL, "dss:SetTurnOnResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		return soap_in_dss__ApartmentGetZoneIDs(soap, NULL, NULL, "dss:ApartmentGetZoneIDs");
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		return soap_in_dss__ApartmentGetZoneIDsResponse(soap, NULL, NULL, "dss:ApartmentGetZoneIDsResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		return soap_in_dss__ApartmentGetZoneByName(soap, NULL, NULL, "dss:ApartmentGetZoneByName");
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		return soap_in_dss__ApartmentGetZoneByNameResponse(soap, NULL, NULL, "dss:ApartmentGetZoneByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		return soap_in_dss__ApartmentGetGroupByName(soap, NULL, NULL, "dss:ApartmentGetGroupByName");
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		return soap_in_dss__ApartmentGetGroupByNameResponse(soap, NULL, NULL, "dss:ApartmentGetGroupByNameResponse");
	case SOAP_TYPE_dss__SetGetContainedDevices:
		return soap_in_dss__SetGetContainedDevices(soap, NULL, NULL, "dss:SetGetContainedDevices");
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		return soap_in_dss__SetGetContainedDevicesResponse(soap, NULL, NULL, "dss:SetGetContainedDevicesResponse");
	case SOAP_TYPE_dss__SetByGroup:
		return soap_in_dss__SetByGroup(soap, NULL, NULL, "dss:SetByGroup");
	case SOAP_TYPE_dss__SetByGroupResponse:
		return soap_in_dss__SetByGroupResponse(soap, NULL, NULL, "dss:SetByGroupResponse");
	case SOAP_TYPE_dss__SetRemove:
		return soap_in_dss__SetRemove(soap, NULL, NULL, "dss:SetRemove");
	case SOAP_TYPE_dss__SetRemoveResponse:
		return soap_in_dss__SetRemoveResponse(soap, NULL, NULL, "dss:SetRemoveResponse");
	case SOAP_TYPE_dss__SetCombine:
		return soap_in_dss__SetCombine(soap, NULL, NULL, "dss:SetCombine");
	case SOAP_TYPE_dss__SetCombineResponse:
		return soap_in_dss__SetCombineResponse(soap, NULL, NULL, "dss:SetCombineResponse");
	case SOAP_TYPE_dss__SetRemoveDevice:
		return soap_in_dss__SetRemoveDevice(soap, NULL, NULL, "dss:SetRemoveDevice");
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		return soap_in_dss__SetRemoveDeviceResponse(soap, NULL, NULL, "dss:SetRemoveDeviceResponse");
	case SOAP_TYPE_dss__SetAddDeviceByID:
		return soap_in_dss__SetAddDeviceByID(soap, NULL, NULL, "dss:SetAddDeviceByID");
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		return soap_in_dss__SetAddDeviceByIDResponse(soap, NULL, NULL, "dss:SetAddDeviceByIDResponse");
	case SOAP_TYPE_dss__SetAddDeviceByName:
		return soap_in_dss__SetAddDeviceByName(soap, NULL, NULL, "dss:SetAddDeviceByName");
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		return soap_in_dss__SetAddDeviceByNameResponse(soap, NULL, NULL, "dss:SetAddDeviceByNameResponse");
	case SOAP_TYPE_dss__ApartmentSetName:
		return soap_in_dss__ApartmentSetName(soap, NULL, NULL, "dss:ApartmentSetName");
	case SOAP_TYPE_dss__ApartmentSetNameResponse:
		return soap_in_dss__ApartmentSetNameResponse(soap, NULL, NULL, "dss:ApartmentSetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetName:
		return soap_in_dss__ApartmentGetName(soap, NULL, NULL, "dss:ApartmentGetName");
	case SOAP_TYPE_dss__ApartmentGetNameResponse:
		return soap_in_dss__ApartmentGetNameResponse(soap, NULL, NULL, "dss:ApartmentGetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		return soap_in_dss__ApartmentGetDeviceIDByName(soap, NULL, NULL, "dss:ApartmentGetDeviceIDByName");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		return soap_in_dss__ApartmentGetDeviceIDByNameResponse(soap, NULL, NULL, "dss:ApartmentGetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDevices:
		return soap_in_dss__ApartmentGetDevices(soap, NULL, NULL, "dss:ApartmentGetDevices");
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		return soap_in_dss__ApartmentGetDevicesResponse(soap, NULL, NULL, "dss:ApartmentGetDevicesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		return soap_in_dss__ApartmentCreateSetFromDeviceNames(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceNames");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		return soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		return soap_in_dss__ApartmentCreateSetFromDeviceIDs(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		return soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		return soap_in_dss__ApartmentCreateSetFromGroup(soap, NULL, NULL, "dss:ApartmentCreateSetFromGroup");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		return soap_in_dss__ApartmentCreateSetFromGroupResponse(soap, NULL, NULL, "dss:ApartmentCreateSetFromGroupResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_in_dss__SignOff(soap, NULL, NULL, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_in_dss__SignOffResponse(soap, NULL, NULL, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_in_dss__Authenticate(soap, NULL, NULL, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, "dss:AuthenticateResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "dss:Event"))
		{	*type = SOAP_TYPE_dss__Event;
			return soap_in_dss__Event(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:StructureAddDeviceToZone"))
		{	*type = SOAP_TYPE_dss__StructureAddDeviceToZone;
			return soap_in_dss__StructureAddDeviceToZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:StructureAddDeviceToZoneResponse"))
		{	*type = SOAP_TYPE_dss__StructureAddDeviceToZoneResponse;
			return soap_in_dss__StructureAddDeviceToZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetChildren"))
		{	*type = SOAP_TYPE_dss__PropertyGetChildren;
			return soap_in_dss__PropertyGetChildren(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetChildrenResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetChildrenResponse;
			return soap_in_dss__PropertyGetChildrenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetBool"))
		{	*type = SOAP_TYPE_dss__PropertyGetBool;
			return soap_in_dss__PropertyGetBool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetBoolResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetBoolResponse;
			return soap_in_dss__PropertyGetBoolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetString"))
		{	*type = SOAP_TYPE_dss__PropertyGetString;
			return soap_in_dss__PropertyGetString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetStringResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetStringResponse;
			return soap_in_dss__PropertyGetStringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetInt"))
		{	*type = SOAP_TYPE_dss__PropertyGetInt;
			return soap_in_dss__PropertyGetInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetIntResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetIntResponse;
			return soap_in_dss__PropertyGetIntResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetBool"))
		{	*type = SOAP_TYPE_dss__PropertySetBool;
			return soap_in_dss__PropertySetBool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetBoolResponse"))
		{	*type = SOAP_TYPE_dss__PropertySetBoolResponse;
			return soap_in_dss__PropertySetBoolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetString"))
		{	*type = SOAP_TYPE_dss__PropertySetString;
			return soap_in_dss__PropertySetString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetStringResponse"))
		{	*type = SOAP_TYPE_dss__PropertySetStringResponse;
			return soap_in_dss__PropertySetStringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetInt"))
		{	*type = SOAP_TYPE_dss__PropertySetInt;
			return soap_in_dss__PropertySetInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetIntResponse"))
		{	*type = SOAP_TYPE_dss__PropertySetIntResponse;
			return soap_in_dss__PropertySetIntResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetType"))
		{	*type = SOAP_TYPE_dss__PropertyGetType;
			return soap_in_dss__PropertyGetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetTypeResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetTypeResponse;
			return soap_in_dss__PropertyGetTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventSubscribeTo"))
		{	*type = SOAP_TYPE_dss__EventSubscribeTo;
			return soap_in_dss__EventSubscribeTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventSubscribeToResponse"))
		{	*type = SOAP_TYPE_dss__EventSubscribeToResponse;
			return soap_in_dss__EventSubscribeToResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventWaitFor"))
		{	*type = SOAP_TYPE_dss__EventWaitFor;
			return soap_in_dss__EventWaitFor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventWaitForResponse"))
		{	*type = SOAP_TYPE_dss__EventWaitForResponse;
			return soap_in_dss__EventWaitForResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventRaise"))
		{	*type = SOAP_TYPE_dss__EventRaise;
			return soap_in_dss__EventRaise(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventRaiseResponse"))
		{	*type = SOAP_TYPE_dss__EventRaiseResponse;
			return soap_in_dss__EventRaiseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetFunctionID"))
		{	*type = SOAP_TYPE_dss__DeviceGetFunctionID;
			return soap_in_dss__DeviceGetFunctionID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetFunctionIDResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetFunctionIDResponse;
			return soap_in_dss__DeviceGetFunctionIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupGetName"))
		{	*type = SOAP_TYPE_dss__GroupGetName;
			return soap_in_dss__GroupGetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupGetNameResponse"))
		{	*type = SOAP_TYPE_dss__GroupGetNameResponse;
			return soap_in_dss__GroupGetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupSetName"))
		{	*type = SOAP_TYPE_dss__GroupSetName;
			return soap_in_dss__GroupSetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupSetNameResponse"))
		{	*type = SOAP_TYPE_dss__GroupSetNameResponse;
			return soap_in_dss__GroupSetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneGetName"))
		{	*type = SOAP_TYPE_dss__ZoneGetName;
			return soap_in_dss__ZoneGetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneGetNameResponse"))
		{	*type = SOAP_TYPE_dss__ZoneGetNameResponse;
			return soap_in_dss__ZoneGetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSetName"))
		{	*type = SOAP_TYPE_dss__ZoneSetName;
			return soap_in_dss__ZoneSetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSetNameResponse"))
		{	*type = SOAP_TYPE_dss__ZoneSetNameResponse;
			return soap_in_dss__ZoneSetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDeleteZone"))
		{	*type = SOAP_TYPE_dss__ApartmentDeleteZone;
			return soap_in_dss__ApartmentDeleteZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDeleteZoneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentDeleteZoneResponse;
			return soap_in_dss__ApartmentDeleteZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentAllocateZone"))
		{	*type = SOAP_TYPE_dss__ApartmentAllocateZone;
			return soap_in_dss__ApartmentAllocateZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentAllocateZoneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentAllocateZoneResponse;
			return soap_in_dss__ApartmentAllocateZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DSMeterSetName"))
		{	*type = SOAP_TYPE_dss__DSMeterSetName;
			return soap_in_dss__DSMeterSetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DSMeterSetNameResponse"))
		{	*type = SOAP_TYPE_dss__DSMeterSetNameResponse;
			return soap_in_dss__DSMeterSetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DSMeterGetName"))
		{	*type = SOAP_TYPE_dss__DSMeterGetName;
			return soap_in_dss__DSMeterGetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DSMeterGetNameResponse"))
		{	*type = SOAP_TYPE_dss__DSMeterGetNameResponse;
			return soap_in_dss__DSMeterGetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDSMeterIDs"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDSMeterIDs;
			return soap_in_dss__ApartmentGetDSMeterIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDSMeterIDsResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse;
			return soap_in_dss__ApartmentGetDSMeterIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DSMeterGetPowerConsumption"))
		{	*type = SOAP_TYPE_dss__DSMeterGetPowerConsumption;
			return soap_in_dss__DSMeterGetPowerConsumption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DSMeterGetPowerConsumptionResponse"))
		{	*type = SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse;
			return soap_in_dss__DSMeterGetPowerConsumptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetIsLocked"))
		{	*type = SOAP_TYPE_dss__DeviceGetIsLocked;
			return soap_in_dss__DeviceGetIsLocked(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetIsLockedResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetIsLockedResponse;
			return soap_in_dss__DeviceGetIsLockedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceUnlock"))
		{	*type = SOAP_TYPE_dss__DeviceUnlock;
			return soap_in_dss__DeviceUnlock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceUnlockResponse"))
		{	*type = SOAP_TYPE_dss__DeviceUnlockResponse;
			return soap_in_dss__DeviceUnlockResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceLock"))
		{	*type = SOAP_TYPE_dss__DeviceLock;
			return soap_in_dss__DeviceLock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceLockResponse"))
		{	*type = SOAP_TYPE_dss__DeviceLockResponse;
			return soap_in_dss__DeviceLockResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetTags"))
		{	*type = SOAP_TYPE_dss__DeviceGetTags;
			return soap_in_dss__DeviceGetTags(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetTagsResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetTagsResponse;
			return soap_in_dss__DeviceGetTagsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceHasTag"))
		{	*type = SOAP_TYPE_dss__DeviceHasTag;
			return soap_in_dss__DeviceHasTag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceHasTagResponse"))
		{	*type = SOAP_TYPE_dss__DeviceHasTagResponse;
			return soap_in_dss__DeviceHasTagResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceRemoveTag"))
		{	*type = SOAP_TYPE_dss__DeviceRemoveTag;
			return soap_in_dss__DeviceRemoveTag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceRemoveTagResponse"))
		{	*type = SOAP_TYPE_dss__DeviceRemoveTagResponse;
			return soap_in_dss__DeviceRemoveTagResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceAddTag"))
		{	*type = SOAP_TYPE_dss__DeviceAddTag;
			return soap_in_dss__DeviceAddTag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceAddTagResponse"))
		{	*type = SOAP_TYPE_dss__DeviceAddTagResponse;
			return soap_in_dss__DeviceAddTagResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetZoneID"))
		{	*type = SOAP_TYPE_dss__DeviceGetZoneID;
			return soap_in_dss__DeviceGetZoneID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetZoneIDResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetZoneIDResponse;
			return soap_in_dss__DeviceGetZoneIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetName"))
		{	*type = SOAP_TYPE_dss__DeviceSetName;
			return soap_in_dss__DeviceSetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetNameResponse"))
		{	*type = SOAP_TYPE_dss__DeviceSetNameResponse;
			return soap_in_dss__DeviceSetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetName"))
		{	*type = SOAP_TYPE_dss__DeviceGetName;
			return soap_in_dss__DeviceGetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetNameResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetNameResponse;
			return soap_in_dss__DeviceGetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSaveScene"))
		{	*type = SOAP_TYPE_dss__DeviceSaveScene;
			return soap_in_dss__DeviceSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__DeviceSaveSceneResponse;
			return soap_in_dss__DeviceSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceCallScene"))
		{	*type = SOAP_TYPE_dss__DeviceCallScene;
			return soap_in_dss__DeviceCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__DeviceCallSceneResponse;
			return soap_in_dss__DeviceCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetConfigWord"))
		{	*type = SOAP_TYPE_dss__DeviceGetConfigWord;
			return soap_in_dss__DeviceGetConfigWord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetConfigWordResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetConfigWordResponse;
			return soap_in_dss__DeviceGetConfigWordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetConfig"))
		{	*type = SOAP_TYPE_dss__DeviceGetConfig;
			return soap_in_dss__DeviceGetConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetConfigResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetConfigResponse;
			return soap_in_dss__DeviceGetConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetConfig"))
		{	*type = SOAP_TYPE_dss__DeviceSetConfig;
			return soap_in_dss__DeviceSetConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetConfigResponse"))
		{	*type = SOAP_TYPE_dss__DeviceSetConfigResponse;
			return soap_in_dss__DeviceSetConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetValue"))
		{	*type = SOAP_TYPE_dss__DeviceSetValue;
			return soap_in_dss__DeviceSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetValueResponse"))
		{	*type = SOAP_TYPE_dss__DeviceSetValueResponse;
			return soap_in_dss__DeviceSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceDecreaseValue"))
		{	*type = SOAP_TYPE_dss__DeviceDecreaseValue;
			return soap_in_dss__DeviceDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__DeviceDecreaseValueResponse;
			return soap_in_dss__DeviceDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceIncreaseValue"))
		{	*type = SOAP_TYPE_dss__DeviceIncreaseValue;
			return soap_in_dss__DeviceIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__DeviceIncreaseValueResponse;
			return soap_in_dss__DeviceIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOff"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOff;
			return soap_in_dss__DeviceTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOffResponse;
			return soap_in_dss__DeviceTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOn"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOn;
			return soap_in_dss__DeviceTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOnResponse;
			return soap_in_dss__DeviceTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSaveScene"))
		{	*type = SOAP_TYPE_dss__ZoneSaveScene;
			return soap_in_dss__ZoneSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__ZoneSaveSceneResponse;
			return soap_in_dss__ZoneSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneCallScene"))
		{	*type = SOAP_TYPE_dss__ZoneCallScene;
			return soap_in_dss__ZoneCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__ZoneCallSceneResponse;
			return soap_in_dss__ZoneCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSetValue"))
		{	*type = SOAP_TYPE_dss__ZoneSetValue;
			return soap_in_dss__ZoneSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSetValueResponse"))
		{	*type = SOAP_TYPE_dss__ZoneSetValueResponse;
			return soap_in_dss__ZoneSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneDecreaseValue"))
		{	*type = SOAP_TYPE_dss__ZoneDecreaseValue;
			return soap_in_dss__ZoneDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ZoneDecreaseValueResponse;
			return soap_in_dss__ZoneDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneIncreaseValue"))
		{	*type = SOAP_TYPE_dss__ZoneIncreaseValue;
			return soap_in_dss__ZoneIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ZoneIncreaseValueResponse;
			return soap_in_dss__ZoneIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOff"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOff;
			return soap_in_dss__ZoneTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOffResponse;
			return soap_in_dss__ZoneTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOn"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOn;
			return soap_in_dss__ZoneTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOnResponse;
			return soap_in_dss__ZoneTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:CircuitRescan"))
		{	*type = SOAP_TYPE_dss__CircuitRescan;
			return soap_in_dss__CircuitRescan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:CircuitRescanResponse"))
		{	*type = SOAP_TYPE_dss__CircuitRescanResponse;
			return soap_in_dss__CircuitRescanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentRescan"))
		{	*type = SOAP_TYPE_dss__ApartmentRescan;
			return soap_in_dss__ApartmentRescan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentRescanResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentRescanResponse;
			return soap_in_dss__ApartmentRescanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSaveScene"))
		{	*type = SOAP_TYPE_dss__ApartmentSaveScene;
			return soap_in_dss__ApartmentSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentSaveSceneResponse;
			return soap_in_dss__ApartmentSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCallScene"))
		{	*type = SOAP_TYPE_dss__ApartmentCallScene;
			return soap_in_dss__ApartmentCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCallSceneResponse;
			return soap_in_dss__ApartmentCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSetValue"))
		{	*type = SOAP_TYPE_dss__ApartmentSetValue;
			return soap_in_dss__ApartmentSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSetValueResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentSetValueResponse;
			return soap_in_dss__ApartmentSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDecreaseValue"))
		{	*type = SOAP_TYPE_dss__ApartmentDecreaseValue;
			return soap_in_dss__ApartmentDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentDecreaseValueResponse;
			return soap_in_dss__ApartmentDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentIncreaseValue"))
		{	*type = SOAP_TYPE_dss__ApartmentIncreaseValue;
			return soap_in_dss__ApartmentIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentIncreaseValueResponse;
			return soap_in_dss__ApartmentIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOff"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOff;
			return soap_in_dss__ApartmentTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOffResponse;
			return soap_in_dss__ApartmentTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOn"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOn;
			return soap_in_dss__ApartmentTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOnResponse;
			return soap_in_dss__ApartmentTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSaveScene"))
		{	*type = SOAP_TYPE_dss__SetSaveScene;
			return soap_in_dss__SetSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__SetSaveSceneResponse;
			return soap_in_dss__SetSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCallScene"))
		{	*type = SOAP_TYPE_dss__SetCallScene;
			return soap_in_dss__SetCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__SetCallSceneResponse;
			return soap_in_dss__SetCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSetValue"))
		{	*type = SOAP_TYPE_dss__SetSetValue;
			return soap_in_dss__SetSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSetValueResponse"))
		{	*type = SOAP_TYPE_dss__SetSetValueResponse;
			return soap_in_dss__SetSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetDecreaseValue"))
		{	*type = SOAP_TYPE_dss__SetDecreaseValue;
			return soap_in_dss__SetDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__SetDecreaseValueResponse;
			return soap_in_dss__SetDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetIncreaseValue"))
		{	*type = SOAP_TYPE_dss__SetIncreaseValue;
			return soap_in_dss__SetIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__SetIncreaseValueResponse;
			return soap_in_dss__SetIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOff"))
		{	*type = SOAP_TYPE_dss__SetTurnOff;
			return soap_in_dss__SetTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__SetTurnOffResponse;
			return soap_in_dss__SetTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOn"))
		{	*type = SOAP_TYPE_dss__SetTurnOn;
			return soap_in_dss__SetTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__SetTurnOnResponse;
			return soap_in_dss__SetTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneIDs"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneIDs;
			return soap_in_dss__ApartmentGetZoneIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneIDsResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneIDsResponse;
			return soap_in_dss__ApartmentGetZoneIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneByName"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneByName;
			return soap_in_dss__ApartmentGetZoneByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneByNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneByNameResponse;
			return soap_in_dss__ApartmentGetZoneByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetGroupByName"))
		{	*type = SOAP_TYPE_dss__ApartmentGetGroupByName;
			return soap_in_dss__ApartmentGetGroupByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetGroupByNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetGroupByNameResponse;
			return soap_in_dss__ApartmentGetGroupByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetGetContainedDevices"))
		{	*type = SOAP_TYPE_dss__SetGetContainedDevices;
			return soap_in_dss__SetGetContainedDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetGetContainedDevicesResponse"))
		{	*type = SOAP_TYPE_dss__SetGetContainedDevicesResponse;
			return soap_in_dss__SetGetContainedDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetByGroup"))
		{	*type = SOAP_TYPE_dss__SetByGroup;
			return soap_in_dss__SetByGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetByGroupResponse"))
		{	*type = SOAP_TYPE_dss__SetByGroupResponse;
			return soap_in_dss__SetByGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemove"))
		{	*type = SOAP_TYPE_dss__SetRemove;
			return soap_in_dss__SetRemove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemoveResponse"))
		{	*type = SOAP_TYPE_dss__SetRemoveResponse;
			return soap_in_dss__SetRemoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCombine"))
		{	*type = SOAP_TYPE_dss__SetCombine;
			return soap_in_dss__SetCombine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCombineResponse"))
		{	*type = SOAP_TYPE_dss__SetCombineResponse;
			return soap_in_dss__SetCombineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemoveDevice"))
		{	*type = SOAP_TYPE_dss__SetRemoveDevice;
			return soap_in_dss__SetRemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__SetRemoveDeviceResponse;
			return soap_in_dss__SetRemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByID"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByID;
			return soap_in_dss__SetAddDeviceByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByIDResponse"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByIDResponse;
			return soap_in_dss__SetAddDeviceByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByName"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByName;
			return soap_in_dss__SetAddDeviceByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByNameResponse"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByNameResponse;
			return soap_in_dss__SetAddDeviceByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSetName"))
		{	*type = SOAP_TYPE_dss__ApartmentSetName;
			return soap_in_dss__ApartmentSetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSetNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentSetNameResponse;
			return soap_in_dss__ApartmentSetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetName"))
		{	*type = SOAP_TYPE_dss__ApartmentGetName;
			return soap_in_dss__ApartmentGetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetNameResponse;
			return soap_in_dss__ApartmentGetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDeviceIDByName"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDeviceIDByName;
			return soap_in_dss__ApartmentGetDeviceIDByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDeviceIDByNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse;
			return soap_in_dss__ApartmentGetDeviceIDByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDevices"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDevices;
			return soap_in_dss__ApartmentGetDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDevicesResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDevicesResponse;
			return soap_in_dss__ApartmentGetDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceNames"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames;
			return soap_in_dss__ApartmentCreateSetFromDeviceNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceNamesResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse;
			return soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceIDs"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs;
			return soap_in_dss__ApartmentCreateSetFromDeviceIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceIDsResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse;
			return soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromGroup"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromGroup;
			return soap_in_dss__ApartmentCreateSetFromGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromGroupResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse;
			return soap_in_dss__ApartmentCreateSetFromGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOff"))
		{	*type = SOAP_TYPE_dss__SignOff;
			return soap_in_dss__SignOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOffResponse"))
		{	*type = SOAP_TYPE_dss__SignOffResponse;
			return soap_in_dss__SignOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Authenticate"))
		{	*type = SOAP_TYPE_dss__Authenticate;
			return soap_in_dss__Authenticate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:AuthenticateResponse"))
		{	*type = SOAP_TYPE_dss__AuthenticateResponse;
			return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_out_xsd__unsignedInt(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_out_xsd__unsignedLong(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_dss__Event:
		return ((dss__Event *)ptr)->soap_out(soap, tag, id, "dss:Event");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_dss__StructureAddDeviceToZone:
		return soap_out_dss__StructureAddDeviceToZone(soap, tag, id, (const struct dss__StructureAddDeviceToZone *)ptr, "dss:StructureAddDeviceToZone");
	case SOAP_TYPE_dss__StructureAddDeviceToZoneResponse:
		return soap_out_dss__StructureAddDeviceToZoneResponse(soap, tag, id, (const struct dss__StructureAddDeviceToZoneResponse *)ptr, "dss:StructureAddDeviceToZoneResponse");
	case SOAP_TYPE_dss__PropertyGetChildren:
		return soap_out_dss__PropertyGetChildren(soap, tag, id, (const struct dss__PropertyGetChildren *)ptr, "dss:PropertyGetChildren");
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		return soap_out_dss__PropertyGetChildrenResponse(soap, tag, id, (const struct dss__PropertyGetChildrenResponse *)ptr, "dss:PropertyGetChildrenResponse");
	case SOAP_TYPE_dss__PropertyGetBool:
		return soap_out_dss__PropertyGetBool(soap, tag, id, (const struct dss__PropertyGetBool *)ptr, "dss:PropertyGetBool");
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		return soap_out_dss__PropertyGetBoolResponse(soap, tag, id, (const struct dss__PropertyGetBoolResponse *)ptr, "dss:PropertyGetBoolResponse");
	case SOAP_TYPE_dss__PropertyGetString:
		return soap_out_dss__PropertyGetString(soap, tag, id, (const struct dss__PropertyGetString *)ptr, "dss:PropertyGetString");
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		return soap_out_dss__PropertyGetStringResponse(soap, tag, id, (const struct dss__PropertyGetStringResponse *)ptr, "dss:PropertyGetStringResponse");
	case SOAP_TYPE_dss__PropertyGetInt:
		return soap_out_dss__PropertyGetInt(soap, tag, id, (const struct dss__PropertyGetInt *)ptr, "dss:PropertyGetInt");
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		return soap_out_dss__PropertyGetIntResponse(soap, tag, id, (const struct dss__PropertyGetIntResponse *)ptr, "dss:PropertyGetIntResponse");
	case SOAP_TYPE_dss__PropertySetBool:
		return soap_out_dss__PropertySetBool(soap, tag, id, (const struct dss__PropertySetBool *)ptr, "dss:PropertySetBool");
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		return soap_out_dss__PropertySetBoolResponse(soap, tag, id, (const struct dss__PropertySetBoolResponse *)ptr, "dss:PropertySetBoolResponse");
	case SOAP_TYPE_dss__PropertySetString:
		return soap_out_dss__PropertySetString(soap, tag, id, (const struct dss__PropertySetString *)ptr, "dss:PropertySetString");
	case SOAP_TYPE_dss__PropertySetStringResponse:
		return soap_out_dss__PropertySetStringResponse(soap, tag, id, (const struct dss__PropertySetStringResponse *)ptr, "dss:PropertySetStringResponse");
	case SOAP_TYPE_dss__PropertySetInt:
		return soap_out_dss__PropertySetInt(soap, tag, id, (const struct dss__PropertySetInt *)ptr, "dss:PropertySetInt");
	case SOAP_TYPE_dss__PropertySetIntResponse:
		return soap_out_dss__PropertySetIntResponse(soap, tag, id, (const struct dss__PropertySetIntResponse *)ptr, "dss:PropertySetIntResponse");
	case SOAP_TYPE_dss__PropertyGetType:
		return soap_out_dss__PropertyGetType(soap, tag, id, (const struct dss__PropertyGetType *)ptr, "dss:PropertyGetType");
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		return soap_out_dss__PropertyGetTypeResponse(soap, tag, id, (const struct dss__PropertyGetTypeResponse *)ptr, "dss:PropertyGetTypeResponse");
	case SOAP_TYPE_dss__EventSubscribeTo:
		return soap_out_dss__EventSubscribeTo(soap, tag, id, (const struct dss__EventSubscribeTo *)ptr, "dss:EventSubscribeTo");
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		return soap_out_dss__EventSubscribeToResponse(soap, tag, id, (const struct dss__EventSubscribeToResponse *)ptr, "dss:EventSubscribeToResponse");
	case SOAP_TYPE_dss__EventWaitFor:
		return soap_out_dss__EventWaitFor(soap, tag, id, (const struct dss__EventWaitFor *)ptr, "dss:EventWaitFor");
	case SOAP_TYPE_dss__EventWaitForResponse:
		return soap_out_dss__EventWaitForResponse(soap, tag, id, (const struct dss__EventWaitForResponse *)ptr, "dss:EventWaitForResponse");
	case SOAP_TYPE_dss__EventRaise:
		return soap_out_dss__EventRaise(soap, tag, id, (const struct dss__EventRaise *)ptr, "dss:EventRaise");
	case SOAP_TYPE_dss__EventRaiseResponse:
		return soap_out_dss__EventRaiseResponse(soap, tag, id, (const struct dss__EventRaiseResponse *)ptr, "dss:EventRaiseResponse");
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		return soap_out_dss__DeviceGetFunctionID(soap, tag, id, (const struct dss__DeviceGetFunctionID *)ptr, "dss:DeviceGetFunctionID");
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		return soap_out_dss__DeviceGetFunctionIDResponse(soap, tag, id, (const struct dss__DeviceGetFunctionIDResponse *)ptr, "dss:DeviceGetFunctionIDResponse");
	case SOAP_TYPE_dss__GroupGetName:
		return soap_out_dss__GroupGetName(soap, tag, id, (const struct dss__GroupGetName *)ptr, "dss:GroupGetName");
	case SOAP_TYPE_dss__GroupGetNameResponse:
		return soap_out_dss__GroupGetNameResponse(soap, tag, id, (const struct dss__GroupGetNameResponse *)ptr, "dss:GroupGetNameResponse");
	case SOAP_TYPE_dss__GroupSetName:
		return soap_out_dss__GroupSetName(soap, tag, id, (const struct dss__GroupSetName *)ptr, "dss:GroupSetName");
	case SOAP_TYPE_dss__GroupSetNameResponse:
		return soap_out_dss__GroupSetNameResponse(soap, tag, id, (const struct dss__GroupSetNameResponse *)ptr, "dss:GroupSetNameResponse");
	case SOAP_TYPE_dss__ZoneGetName:
		return soap_out_dss__ZoneGetName(soap, tag, id, (const struct dss__ZoneGetName *)ptr, "dss:ZoneGetName");
	case SOAP_TYPE_dss__ZoneGetNameResponse:
		return soap_out_dss__ZoneGetNameResponse(soap, tag, id, (const struct dss__ZoneGetNameResponse *)ptr, "dss:ZoneGetNameResponse");
	case SOAP_TYPE_dss__ZoneSetName:
		return soap_out_dss__ZoneSetName(soap, tag, id, (const struct dss__ZoneSetName *)ptr, "dss:ZoneSetName");
	case SOAP_TYPE_dss__ZoneSetNameResponse:
		return soap_out_dss__ZoneSetNameResponse(soap, tag, id, (const struct dss__ZoneSetNameResponse *)ptr, "dss:ZoneSetNameResponse");
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		return soap_out_dss__ApartmentDeleteZone(soap, tag, id, (const struct dss__ApartmentDeleteZone *)ptr, "dss:ApartmentDeleteZone");
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		return soap_out_dss__ApartmentDeleteZoneResponse(soap, tag, id, (const struct dss__ApartmentDeleteZoneResponse *)ptr, "dss:ApartmentDeleteZoneResponse");
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		return soap_out_dss__ApartmentAllocateZone(soap, tag, id, (const struct dss__ApartmentAllocateZone *)ptr, "dss:ApartmentAllocateZone");
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		return soap_out_dss__ApartmentAllocateZoneResponse(soap, tag, id, (const struct dss__ApartmentAllocateZoneResponse *)ptr, "dss:ApartmentAllocateZoneResponse");
	case SOAP_TYPE_dss__DSMeterSetName:
		return soap_out_dss__DSMeterSetName(soap, tag, id, (const struct dss__DSMeterSetName *)ptr, "dss:DSMeterSetName");
	case SOAP_TYPE_dss__DSMeterSetNameResponse:
		return soap_out_dss__DSMeterSetNameResponse(soap, tag, id, (const struct dss__DSMeterSetNameResponse *)ptr, "dss:DSMeterSetNameResponse");
	case SOAP_TYPE_dss__DSMeterGetName:
		return soap_out_dss__DSMeterGetName(soap, tag, id, (const struct dss__DSMeterGetName *)ptr, "dss:DSMeterGetName");
	case SOAP_TYPE_dss__DSMeterGetNameResponse:
		return soap_out_dss__DSMeterGetNameResponse(soap, tag, id, (const struct dss__DSMeterGetNameResponse *)ptr, "dss:DSMeterGetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDs:
		return soap_out_dss__ApartmentGetDSMeterIDs(soap, tag, id, (const struct dss__ApartmentGetDSMeterIDs *)ptr, "dss:ApartmentGetDSMeterIDs");
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse:
		return soap_out_dss__ApartmentGetDSMeterIDsResponse(soap, tag, id, (const struct dss__ApartmentGetDSMeterIDsResponse *)ptr, "dss:ApartmentGetDSMeterIDsResponse");
	case SOAP_TYPE_dss__DSMeterGetPowerConsumption:
		return soap_out_dss__DSMeterGetPowerConsumption(soap, tag, id, (const struct dss__DSMeterGetPowerConsumption *)ptr, "dss:DSMeterGetPowerConsumption");
	case SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse:
		return soap_out_dss__DSMeterGetPowerConsumptionResponse(soap, tag, id, (const struct dss__DSMeterGetPowerConsumptionResponse *)ptr, "dss:DSMeterGetPowerConsumptionResponse");
	case SOAP_TYPE_dss__DeviceGetIsLocked:
		return soap_out_dss__DeviceGetIsLocked(soap, tag, id, (const struct dss__DeviceGetIsLocked *)ptr, "dss:DeviceGetIsLocked");
	case SOAP_TYPE_dss__DeviceGetIsLockedResponse:
		return soap_out_dss__DeviceGetIsLockedResponse(soap, tag, id, (const struct dss__DeviceGetIsLockedResponse *)ptr, "dss:DeviceGetIsLockedResponse");
	case SOAP_TYPE_dss__DeviceUnlock:
		return soap_out_dss__DeviceUnlock(soap, tag, id, (const struct dss__DeviceUnlock *)ptr, "dss:DeviceUnlock");
	case SOAP_TYPE_dss__DeviceUnlockResponse:
		return soap_out_dss__DeviceUnlockResponse(soap, tag, id, (const struct dss__DeviceUnlockResponse *)ptr, "dss:DeviceUnlockResponse");
	case SOAP_TYPE_dss__DeviceLock:
		return soap_out_dss__DeviceLock(soap, tag, id, (const struct dss__DeviceLock *)ptr, "dss:DeviceLock");
	case SOAP_TYPE_dss__DeviceLockResponse:
		return soap_out_dss__DeviceLockResponse(soap, tag, id, (const struct dss__DeviceLockResponse *)ptr, "dss:DeviceLockResponse");
	case SOAP_TYPE_dss__DeviceGetTags:
		return soap_out_dss__DeviceGetTags(soap, tag, id, (const struct dss__DeviceGetTags *)ptr, "dss:DeviceGetTags");
	case SOAP_TYPE_dss__DeviceGetTagsResponse:
		return soap_out_dss__DeviceGetTagsResponse(soap, tag, id, (const struct dss__DeviceGetTagsResponse *)ptr, "dss:DeviceGetTagsResponse");
	case SOAP_TYPE_dss__DeviceHasTag:
		return soap_out_dss__DeviceHasTag(soap, tag, id, (const struct dss__DeviceHasTag *)ptr, "dss:DeviceHasTag");
	case SOAP_TYPE_dss__DeviceHasTagResponse:
		return soap_out_dss__DeviceHasTagResponse(soap, tag, id, (const struct dss__DeviceHasTagResponse *)ptr, "dss:DeviceHasTagResponse");
	case SOAP_TYPE_dss__DeviceRemoveTag:
		return soap_out_dss__DeviceRemoveTag(soap, tag, id, (const struct dss__DeviceRemoveTag *)ptr, "dss:DeviceRemoveTag");
	case SOAP_TYPE_dss__DeviceRemoveTagResponse:
		return soap_out_dss__DeviceRemoveTagResponse(soap, tag, id, (const struct dss__DeviceRemoveTagResponse *)ptr, "dss:DeviceRemoveTagResponse");
	case SOAP_TYPE_dss__DeviceAddTag:
		return soap_out_dss__DeviceAddTag(soap, tag, id, (const struct dss__DeviceAddTag *)ptr, "dss:DeviceAddTag");
	case SOAP_TYPE_dss__DeviceAddTagResponse:
		return soap_out_dss__DeviceAddTagResponse(soap, tag, id, (const struct dss__DeviceAddTagResponse *)ptr, "dss:DeviceAddTagResponse");
	case SOAP_TYPE_dss__DeviceGetZoneID:
		return soap_out_dss__DeviceGetZoneID(soap, tag, id, (const struct dss__DeviceGetZoneID *)ptr, "dss:DeviceGetZoneID");
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		return soap_out_dss__DeviceGetZoneIDResponse(soap, tag, id, (const struct dss__DeviceGetZoneIDResponse *)ptr, "dss:DeviceGetZoneIDResponse");
	case SOAP_TYPE_dss__DeviceSetName:
		return soap_out_dss__DeviceSetName(soap, tag, id, (const struct dss__DeviceSetName *)ptr, "dss:DeviceSetName");
	case SOAP_TYPE_dss__DeviceSetNameResponse:
		return soap_out_dss__DeviceSetNameResponse(soap, tag, id, (const struct dss__DeviceSetNameResponse *)ptr, "dss:DeviceSetNameResponse");
	case SOAP_TYPE_dss__DeviceGetName:
		return soap_out_dss__DeviceGetName(soap, tag, id, (const struct dss__DeviceGetName *)ptr, "dss:DeviceGetName");
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		return soap_out_dss__DeviceGetNameResponse(soap, tag, id, (const struct dss__DeviceGetNameResponse *)ptr, "dss:DeviceGetNameResponse");
	case SOAP_TYPE_dss__DeviceSaveScene:
		return soap_out_dss__DeviceSaveScene(soap, tag, id, (const struct dss__DeviceSaveScene *)ptr, "dss:DeviceSaveScene");
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		return soap_out_dss__DeviceSaveSceneResponse(soap, tag, id, (const struct dss__DeviceSaveSceneResponse *)ptr, "dss:DeviceSaveSceneResponse");
	case SOAP_TYPE_dss__DeviceCallScene:
		return soap_out_dss__DeviceCallScene(soap, tag, id, (const struct dss__DeviceCallScene *)ptr, "dss:DeviceCallScene");
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		return soap_out_dss__DeviceCallSceneResponse(soap, tag, id, (const struct dss__DeviceCallSceneResponse *)ptr, "dss:DeviceCallSceneResponse");
	case SOAP_TYPE_dss__DeviceGetConfigWord:
		return soap_out_dss__DeviceGetConfigWord(soap, tag, id, (const struct dss__DeviceGetConfigWord *)ptr, "dss:DeviceGetConfigWord");
	case SOAP_TYPE_dss__DeviceGetConfigWordResponse:
		return soap_out_dss__DeviceGetConfigWordResponse(soap, tag, id, (const struct dss__DeviceGetConfigWordResponse *)ptr, "dss:DeviceGetConfigWordResponse");
	case SOAP_TYPE_dss__DeviceGetConfig:
		return soap_out_dss__DeviceGetConfig(soap, tag, id, (const struct dss__DeviceGetConfig *)ptr, "dss:DeviceGetConfig");
	case SOAP_TYPE_dss__DeviceGetConfigResponse:
		return soap_out_dss__DeviceGetConfigResponse(soap, tag, id, (const struct dss__DeviceGetConfigResponse *)ptr, "dss:DeviceGetConfigResponse");
	case SOAP_TYPE_dss__DeviceSetConfig:
		return soap_out_dss__DeviceSetConfig(soap, tag, id, (const struct dss__DeviceSetConfig *)ptr, "dss:DeviceSetConfig");
	case SOAP_TYPE_dss__DeviceSetConfigResponse:
		return soap_out_dss__DeviceSetConfigResponse(soap, tag, id, (const struct dss__DeviceSetConfigResponse *)ptr, "dss:DeviceSetConfigResponse");
	case SOAP_TYPE_dss__DeviceSetValue:
		return soap_out_dss__DeviceSetValue(soap, tag, id, (const struct dss__DeviceSetValue *)ptr, "dss:DeviceSetValue");
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		return soap_out_dss__DeviceSetValueResponse(soap, tag, id, (const struct dss__DeviceSetValueResponse *)ptr, "dss:DeviceSetValueResponse");
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		return soap_out_dss__DeviceDecreaseValue(soap, tag, id, (const struct dss__DeviceDecreaseValue *)ptr, "dss:DeviceDecreaseValue");
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		return soap_out_dss__DeviceDecreaseValueResponse(soap, tag, id, (const struct dss__DeviceDecreaseValueResponse *)ptr, "dss:DeviceDecreaseValueResponse");
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		return soap_out_dss__DeviceIncreaseValue(soap, tag, id, (const struct dss__DeviceIncreaseValue *)ptr, "dss:DeviceIncreaseValue");
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		return soap_out_dss__DeviceIncreaseValueResponse(soap, tag, id, (const struct dss__DeviceIncreaseValueResponse *)ptr, "dss:DeviceIncreaseValueResponse");
	case SOAP_TYPE_dss__DeviceTurnOff:
		return soap_out_dss__DeviceTurnOff(soap, tag, id, (const struct dss__DeviceTurnOff *)ptr, "dss:DeviceTurnOff");
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		return soap_out_dss__DeviceTurnOffResponse(soap, tag, id, (const struct dss__DeviceTurnOffResponse *)ptr, "dss:DeviceTurnOffResponse");
	case SOAP_TYPE_dss__DeviceTurnOn:
		return soap_out_dss__DeviceTurnOn(soap, tag, id, (const struct dss__DeviceTurnOn *)ptr, "dss:DeviceTurnOn");
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		return soap_out_dss__DeviceTurnOnResponse(soap, tag, id, (const struct dss__DeviceTurnOnResponse *)ptr, "dss:DeviceTurnOnResponse");
	case SOAP_TYPE_dss__ZoneSaveScene:
		return soap_out_dss__ZoneSaveScene(soap, tag, id, (const struct dss__ZoneSaveScene *)ptr, "dss:ZoneSaveScene");
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		return soap_out_dss__ZoneSaveSceneResponse(soap, tag, id, (const struct dss__ZoneSaveSceneResponse *)ptr, "dss:ZoneSaveSceneResponse");
	case SOAP_TYPE_dss__ZoneCallScene:
		return soap_out_dss__ZoneCallScene(soap, tag, id, (const struct dss__ZoneCallScene *)ptr, "dss:ZoneCallScene");
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		return soap_out_dss__ZoneCallSceneResponse(soap, tag, id, (const struct dss__ZoneCallSceneResponse *)ptr, "dss:ZoneCallSceneResponse");
	case SOAP_TYPE_dss__ZoneSetValue:
		return soap_out_dss__ZoneSetValue(soap, tag, id, (const struct dss__ZoneSetValue *)ptr, "dss:ZoneSetValue");
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		return soap_out_dss__ZoneSetValueResponse(soap, tag, id, (const struct dss__ZoneSetValueResponse *)ptr, "dss:ZoneSetValueResponse");
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		return soap_out_dss__ZoneDecreaseValue(soap, tag, id, (const struct dss__ZoneDecreaseValue *)ptr, "dss:ZoneDecreaseValue");
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		return soap_out_dss__ZoneDecreaseValueResponse(soap, tag, id, (const struct dss__ZoneDecreaseValueResponse *)ptr, "dss:ZoneDecreaseValueResponse");
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		return soap_out_dss__ZoneIncreaseValue(soap, tag, id, (const struct dss__ZoneIncreaseValue *)ptr, "dss:ZoneIncreaseValue");
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		return soap_out_dss__ZoneIncreaseValueResponse(soap, tag, id, (const struct dss__ZoneIncreaseValueResponse *)ptr, "dss:ZoneIncreaseValueResponse");
	case SOAP_TYPE_dss__ZoneTurnOff:
		return soap_out_dss__ZoneTurnOff(soap, tag, id, (const struct dss__ZoneTurnOff *)ptr, "dss:ZoneTurnOff");
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		return soap_out_dss__ZoneTurnOffResponse(soap, tag, id, (const struct dss__ZoneTurnOffResponse *)ptr, "dss:ZoneTurnOffResponse");
	case SOAP_TYPE_dss__ZoneTurnOn:
		return soap_out_dss__ZoneTurnOn(soap, tag, id, (const struct dss__ZoneTurnOn *)ptr, "dss:ZoneTurnOn");
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		return soap_out_dss__ZoneTurnOnResponse(soap, tag, id, (const struct dss__ZoneTurnOnResponse *)ptr, "dss:ZoneTurnOnResponse");
	case SOAP_TYPE_dss__CircuitRescan:
		return soap_out_dss__CircuitRescan(soap, tag, id, (const struct dss__CircuitRescan *)ptr, "dss:CircuitRescan");
	case SOAP_TYPE_dss__CircuitRescanResponse:
		return soap_out_dss__CircuitRescanResponse(soap, tag, id, (const struct dss__CircuitRescanResponse *)ptr, "dss:CircuitRescanResponse");
	case SOAP_TYPE_dss__ApartmentRescan:
		return soap_out_dss__ApartmentRescan(soap, tag, id, (const struct dss__ApartmentRescan *)ptr, "dss:ApartmentRescan");
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		return soap_out_dss__ApartmentRescanResponse(soap, tag, id, (const struct dss__ApartmentRescanResponse *)ptr, "dss:ApartmentRescanResponse");
	case SOAP_TYPE_dss__ApartmentSaveScene:
		return soap_out_dss__ApartmentSaveScene(soap, tag, id, (const struct dss__ApartmentSaveScene *)ptr, "dss:ApartmentSaveScene");
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		return soap_out_dss__ApartmentSaveSceneResponse(soap, tag, id, (const struct dss__ApartmentSaveSceneResponse *)ptr, "dss:ApartmentSaveSceneResponse");
	case SOAP_TYPE_dss__ApartmentCallScene:
		return soap_out_dss__ApartmentCallScene(soap, tag, id, (const struct dss__ApartmentCallScene *)ptr, "dss:ApartmentCallScene");
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		return soap_out_dss__ApartmentCallSceneResponse(soap, tag, id, (const struct dss__ApartmentCallSceneResponse *)ptr, "dss:ApartmentCallSceneResponse");
	case SOAP_TYPE_dss__ApartmentSetValue:
		return soap_out_dss__ApartmentSetValue(soap, tag, id, (const struct dss__ApartmentSetValue *)ptr, "dss:ApartmentSetValue");
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		return soap_out_dss__ApartmentSetValueResponse(soap, tag, id, (const struct dss__ApartmentSetValueResponse *)ptr, "dss:ApartmentSetValueResponse");
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		return soap_out_dss__ApartmentDecreaseValue(soap, tag, id, (const struct dss__ApartmentDecreaseValue *)ptr, "dss:ApartmentDecreaseValue");
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		return soap_out_dss__ApartmentDecreaseValueResponse(soap, tag, id, (const struct dss__ApartmentDecreaseValueResponse *)ptr, "dss:ApartmentDecreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		return soap_out_dss__ApartmentIncreaseValue(soap, tag, id, (const struct dss__ApartmentIncreaseValue *)ptr, "dss:ApartmentIncreaseValue");
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		return soap_out_dss__ApartmentIncreaseValueResponse(soap, tag, id, (const struct dss__ApartmentIncreaseValueResponse *)ptr, "dss:ApartmentIncreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentTurnOff:
		return soap_out_dss__ApartmentTurnOff(soap, tag, id, (const struct dss__ApartmentTurnOff *)ptr, "dss:ApartmentTurnOff");
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		return soap_out_dss__ApartmentTurnOffResponse(soap, tag, id, (const struct dss__ApartmentTurnOffResponse *)ptr, "dss:ApartmentTurnOffResponse");
	case SOAP_TYPE_dss__ApartmentTurnOn:
		return soap_out_dss__ApartmentTurnOn(soap, tag, id, (const struct dss__ApartmentTurnOn *)ptr, "dss:ApartmentTurnOn");
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		return soap_out_dss__ApartmentTurnOnResponse(soap, tag, id, (const struct dss__ApartmentTurnOnResponse *)ptr, "dss:ApartmentTurnOnResponse");
	case SOAP_TYPE_dss__SetSaveScene:
		return soap_out_dss__SetSaveScene(soap, tag, id, (const struct dss__SetSaveScene *)ptr, "dss:SetSaveScene");
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		return soap_out_dss__SetSaveSceneResponse(soap, tag, id, (const struct dss__SetSaveSceneResponse *)ptr, "dss:SetSaveSceneResponse");
	case SOAP_TYPE_dss__SetCallScene:
		return soap_out_dss__SetCallScene(soap, tag, id, (const struct dss__SetCallScene *)ptr, "dss:SetCallScene");
	case SOAP_TYPE_dss__SetCallSceneResponse:
		return soap_out_dss__SetCallSceneResponse(soap, tag, id, (const struct dss__SetCallSceneResponse *)ptr, "dss:SetCallSceneResponse");
	case SOAP_TYPE_dss__SetSetValue:
		return soap_out_dss__SetSetValue(soap, tag, id, (const struct dss__SetSetValue *)ptr, "dss:SetSetValue");
	case SOAP_TYPE_dss__SetSetValueResponse:
		return soap_out_dss__SetSetValueResponse(soap, tag, id, (const struct dss__SetSetValueResponse *)ptr, "dss:SetSetValueResponse");
	case SOAP_TYPE_dss__SetDecreaseValue:
		return soap_out_dss__SetDecreaseValue(soap, tag, id, (const struct dss__SetDecreaseValue *)ptr, "dss:SetDecreaseValue");
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		return soap_out_dss__SetDecreaseValueResponse(soap, tag, id, (const struct dss__SetDecreaseValueResponse *)ptr, "dss:SetDecreaseValueResponse");
	case SOAP_TYPE_dss__SetIncreaseValue:
		return soap_out_dss__SetIncreaseValue(soap, tag, id, (const struct dss__SetIncreaseValue *)ptr, "dss:SetIncreaseValue");
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		return soap_out_dss__SetIncreaseValueResponse(soap, tag, id, (const struct dss__SetIncreaseValueResponse *)ptr, "dss:SetIncreaseValueResponse");
	case SOAP_TYPE_dss__SetTurnOff:
		return soap_out_dss__SetTurnOff(soap, tag, id, (const struct dss__SetTurnOff *)ptr, "dss:SetTurnOff");
	case SOAP_TYPE_dss__SetTurnOffResponse:
		return soap_out_dss__SetTurnOffResponse(soap, tag, id, (const struct dss__SetTurnOffResponse *)ptr, "dss:SetTurnOffResponse");
	case SOAP_TYPE_dss__SetTurnOn:
		return soap_out_dss__SetTurnOn(soap, tag, id, (const struct dss__SetTurnOn *)ptr, "dss:SetTurnOn");
	case SOAP_TYPE_dss__SetTurnOnResponse:
		return soap_out_dss__SetTurnOnResponse(soap, tag, id, (const struct dss__SetTurnOnResponse *)ptr, "dss:SetTurnOnResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		return soap_out_dss__ApartmentGetZoneIDs(soap, tag, id, (const struct dss__ApartmentGetZoneIDs *)ptr, "dss:ApartmentGetZoneIDs");
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		return soap_out_dss__ApartmentGetZoneIDsResponse(soap, tag, id, (const struct dss__ApartmentGetZoneIDsResponse *)ptr, "dss:ApartmentGetZoneIDsResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		return soap_out_dss__ApartmentGetZoneByName(soap, tag, id, (const struct dss__ApartmentGetZoneByName *)ptr, "dss:ApartmentGetZoneByName");
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		return soap_out_dss__ApartmentGetZoneByNameResponse(soap, tag, id, (const struct dss__ApartmentGetZoneByNameResponse *)ptr, "dss:ApartmentGetZoneByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		return soap_out_dss__ApartmentGetGroupByName(soap, tag, id, (const struct dss__ApartmentGetGroupByName *)ptr, "dss:ApartmentGetGroupByName");
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		return soap_out_dss__ApartmentGetGroupByNameResponse(soap, tag, id, (const struct dss__ApartmentGetGroupByNameResponse *)ptr, "dss:ApartmentGetGroupByNameResponse");
	case SOAP_TYPE_dss__SetGetContainedDevices:
		return soap_out_dss__SetGetContainedDevices(soap, tag, id, (const struct dss__SetGetContainedDevices *)ptr, "dss:SetGetContainedDevices");
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		return soap_out_dss__SetGetContainedDevicesResponse(soap, tag, id, (const struct dss__SetGetContainedDevicesResponse *)ptr, "dss:SetGetContainedDevicesResponse");
	case SOAP_TYPE_dss__SetByGroup:
		return soap_out_dss__SetByGroup(soap, tag, id, (const struct dss__SetByGroup *)ptr, "dss:SetByGroup");
	case SOAP_TYPE_dss__SetByGroupResponse:
		return soap_out_dss__SetByGroupResponse(soap, tag, id, (const struct dss__SetByGroupResponse *)ptr, "dss:SetByGroupResponse");
	case SOAP_TYPE_dss__SetRemove:
		return soap_out_dss__SetRemove(soap, tag, id, (const struct dss__SetRemove *)ptr, "dss:SetRemove");
	case SOAP_TYPE_dss__SetRemoveResponse:
		return soap_out_dss__SetRemoveResponse(soap, tag, id, (const struct dss__SetRemoveResponse *)ptr, "dss:SetRemoveResponse");
	case SOAP_TYPE_dss__SetCombine:
		return soap_out_dss__SetCombine(soap, tag, id, (const struct dss__SetCombine *)ptr, "dss:SetCombine");
	case SOAP_TYPE_dss__SetCombineResponse:
		return soap_out_dss__SetCombineResponse(soap, tag, id, (const struct dss__SetCombineResponse *)ptr, "dss:SetCombineResponse");
	case SOAP_TYPE_dss__SetRemoveDevice:
		return soap_out_dss__SetRemoveDevice(soap, tag, id, (const struct dss__SetRemoveDevice *)ptr, "dss:SetRemoveDevice");
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		return soap_out_dss__SetRemoveDeviceResponse(soap, tag, id, (const struct dss__SetRemoveDeviceResponse *)ptr, "dss:SetRemoveDeviceResponse");
	case SOAP_TYPE_dss__SetAddDeviceByID:
		return soap_out_dss__SetAddDeviceByID(soap, tag, id, (const struct dss__SetAddDeviceByID *)ptr, "dss:SetAddDeviceByID");
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		return soap_out_dss__SetAddDeviceByIDResponse(soap, tag, id, (const struct dss__SetAddDeviceByIDResponse *)ptr, "dss:SetAddDeviceByIDResponse");
	case SOAP_TYPE_dss__SetAddDeviceByName:
		return soap_out_dss__SetAddDeviceByName(soap, tag, id, (const struct dss__SetAddDeviceByName *)ptr, "dss:SetAddDeviceByName");
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		return soap_out_dss__SetAddDeviceByNameResponse(soap, tag, id, (const struct dss__SetAddDeviceByNameResponse *)ptr, "dss:SetAddDeviceByNameResponse");
	case SOAP_TYPE_dss__ApartmentSetName:
		return soap_out_dss__ApartmentSetName(soap, tag, id, (const struct dss__ApartmentSetName *)ptr, "dss:ApartmentSetName");
	case SOAP_TYPE_dss__ApartmentSetNameResponse:
		return soap_out_dss__ApartmentSetNameResponse(soap, tag, id, (const struct dss__ApartmentSetNameResponse *)ptr, "dss:ApartmentSetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetName:
		return soap_out_dss__ApartmentGetName(soap, tag, id, (const struct dss__ApartmentGetName *)ptr, "dss:ApartmentGetName");
	case SOAP_TYPE_dss__ApartmentGetNameResponse:
		return soap_out_dss__ApartmentGetNameResponse(soap, tag, id, (const struct dss__ApartmentGetNameResponse *)ptr, "dss:ApartmentGetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		return soap_out_dss__ApartmentGetDeviceIDByName(soap, tag, id, (const struct dss__ApartmentGetDeviceIDByName *)ptr, "dss:ApartmentGetDeviceIDByName");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		return soap_out_dss__ApartmentGetDeviceIDByNameResponse(soap, tag, id, (const struct dss__ApartmentGetDeviceIDByNameResponse *)ptr, "dss:ApartmentGetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDevices:
		return soap_out_dss__ApartmentGetDevices(soap, tag, id, (const struct dss__ApartmentGetDevices *)ptr, "dss:ApartmentGetDevices");
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		return soap_out_dss__ApartmentGetDevicesResponse(soap, tag, id, (const struct dss__ApartmentGetDevicesResponse *)ptr, "dss:ApartmentGetDevicesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		return soap_out_dss__ApartmentCreateSetFromDeviceNames(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceNames *)ptr, "dss:ApartmentCreateSetFromDeviceNames");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		return soap_out_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceNamesResponse *)ptr, "dss:ApartmentCreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		return soap_out_dss__ApartmentCreateSetFromDeviceIDs(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceIDs *)ptr, "dss:ApartmentCreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		return soap_out_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceIDsResponse *)ptr, "dss:ApartmentCreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		return soap_out_dss__ApartmentCreateSetFromGroup(soap, tag, id, (const struct dss__ApartmentCreateSetFromGroup *)ptr, "dss:ApartmentCreateSetFromGroup");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		return soap_out_dss__ApartmentCreateSetFromGroupResponse(soap, tag, id, (const struct dss__ApartmentCreateSetFromGroupResponse *)ptr, "dss:ApartmentCreateSetFromGroupResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_out_dss__SignOff(soap, tag, id, (const struct dss__SignOff *)ptr, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_out_dss__SignOffResponse(soap, tag, id, (const struct dss__SignOffResponse *)ptr, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_out_dss__Authenticate(soap, tag, id, (const struct dss__Authenticate *)ptr, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_out_dss__AuthenticateResponse(soap, tag, id, (const struct dss__AuthenticateResponse *)ptr, "dss:AuthenticateResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_dss__Event:
		((dss__Event *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_dss__StructureAddDeviceToZone:
		soap_serialize_dss__StructureAddDeviceToZone(soap, (const struct dss__StructureAddDeviceToZone *)ptr);
		break;
	case SOAP_TYPE_dss__StructureAddDeviceToZoneResponse:
		soap_serialize_dss__StructureAddDeviceToZoneResponse(soap, (const struct dss__StructureAddDeviceToZoneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetChildren:
		soap_serialize_dss__PropertyGetChildren(soap, (const struct dss__PropertyGetChildren *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		soap_serialize_dss__PropertyGetChildrenResponse(soap, (const struct dss__PropertyGetChildrenResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetBool:
		soap_serialize_dss__PropertyGetBool(soap, (const struct dss__PropertyGetBool *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		soap_serialize_dss__PropertyGetBoolResponse(soap, (const struct dss__PropertyGetBoolResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetString:
		soap_serialize_dss__PropertyGetString(soap, (const struct dss__PropertyGetString *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		soap_serialize_dss__PropertyGetStringResponse(soap, (const struct dss__PropertyGetStringResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetInt:
		soap_serialize_dss__PropertyGetInt(soap, (const struct dss__PropertyGetInt *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		soap_serialize_dss__PropertyGetIntResponse(soap, (const struct dss__PropertyGetIntResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetBool:
		soap_serialize_dss__PropertySetBool(soap, (const struct dss__PropertySetBool *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		soap_serialize_dss__PropertySetBoolResponse(soap, (const struct dss__PropertySetBoolResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetString:
		soap_serialize_dss__PropertySetString(soap, (const struct dss__PropertySetString *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetStringResponse:
		soap_serialize_dss__PropertySetStringResponse(soap, (const struct dss__PropertySetStringResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetInt:
		soap_serialize_dss__PropertySetInt(soap, (const struct dss__PropertySetInt *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetIntResponse:
		soap_serialize_dss__PropertySetIntResponse(soap, (const struct dss__PropertySetIntResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetType:
		soap_serialize_dss__PropertyGetType(soap, (const struct dss__PropertyGetType *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		soap_serialize_dss__PropertyGetTypeResponse(soap, (const struct dss__PropertyGetTypeResponse *)ptr);
		break;
	case SOAP_TYPE_dss__EventSubscribeTo:
		soap_serialize_dss__EventSubscribeTo(soap, (const struct dss__EventSubscribeTo *)ptr);
		break;
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		soap_serialize_dss__EventSubscribeToResponse(soap, (const struct dss__EventSubscribeToResponse *)ptr);
		break;
	case SOAP_TYPE_dss__EventWaitFor:
		soap_serialize_dss__EventWaitFor(soap, (const struct dss__EventWaitFor *)ptr);
		break;
	case SOAP_TYPE_dss__EventWaitForResponse:
		soap_serialize_dss__EventWaitForResponse(soap, (const struct dss__EventWaitForResponse *)ptr);
		break;
	case SOAP_TYPE_dss__EventRaise:
		soap_serialize_dss__EventRaise(soap, (const struct dss__EventRaise *)ptr);
		break;
	case SOAP_TYPE_dss__EventRaiseResponse:
		soap_serialize_dss__EventRaiseResponse(soap, (const struct dss__EventRaiseResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		soap_serialize_dss__DeviceGetFunctionID(soap, (const struct dss__DeviceGetFunctionID *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		soap_serialize_dss__DeviceGetFunctionIDResponse(soap, (const struct dss__DeviceGetFunctionIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__GroupGetName:
		soap_serialize_dss__GroupGetName(soap, (const struct dss__GroupGetName *)ptr);
		break;
	case SOAP_TYPE_dss__GroupGetNameResponse:
		soap_serialize_dss__GroupGetNameResponse(soap, (const struct dss__GroupGetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__GroupSetName:
		soap_serialize_dss__GroupSetName(soap, (const struct dss__GroupSetName *)ptr);
		break;
	case SOAP_TYPE_dss__GroupSetNameResponse:
		soap_serialize_dss__GroupSetNameResponse(soap, (const struct dss__GroupSetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneGetName:
		soap_serialize_dss__ZoneGetName(soap, (const struct dss__ZoneGetName *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneGetNameResponse:
		soap_serialize_dss__ZoneGetNameResponse(soap, (const struct dss__ZoneGetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSetName:
		soap_serialize_dss__ZoneSetName(soap, (const struct dss__ZoneSetName *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSetNameResponse:
		soap_serialize_dss__ZoneSetNameResponse(soap, (const struct dss__ZoneSetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		soap_serialize_dss__ApartmentDeleteZone(soap, (const struct dss__ApartmentDeleteZone *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		soap_serialize_dss__ApartmentDeleteZoneResponse(soap, (const struct dss__ApartmentDeleteZoneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		soap_serialize_dss__ApartmentAllocateZone(soap, (const struct dss__ApartmentAllocateZone *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		soap_serialize_dss__ApartmentAllocateZoneResponse(soap, (const struct dss__ApartmentAllocateZoneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DSMeterSetName:
		soap_serialize_dss__DSMeterSetName(soap, (const struct dss__DSMeterSetName *)ptr);
		break;
	case SOAP_TYPE_dss__DSMeterSetNameResponse:
		soap_serialize_dss__DSMeterSetNameResponse(soap, (const struct dss__DSMeterSetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DSMeterGetName:
		soap_serialize_dss__DSMeterGetName(soap, (const struct dss__DSMeterGetName *)ptr);
		break;
	case SOAP_TYPE_dss__DSMeterGetNameResponse:
		soap_serialize_dss__DSMeterGetNameResponse(soap, (const struct dss__DSMeterGetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDs:
		soap_serialize_dss__ApartmentGetDSMeterIDs(soap, (const struct dss__ApartmentGetDSMeterIDs *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse:
		soap_serialize_dss__ApartmentGetDSMeterIDsResponse(soap, (const struct dss__ApartmentGetDSMeterIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DSMeterGetPowerConsumption:
		soap_serialize_dss__DSMeterGetPowerConsumption(soap, (const struct dss__DSMeterGetPowerConsumption *)ptr);
		break;
	case SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse:
		soap_serialize_dss__DSMeterGetPowerConsumptionResponse(soap, (const struct dss__DSMeterGetPowerConsumptionResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetIsLocked:
		soap_serialize_dss__DeviceGetIsLocked(soap, (const struct dss__DeviceGetIsLocked *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetIsLockedResponse:
		soap_serialize_dss__DeviceGetIsLockedResponse(soap, (const struct dss__DeviceGetIsLockedResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceUnlock:
		soap_serialize_dss__DeviceUnlock(soap, (const struct dss__DeviceUnlock *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceUnlockResponse:
		soap_serialize_dss__DeviceUnlockResponse(soap, (const struct dss__DeviceUnlockResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceLock:
		soap_serialize_dss__DeviceLock(soap, (const struct dss__DeviceLock *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceLockResponse:
		soap_serialize_dss__DeviceLockResponse(soap, (const struct dss__DeviceLockResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetTags:
		soap_serialize_dss__DeviceGetTags(soap, (const struct dss__DeviceGetTags *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetTagsResponse:
		soap_serialize_dss__DeviceGetTagsResponse(soap, (const struct dss__DeviceGetTagsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceHasTag:
		soap_serialize_dss__DeviceHasTag(soap, (const struct dss__DeviceHasTag *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceHasTagResponse:
		soap_serialize_dss__DeviceHasTagResponse(soap, (const struct dss__DeviceHasTagResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceRemoveTag:
		soap_serialize_dss__DeviceRemoveTag(soap, (const struct dss__DeviceRemoveTag *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceRemoveTagResponse:
		soap_serialize_dss__DeviceRemoveTagResponse(soap, (const struct dss__DeviceRemoveTagResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceAddTag:
		soap_serialize_dss__DeviceAddTag(soap, (const struct dss__DeviceAddTag *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceAddTagResponse:
		soap_serialize_dss__DeviceAddTagResponse(soap, (const struct dss__DeviceAddTagResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetZoneID:
		soap_serialize_dss__DeviceGetZoneID(soap, (const struct dss__DeviceGetZoneID *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		soap_serialize_dss__DeviceGetZoneIDResponse(soap, (const struct dss__DeviceGetZoneIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetName:
		soap_serialize_dss__DeviceSetName(soap, (const struct dss__DeviceSetName *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetNameResponse:
		soap_serialize_dss__DeviceSetNameResponse(soap, (const struct dss__DeviceSetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetName:
		soap_serialize_dss__DeviceGetName(soap, (const struct dss__DeviceGetName *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		soap_serialize_dss__DeviceGetNameResponse(soap, (const struct dss__DeviceGetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSaveScene:
		soap_serialize_dss__DeviceSaveScene(soap, (const struct dss__DeviceSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		soap_serialize_dss__DeviceSaveSceneResponse(soap, (const struct dss__DeviceSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceCallScene:
		soap_serialize_dss__DeviceCallScene(soap, (const struct dss__DeviceCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		soap_serialize_dss__DeviceCallSceneResponse(soap, (const struct dss__DeviceCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetConfigWord:
		soap_serialize_dss__DeviceGetConfigWord(soap, (const struct dss__DeviceGetConfigWord *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetConfigWordResponse:
		soap_serialize_dss__DeviceGetConfigWordResponse(soap, (const struct dss__DeviceGetConfigWordResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetConfig:
		soap_serialize_dss__DeviceGetConfig(soap, (const struct dss__DeviceGetConfig *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetConfigResponse:
		soap_serialize_dss__DeviceGetConfigResponse(soap, (const struct dss__DeviceGetConfigResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetConfig:
		soap_serialize_dss__DeviceSetConfig(soap, (const struct dss__DeviceSetConfig *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetConfigResponse:
		soap_serialize_dss__DeviceSetConfigResponse(soap, (const struct dss__DeviceSetConfigResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetValue:
		soap_serialize_dss__DeviceSetValue(soap, (const struct dss__DeviceSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		soap_serialize_dss__DeviceSetValueResponse(soap, (const struct dss__DeviceSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		soap_serialize_dss__DeviceDecreaseValue(soap, (const struct dss__DeviceDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		soap_serialize_dss__DeviceDecreaseValueResponse(soap, (const struct dss__DeviceDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		soap_serialize_dss__DeviceIncreaseValue(soap, (const struct dss__DeviceIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		soap_serialize_dss__DeviceIncreaseValueResponse(soap, (const struct dss__DeviceIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOff:
		soap_serialize_dss__DeviceTurnOff(soap, (const struct dss__DeviceTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		soap_serialize_dss__DeviceTurnOffResponse(soap, (const struct dss__DeviceTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOn:
		soap_serialize_dss__DeviceTurnOn(soap, (const struct dss__DeviceTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		soap_serialize_dss__DeviceTurnOnResponse(soap, (const struct dss__DeviceTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSaveScene:
		soap_serialize_dss__ZoneSaveScene(soap, (const struct dss__ZoneSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		soap_serialize_dss__ZoneSaveSceneResponse(soap, (const struct dss__ZoneSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneCallScene:
		soap_serialize_dss__ZoneCallScene(soap, (const struct dss__ZoneCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		soap_serialize_dss__ZoneCallSceneResponse(soap, (const struct dss__ZoneCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSetValue:
		soap_serialize_dss__ZoneSetValue(soap, (const struct dss__ZoneSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		soap_serialize_dss__ZoneSetValueResponse(soap, (const struct dss__ZoneSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		soap_serialize_dss__ZoneDecreaseValue(soap, (const struct dss__ZoneDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		soap_serialize_dss__ZoneDecreaseValueResponse(soap, (const struct dss__ZoneDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		soap_serialize_dss__ZoneIncreaseValue(soap, (const struct dss__ZoneIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		soap_serialize_dss__ZoneIncreaseValueResponse(soap, (const struct dss__ZoneIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOff:
		soap_serialize_dss__ZoneTurnOff(soap, (const struct dss__ZoneTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		soap_serialize_dss__ZoneTurnOffResponse(soap, (const struct dss__ZoneTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOn:
		soap_serialize_dss__ZoneTurnOn(soap, (const struct dss__ZoneTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		soap_serialize_dss__ZoneTurnOnResponse(soap, (const struct dss__ZoneTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__CircuitRescan:
		soap_serialize_dss__CircuitRescan(soap, (const struct dss__CircuitRescan *)ptr);
		break;
	case SOAP_TYPE_dss__CircuitRescanResponse:
		soap_serialize_dss__CircuitRescanResponse(soap, (const struct dss__CircuitRescanResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentRescan:
		soap_serialize_dss__ApartmentRescan(soap, (const struct dss__ApartmentRescan *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		soap_serialize_dss__ApartmentRescanResponse(soap, (const struct dss__ApartmentRescanResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSaveScene:
		soap_serialize_dss__ApartmentSaveScene(soap, (const struct dss__ApartmentSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		soap_serialize_dss__ApartmentSaveSceneResponse(soap, (const struct dss__ApartmentSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCallScene:
		soap_serialize_dss__ApartmentCallScene(soap, (const struct dss__ApartmentCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		soap_serialize_dss__ApartmentCallSceneResponse(soap, (const struct dss__ApartmentCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSetValue:
		soap_serialize_dss__ApartmentSetValue(soap, (const struct dss__ApartmentSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		soap_serialize_dss__ApartmentSetValueResponse(soap, (const struct dss__ApartmentSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		soap_serialize_dss__ApartmentDecreaseValue(soap, (const struct dss__ApartmentDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		soap_serialize_dss__ApartmentDecreaseValueResponse(soap, (const struct dss__ApartmentDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		soap_serialize_dss__ApartmentIncreaseValue(soap, (const struct dss__ApartmentIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		soap_serialize_dss__ApartmentIncreaseValueResponse(soap, (const struct dss__ApartmentIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOff:
		soap_serialize_dss__ApartmentTurnOff(soap, (const struct dss__ApartmentTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		soap_serialize_dss__ApartmentTurnOffResponse(soap, (const struct dss__ApartmentTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOn:
		soap_serialize_dss__ApartmentTurnOn(soap, (const struct dss__ApartmentTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		soap_serialize_dss__ApartmentTurnOnResponse(soap, (const struct dss__ApartmentTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetSaveScene:
		soap_serialize_dss__SetSaveScene(soap, (const struct dss__SetSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		soap_serialize_dss__SetSaveSceneResponse(soap, (const struct dss__SetSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetCallScene:
		soap_serialize_dss__SetCallScene(soap, (const struct dss__SetCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__SetCallSceneResponse:
		soap_serialize_dss__SetCallSceneResponse(soap, (const struct dss__SetCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetSetValue:
		soap_serialize_dss__SetSetValue(soap, (const struct dss__SetSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__SetSetValueResponse:
		soap_serialize_dss__SetSetValueResponse(soap, (const struct dss__SetSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetDecreaseValue:
		soap_serialize_dss__SetDecreaseValue(soap, (const struct dss__SetDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		soap_serialize_dss__SetDecreaseValueResponse(soap, (const struct dss__SetDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetIncreaseValue:
		soap_serialize_dss__SetIncreaseValue(soap, (const struct dss__SetIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		soap_serialize_dss__SetIncreaseValueResponse(soap, (const struct dss__SetIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOff:
		soap_serialize_dss__SetTurnOff(soap, (const struct dss__SetTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOffResponse:
		soap_serialize_dss__SetTurnOffResponse(soap, (const struct dss__SetTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOn:
		soap_serialize_dss__SetTurnOn(soap, (const struct dss__SetTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOnResponse:
		soap_serialize_dss__SetTurnOnResponse(soap, (const struct dss__SetTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		soap_serialize_dss__ApartmentGetZoneIDs(soap, (const struct dss__ApartmentGetZoneIDs *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		soap_serialize_dss__ApartmentGetZoneIDsResponse(soap, (const struct dss__ApartmentGetZoneIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		soap_serialize_dss__ApartmentGetZoneByName(soap, (const struct dss__ApartmentGetZoneByName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		soap_serialize_dss__ApartmentGetZoneByNameResponse(soap, (const struct dss__ApartmentGetZoneByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		soap_serialize_dss__ApartmentGetGroupByName(soap, (const struct dss__ApartmentGetGroupByName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		soap_serialize_dss__ApartmentGetGroupByNameResponse(soap, (const struct dss__ApartmentGetGroupByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetGetContainedDevices:
		soap_serialize_dss__SetGetContainedDevices(soap, (const struct dss__SetGetContainedDevices *)ptr);
		break;
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		soap_serialize_dss__SetGetContainedDevicesResponse(soap, (const struct dss__SetGetContainedDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetByGroup:
		soap_serialize_dss__SetByGroup(soap, (const struct dss__SetByGroup *)ptr);
		break;
	case SOAP_TYPE_dss__SetByGroupResponse:
		soap_serialize_dss__SetByGroupResponse(soap, (const struct dss__SetByGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemove:
		soap_serialize_dss__SetRemove(soap, (const struct dss__SetRemove *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemoveResponse:
		soap_serialize_dss__SetRemoveResponse(soap, (const struct dss__SetRemoveResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetCombine:
		soap_serialize_dss__SetCombine(soap, (const struct dss__SetCombine *)ptr);
		break;
	case SOAP_TYPE_dss__SetCombineResponse:
		soap_serialize_dss__SetCombineResponse(soap, (const struct dss__SetCombineResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemoveDevice:
		soap_serialize_dss__SetRemoveDevice(soap, (const struct dss__SetRemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		soap_serialize_dss__SetRemoveDeviceResponse(soap, (const struct dss__SetRemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByID:
		soap_serialize_dss__SetAddDeviceByID(soap, (const struct dss__SetAddDeviceByID *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		soap_serialize_dss__SetAddDeviceByIDResponse(soap, (const struct dss__SetAddDeviceByIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByName:
		soap_serialize_dss__SetAddDeviceByName(soap, (const struct dss__SetAddDeviceByName *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		soap_serialize_dss__SetAddDeviceByNameResponse(soap, (const struct dss__SetAddDeviceByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSetName:
		soap_serialize_dss__ApartmentSetName(soap, (const struct dss__ApartmentSetName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSetNameResponse:
		soap_serialize_dss__ApartmentSetNameResponse(soap, (const struct dss__ApartmentSetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetName:
		soap_serialize_dss__ApartmentGetName(soap, (const struct dss__ApartmentGetName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetNameResponse:
		soap_serialize_dss__ApartmentGetNameResponse(soap, (const struct dss__ApartmentGetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		soap_serialize_dss__ApartmentGetDeviceIDByName(soap, (const struct dss__ApartmentGetDeviceIDByName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		soap_serialize_dss__ApartmentGetDeviceIDByNameResponse(soap, (const struct dss__ApartmentGetDeviceIDByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDevices:
		soap_serialize_dss__ApartmentGetDevices(soap, (const struct dss__ApartmentGetDevices *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		soap_serialize_dss__ApartmentGetDevicesResponse(soap, (const struct dss__ApartmentGetDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		soap_serialize_dss__ApartmentCreateSetFromDeviceNames(soap, (const struct dss__ApartmentCreateSetFromDeviceNames *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		soap_serialize_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, (const struct dss__ApartmentCreateSetFromDeviceNamesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		soap_serialize_dss__ApartmentCreateSetFromDeviceIDs(soap, (const struct dss__ApartmentCreateSetFromDeviceIDs *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		soap_serialize_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, (const struct dss__ApartmentCreateSetFromDeviceIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		soap_serialize_dss__ApartmentCreateSetFromGroup(soap, (const struct dss__ApartmentCreateSetFromGroup *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		soap_serialize_dss__ApartmentCreateSetFromGroupResponse(soap, (const struct dss__ApartmentCreateSetFromGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SignOff:
		soap_serialize_dss__SignOff(soap, (const struct dss__SignOff *)ptr);
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		soap_serialize_dss__SignOffResponse(soap, (const struct dss__SignOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Authenticate:
		soap_serialize_dss__Authenticate(soap, (const struct dss__Authenticate *)ptr);
		break;
	case SOAP_TYPE_dss__AuthenticateResponse:
		soap_serialize_dss__AuthenticateResponse(soap, (const struct dss__AuthenticateResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__AuthenticateResponse:
		return (void*)soap_instantiate_dss__AuthenticateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Authenticate:
		return (void*)soap_instantiate_dss__Authenticate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOffResponse:
		return (void*)soap_instantiate_dss__SignOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOff:
		return (void*)soap_instantiate_dss__SignOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		return (void*)soap_instantiate_dss__ApartmentGetDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDevices:
		return (void*)soap_instantiate_dss__ApartmentGetDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		return (void*)soap_instantiate_dss__ApartmentGetDeviceIDByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		return (void*)soap_instantiate_dss__ApartmentGetDeviceIDByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetNameResponse:
		return (void*)soap_instantiate_dss__ApartmentGetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetName:
		return (void*)soap_instantiate_dss__ApartmentGetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSetNameResponse:
		return (void*)soap_instantiate_dss__ApartmentSetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSetName:
		return (void*)soap_instantiate_dss__ApartmentSetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		return (void*)soap_instantiate_dss__SetAddDeviceByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByName:
		return (void*)soap_instantiate_dss__SetAddDeviceByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		return (void*)soap_instantiate_dss__SetAddDeviceByIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByID:
		return (void*)soap_instantiate_dss__SetAddDeviceByID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		return (void*)soap_instantiate_dss__SetRemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemoveDevice:
		return (void*)soap_instantiate_dss__SetRemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCombineResponse:
		return (void*)soap_instantiate_dss__SetCombineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCombine:
		return (void*)soap_instantiate_dss__SetCombine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemoveResponse:
		return (void*)soap_instantiate_dss__SetRemoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemove:
		return (void*)soap_instantiate_dss__SetRemove(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetByGroupResponse:
		return (void*)soap_instantiate_dss__SetByGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetByGroup:
		return (void*)soap_instantiate_dss__SetByGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		return (void*)soap_instantiate_dss__SetGetContainedDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetGetContainedDevices:
		return (void*)soap_instantiate_dss__SetGetContainedDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		return (void*)soap_instantiate_dss__ApartmentGetGroupByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		return (void*)soap_instantiate_dss__ApartmentGetGroupByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		return (void*)soap_instantiate_dss__ApartmentGetZoneByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		return (void*)soap_instantiate_dss__ApartmentGetZoneByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		return (void*)soap_instantiate_dss__ApartmentGetZoneIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		return (void*)soap_instantiate_dss__ApartmentGetZoneIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOnResponse:
		return (void*)soap_instantiate_dss__SetTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOn:
		return (void*)soap_instantiate_dss__SetTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOffResponse:
		return (void*)soap_instantiate_dss__SetTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOff:
		return (void*)soap_instantiate_dss__SetTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		return (void*)soap_instantiate_dss__SetIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetIncreaseValue:
		return (void*)soap_instantiate_dss__SetIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		return (void*)soap_instantiate_dss__SetDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetDecreaseValue:
		return (void*)soap_instantiate_dss__SetDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSetValueResponse:
		return (void*)soap_instantiate_dss__SetSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSetValue:
		return (void*)soap_instantiate_dss__SetSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCallSceneResponse:
		return (void*)soap_instantiate_dss__SetCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCallScene:
		return (void*)soap_instantiate_dss__SetCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		return (void*)soap_instantiate_dss__SetSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSaveScene:
		return (void*)soap_instantiate_dss__SetSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		return (void*)soap_instantiate_dss__ApartmentTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOn:
		return (void*)soap_instantiate_dss__ApartmentTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		return (void*)soap_instantiate_dss__ApartmentTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOff:
		return (void*)soap_instantiate_dss__ApartmentTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		return (void*)soap_instantiate_dss__ApartmentIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		return (void*)soap_instantiate_dss__ApartmentIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		return (void*)soap_instantiate_dss__ApartmentDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		return (void*)soap_instantiate_dss__ApartmentDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		return (void*)soap_instantiate_dss__ApartmentSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSetValue:
		return (void*)soap_instantiate_dss__ApartmentSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		return (void*)soap_instantiate_dss__ApartmentCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCallScene:
		return (void*)soap_instantiate_dss__ApartmentCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		return (void*)soap_instantiate_dss__ApartmentSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSaveScene:
		return (void*)soap_instantiate_dss__ApartmentSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		return (void*)soap_instantiate_dss__ApartmentRescanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentRescan:
		return (void*)soap_instantiate_dss__ApartmentRescan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__CircuitRescanResponse:
		return (void*)soap_instantiate_dss__CircuitRescanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__CircuitRescan:
		return (void*)soap_instantiate_dss__CircuitRescan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		return (void*)soap_instantiate_dss__ZoneTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOn:
		return (void*)soap_instantiate_dss__ZoneTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		return (void*)soap_instantiate_dss__ZoneTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOff:
		return (void*)soap_instantiate_dss__ZoneTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		return (void*)soap_instantiate_dss__ZoneIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		return (void*)soap_instantiate_dss__ZoneIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		return (void*)soap_instantiate_dss__ZoneDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		return (void*)soap_instantiate_dss__ZoneDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		return (void*)soap_instantiate_dss__ZoneSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSetValue:
		return (void*)soap_instantiate_dss__ZoneSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		return (void*)soap_instantiate_dss__ZoneCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneCallScene:
		return (void*)soap_instantiate_dss__ZoneCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		return (void*)soap_instantiate_dss__ZoneSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSaveScene:
		return (void*)soap_instantiate_dss__ZoneSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		return (void*)soap_instantiate_dss__DeviceTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOn:
		return (void*)soap_instantiate_dss__DeviceTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		return (void*)soap_instantiate_dss__DeviceTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOff:
		return (void*)soap_instantiate_dss__DeviceTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		return (void*)soap_instantiate_dss__DeviceIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		return (void*)soap_instantiate_dss__DeviceIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		return (void*)soap_instantiate_dss__DeviceDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		return (void*)soap_instantiate_dss__DeviceDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		return (void*)soap_instantiate_dss__DeviceSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetValue:
		return (void*)soap_instantiate_dss__DeviceSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetConfigResponse:
		return (void*)soap_instantiate_dss__DeviceSetConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetConfig:
		return (void*)soap_instantiate_dss__DeviceSetConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetConfigResponse:
		return (void*)soap_instantiate_dss__DeviceGetConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetConfig:
		return (void*)soap_instantiate_dss__DeviceGetConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetConfigWordResponse:
		return (void*)soap_instantiate_dss__DeviceGetConfigWordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetConfigWord:
		return (void*)soap_instantiate_dss__DeviceGetConfigWord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		return (void*)soap_instantiate_dss__DeviceCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceCallScene:
		return (void*)soap_instantiate_dss__DeviceCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		return (void*)soap_instantiate_dss__DeviceSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSaveScene:
		return (void*)soap_instantiate_dss__DeviceSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		return (void*)soap_instantiate_dss__DeviceGetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetName:
		return (void*)soap_instantiate_dss__DeviceGetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetNameResponse:
		return (void*)soap_instantiate_dss__DeviceSetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetName:
		return (void*)soap_instantiate_dss__DeviceSetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		return (void*)soap_instantiate_dss__DeviceGetZoneIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetZoneID:
		return (void*)soap_instantiate_dss__DeviceGetZoneID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceAddTagResponse:
		return (void*)soap_instantiate_dss__DeviceAddTagResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceAddTag:
		return (void*)soap_instantiate_dss__DeviceAddTag(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceRemoveTagResponse:
		return (void*)soap_instantiate_dss__DeviceRemoveTagResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceRemoveTag:
		return (void*)soap_instantiate_dss__DeviceRemoveTag(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceHasTagResponse:
		return (void*)soap_instantiate_dss__DeviceHasTagResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceHasTag:
		return (void*)soap_instantiate_dss__DeviceHasTag(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetTagsResponse:
		return (void*)soap_instantiate_dss__DeviceGetTagsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetTags:
		return (void*)soap_instantiate_dss__DeviceGetTags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceLockResponse:
		return (void*)soap_instantiate_dss__DeviceLockResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceLock:
		return (void*)soap_instantiate_dss__DeviceLock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceUnlockResponse:
		return (void*)soap_instantiate_dss__DeviceUnlockResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceUnlock:
		return (void*)soap_instantiate_dss__DeviceUnlock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetIsLockedResponse:
		return (void*)soap_instantiate_dss__DeviceGetIsLockedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetIsLocked:
		return (void*)soap_instantiate_dss__DeviceGetIsLocked(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse:
		return (void*)soap_instantiate_dss__DSMeterGetPowerConsumptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DSMeterGetPowerConsumption:
		return (void*)soap_instantiate_dss__DSMeterGetPowerConsumption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse:
		return (void*)soap_instantiate_dss__ApartmentGetDSMeterIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDs:
		return (void*)soap_instantiate_dss__ApartmentGetDSMeterIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DSMeterGetNameResponse:
		return (void*)soap_instantiate_dss__DSMeterGetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DSMeterGetName:
		return (void*)soap_instantiate_dss__DSMeterGetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DSMeterSetNameResponse:
		return (void*)soap_instantiate_dss__DSMeterSetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DSMeterSetName:
		return (void*)soap_instantiate_dss__DSMeterSetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		return (void*)soap_instantiate_dss__ApartmentAllocateZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		return (void*)soap_instantiate_dss__ApartmentAllocateZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		return (void*)soap_instantiate_dss__ApartmentDeleteZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		return (void*)soap_instantiate_dss__ApartmentDeleteZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSetNameResponse:
		return (void*)soap_instantiate_dss__ZoneSetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSetName:
		return (void*)soap_instantiate_dss__ZoneSetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneGetNameResponse:
		return (void*)soap_instantiate_dss__ZoneGetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneGetName:
		return (void*)soap_instantiate_dss__ZoneGetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupSetNameResponse:
		return (void*)soap_instantiate_dss__GroupSetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupSetName:
		return (void*)soap_instantiate_dss__GroupSetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupGetNameResponse:
		return (void*)soap_instantiate_dss__GroupGetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupGetName:
		return (void*)soap_instantiate_dss__GroupGetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		return (void*)soap_instantiate_dss__DeviceGetFunctionIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		return (void*)soap_instantiate_dss__DeviceGetFunctionID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event:
		return (void*)soap_instantiate_dss__Event(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventRaiseResponse:
		return (void*)soap_instantiate_dss__EventRaiseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventRaise:
		return (void*)soap_instantiate_dss__EventRaise(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventWaitForResponse:
		return (void*)soap_instantiate_dss__EventWaitForResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventWaitFor:
		return (void*)soap_instantiate_dss__EventWaitFor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		return (void*)soap_instantiate_dss__EventSubscribeToResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventSubscribeTo:
		return (void*)soap_instantiate_dss__EventSubscribeTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		return (void*)soap_instantiate_dss__PropertyGetTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetType:
		return (void*)soap_instantiate_dss__PropertyGetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetIntResponse:
		return (void*)soap_instantiate_dss__PropertySetIntResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetInt:
		return (void*)soap_instantiate_dss__PropertySetInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetStringResponse:
		return (void*)soap_instantiate_dss__PropertySetStringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetString:
		return (void*)soap_instantiate_dss__PropertySetString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		return (void*)soap_instantiate_dss__PropertySetBoolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetBool:
		return (void*)soap_instantiate_dss__PropertySetBool(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		return (void*)soap_instantiate_dss__PropertyGetIntResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetInt:
		return (void*)soap_instantiate_dss__PropertyGetInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		return (void*)soap_instantiate_dss__PropertyGetStringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetString:
		return (void*)soap_instantiate_dss__PropertyGetString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		return (void*)soap_instantiate_dss__PropertyGetBoolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetBool:
		return (void*)soap_instantiate_dss__PropertyGetBool(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		return (void*)soap_instantiate_dss__PropertyGetChildrenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetChildren:
		return (void*)soap_instantiate_dss__PropertyGetChildren(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__StructureAddDeviceToZoneResponse:
		return (void*)soap_instantiate_dss__StructureAddDeviceToZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__StructureAddDeviceToZone:
		return (void*)soap_instantiate_dss__StructureAddDeviceToZone(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfdss__Event:
		return (void*)soap_instantiate_std__vectorTemplateOfdss__Event(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_dss__AuthenticateResponse:
		if (p->size < 0)
			delete (struct dss__AuthenticateResponse*)p->ptr;
		else
			delete[] (struct dss__AuthenticateResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Authenticate:
		if (p->size < 0)
			delete (struct dss__Authenticate*)p->ptr;
		else
			delete[] (struct dss__Authenticate*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		if (p->size < 0)
			delete (struct dss__SignOffResponse*)p->ptr;
		else
			delete[] (struct dss__SignOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOff:
		if (p->size < 0)
			delete (struct dss__SignOff*)p->ptr;
		else
			delete[] (struct dss__SignOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromGroupResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromGroup*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceIDsResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceIDs*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceNamesResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceNamesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceNames*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceNames*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDevicesResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDevicesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDevices:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDevices*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDevices*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDeviceIDByNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDeviceIDByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDeviceIDByName*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDeviceIDByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetName:
		if (p->size < 0)
			delete (struct dss__ApartmentGetName*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSetNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentSetNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentSetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSetName:
		if (p->size < 0)
			delete (struct dss__ApartmentSetName*)p->ptr;
		else
			delete[] (struct dss__ApartmentSetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByNameResponse*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByName:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByName*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByIDResponse*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByID:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByID*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByID*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__SetRemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__SetRemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemoveDevice:
		if (p->size < 0)
			delete (struct dss__SetRemoveDevice*)p->ptr;
		else
			delete[] (struct dss__SetRemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCombineResponse:
		if (p->size < 0)
			delete (struct dss__SetCombineResponse*)p->ptr;
		else
			delete[] (struct dss__SetCombineResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCombine:
		if (p->size < 0)
			delete (struct dss__SetCombine*)p->ptr;
		else
			delete[] (struct dss__SetCombine*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemoveResponse:
		if (p->size < 0)
			delete (struct dss__SetRemoveResponse*)p->ptr;
		else
			delete[] (struct dss__SetRemoveResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemove:
		if (p->size < 0)
			delete (struct dss__SetRemove*)p->ptr;
		else
			delete[] (struct dss__SetRemove*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetByGroupResponse:
		if (p->size < 0)
			delete (struct dss__SetByGroupResponse*)p->ptr;
		else
			delete[] (struct dss__SetByGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetByGroup:
		if (p->size < 0)
			delete (struct dss__SetByGroup*)p->ptr;
		else
			delete[] (struct dss__SetByGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		if (p->size < 0)
			delete (struct dss__SetGetContainedDevicesResponse*)p->ptr;
		else
			delete[] (struct dss__SetGetContainedDevicesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetGetContainedDevices:
		if (p->size < 0)
			delete (struct dss__SetGetContainedDevices*)p->ptr;
		else
			delete[] (struct dss__SetGetContainedDevices*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetGroupByNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetGroupByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		if (p->size < 0)
			delete (struct dss__ApartmentGetGroupByName*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetGroupByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneByNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneByName*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneIDsResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneIDs*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__SetTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__SetTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOn:
		if (p->size < 0)
			delete (struct dss__SetTurnOn*)p->ptr;
		else
			delete[] (struct dss__SetTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__SetTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__SetTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOff:
		if (p->size < 0)
			delete (struct dss__SetTurnOff*)p->ptr;
		else
			delete[] (struct dss__SetTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__SetIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__SetIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetIncreaseValue:
		if (p->size < 0)
			delete (struct dss__SetIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__SetIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__SetDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__SetDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetDecreaseValue:
		if (p->size < 0)
			delete (struct dss__SetDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__SetDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSetValueResponse:
		if (p->size < 0)
			delete (struct dss__SetSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__SetSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSetValue:
		if (p->size < 0)
			delete (struct dss__SetSetValue*)p->ptr;
		else
			delete[] (struct dss__SetSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__SetCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__SetCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCallScene:
		if (p->size < 0)
			delete (struct dss__SetCallScene*)p->ptr;
		else
			delete[] (struct dss__SetCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__SetSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__SetSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSaveScene:
		if (p->size < 0)
			delete (struct dss__SetSaveScene*)p->ptr;
		else
			delete[] (struct dss__SetSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOn:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOn*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOff:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOff*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		if (p->size < 0)
			delete (struct dss__ApartmentIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__ApartmentIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		if (p->size < 0)
			delete (struct dss__ApartmentDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__ApartmentDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSetValue:
		if (p->size < 0)
			delete (struct dss__ApartmentSetValue*)p->ptr;
		else
			delete[] (struct dss__ApartmentSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCallScene:
		if (p->size < 0)
			delete (struct dss__ApartmentCallScene*)p->ptr;
		else
			delete[] (struct dss__ApartmentCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSaveScene:
		if (p->size < 0)
			delete (struct dss__ApartmentSaveScene*)p->ptr;
		else
			delete[] (struct dss__ApartmentSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentRescanResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentRescanResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentRescan:
		if (p->size < 0)
			delete (struct dss__ApartmentRescan*)p->ptr;
		else
			delete[] (struct dss__ApartmentRescan*)p->ptr;
		break;
	case SOAP_TYPE_dss__CircuitRescanResponse:
		if (p->size < 0)
			delete (struct dss__CircuitRescanResponse*)p->ptr;
		else
			delete[] (struct dss__CircuitRescanResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__CircuitRescan:
		if (p->size < 0)
			delete (struct dss__CircuitRescan*)p->ptr;
		else
			delete[] (struct dss__CircuitRescan*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOn:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOn*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOff:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOff*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ZoneIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		if (p->size < 0)
			delete (struct dss__ZoneIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__ZoneIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ZoneDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		if (p->size < 0)
			delete (struct dss__ZoneDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__ZoneDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		if (p->size < 0)
			delete (struct dss__ZoneSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSetValue:
		if (p->size < 0)
			delete (struct dss__ZoneSetValue*)p->ptr;
		else
			delete[] (struct dss__ZoneSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__ZoneCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneCallScene:
		if (p->size < 0)
			delete (struct dss__ZoneCallScene*)p->ptr;
		else
			delete[] (struct dss__ZoneCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__ZoneSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSaveScene:
		if (p->size < 0)
			delete (struct dss__ZoneSaveScene*)p->ptr;
		else
			delete[] (struct dss__ZoneSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOn:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOn*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOff:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOff*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__DeviceIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		if (p->size < 0)
			delete (struct dss__DeviceIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__DeviceIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__DeviceDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		if (p->size < 0)
			delete (struct dss__DeviceDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__DeviceDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		if (p->size < 0)
			delete (struct dss__DeviceSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetValue:
		if (p->size < 0)
			delete (struct dss__DeviceSetValue*)p->ptr;
		else
			delete[] (struct dss__DeviceSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetConfigResponse:
		if (p->size < 0)
			delete (struct dss__DeviceSetConfigResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceSetConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetConfig:
		if (p->size < 0)
			delete (struct dss__DeviceSetConfig*)p->ptr;
		else
			delete[] (struct dss__DeviceSetConfig*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetConfigResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetConfigResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetConfig:
		if (p->size < 0)
			delete (struct dss__DeviceGetConfig*)p->ptr;
		else
			delete[] (struct dss__DeviceGetConfig*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetConfigWordResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetConfigWordResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetConfigWordResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetConfigWord:
		if (p->size < 0)
			delete (struct dss__DeviceGetConfigWord*)p->ptr;
		else
			delete[] (struct dss__DeviceGetConfigWord*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__DeviceCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceCallScene:
		if (p->size < 0)
			delete (struct dss__DeviceCallScene*)p->ptr;
		else
			delete[] (struct dss__DeviceCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__DeviceSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSaveScene:
		if (p->size < 0)
			delete (struct dss__DeviceSaveScene*)p->ptr;
		else
			delete[] (struct dss__DeviceSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetNameResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetName:
		if (p->size < 0)
			delete (struct dss__DeviceGetName*)p->ptr;
		else
			delete[] (struct dss__DeviceGetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetNameResponse:
		if (p->size < 0)
			delete (struct dss__DeviceSetNameResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceSetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetName:
		if (p->size < 0)
			delete (struct dss__DeviceSetName*)p->ptr;
		else
			delete[] (struct dss__DeviceSetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetZoneIDResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetZoneIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetZoneID:
		if (p->size < 0)
			delete (struct dss__DeviceGetZoneID*)p->ptr;
		else
			delete[] (struct dss__DeviceGetZoneID*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceAddTagResponse:
		if (p->size < 0)
			delete (struct dss__DeviceAddTagResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceAddTagResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceAddTag:
		if (p->size < 0)
			delete (struct dss__DeviceAddTag*)p->ptr;
		else
			delete[] (struct dss__DeviceAddTag*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceRemoveTagResponse:
		if (p->size < 0)
			delete (struct dss__DeviceRemoveTagResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceRemoveTagResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceRemoveTag:
		if (p->size < 0)
			delete (struct dss__DeviceRemoveTag*)p->ptr;
		else
			delete[] (struct dss__DeviceRemoveTag*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceHasTagResponse:
		if (p->size < 0)
			delete (struct dss__DeviceHasTagResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceHasTagResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceHasTag:
		if (p->size < 0)
			delete (struct dss__DeviceHasTag*)p->ptr;
		else
			delete[] (struct dss__DeviceHasTag*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetTagsResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetTagsResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetTagsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetTags:
		if (p->size < 0)
			delete (struct dss__DeviceGetTags*)p->ptr;
		else
			delete[] (struct dss__DeviceGetTags*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceLockResponse:
		if (p->size < 0)
			delete (struct dss__DeviceLockResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceLockResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceLock:
		if (p->size < 0)
			delete (struct dss__DeviceLock*)p->ptr;
		else
			delete[] (struct dss__DeviceLock*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceUnlockResponse:
		if (p->size < 0)
			delete (struct dss__DeviceUnlockResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceUnlockResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceUnlock:
		if (p->size < 0)
			delete (struct dss__DeviceUnlock*)p->ptr;
		else
			delete[] (struct dss__DeviceUnlock*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetIsLockedResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetIsLockedResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetIsLockedResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetIsLocked:
		if (p->size < 0)
			delete (struct dss__DeviceGetIsLocked*)p->ptr;
		else
			delete[] (struct dss__DeviceGetIsLocked*)p->ptr;
		break;
	case SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse:
		if (p->size < 0)
			delete (struct dss__DSMeterGetPowerConsumptionResponse*)p->ptr;
		else
			delete[] (struct dss__DSMeterGetPowerConsumptionResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DSMeterGetPowerConsumption:
		if (p->size < 0)
			delete (struct dss__DSMeterGetPowerConsumption*)p->ptr;
		else
			delete[] (struct dss__DSMeterGetPowerConsumption*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDSMeterIDsResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDSMeterIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDSMeterIDs:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDSMeterIDs*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDSMeterIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__DSMeterGetNameResponse:
		if (p->size < 0)
			delete (struct dss__DSMeterGetNameResponse*)p->ptr;
		else
			delete[] (struct dss__DSMeterGetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DSMeterGetName:
		if (p->size < 0)
			delete (struct dss__DSMeterGetName*)p->ptr;
		else
			delete[] (struct dss__DSMeterGetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__DSMeterSetNameResponse:
		if (p->size < 0)
			delete (struct dss__DSMeterSetNameResponse*)p->ptr;
		else
			delete[] (struct dss__DSMeterSetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DSMeterSetName:
		if (p->size < 0)
			delete (struct dss__DSMeterSetName*)p->ptr;
		else
			delete[] (struct dss__DSMeterSetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentAllocateZoneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentAllocateZoneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		if (p->size < 0)
			delete (struct dss__ApartmentAllocateZone*)p->ptr;
		else
			delete[] (struct dss__ApartmentAllocateZone*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentDeleteZoneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentDeleteZoneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		if (p->size < 0)
			delete (struct dss__ApartmentDeleteZone*)p->ptr;
		else
			delete[] (struct dss__ApartmentDeleteZone*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSetNameResponse:
		if (p->size < 0)
			delete (struct dss__ZoneSetNameResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneSetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSetName:
		if (p->size < 0)
			delete (struct dss__ZoneSetName*)p->ptr;
		else
			delete[] (struct dss__ZoneSetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneGetNameResponse:
		if (p->size < 0)
			delete (struct dss__ZoneGetNameResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneGetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneGetName:
		if (p->size < 0)
			delete (struct dss__ZoneGetName*)p->ptr;
		else
			delete[] (struct dss__ZoneGetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupSetNameResponse:
		if (p->size < 0)
			delete (struct dss__GroupSetNameResponse*)p->ptr;
		else
			delete[] (struct dss__GroupSetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupSetName:
		if (p->size < 0)
			delete (struct dss__GroupSetName*)p->ptr;
		else
			delete[] (struct dss__GroupSetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupGetNameResponse:
		if (p->size < 0)
			delete (struct dss__GroupGetNameResponse*)p->ptr;
		else
			delete[] (struct dss__GroupGetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupGetName:
		if (p->size < 0)
			delete (struct dss__GroupGetName*)p->ptr;
		else
			delete[] (struct dss__GroupGetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetFunctionIDResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetFunctionIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		if (p->size < 0)
			delete (struct dss__DeviceGetFunctionID*)p->ptr;
		else
			delete[] (struct dss__DeviceGetFunctionID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event:
		if (p->size < 0)
			delete (dss__Event*)p->ptr;
		else
			delete[] (dss__Event*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventRaiseResponse:
		if (p->size < 0)
			delete (struct dss__EventRaiseResponse*)p->ptr;
		else
			delete[] (struct dss__EventRaiseResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventRaise:
		if (p->size < 0)
			delete (struct dss__EventRaise*)p->ptr;
		else
			delete[] (struct dss__EventRaise*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventWaitForResponse:
		if (p->size < 0)
			delete (struct dss__EventWaitForResponse*)p->ptr;
		else
			delete[] (struct dss__EventWaitForResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventWaitFor:
		if (p->size < 0)
			delete (struct dss__EventWaitFor*)p->ptr;
		else
			delete[] (struct dss__EventWaitFor*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		if (p->size < 0)
			delete (struct dss__EventSubscribeToResponse*)p->ptr;
		else
			delete[] (struct dss__EventSubscribeToResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventSubscribeTo:
		if (p->size < 0)
			delete (struct dss__EventSubscribeTo*)p->ptr;
		else
			delete[] (struct dss__EventSubscribeTo*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetTypeResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetTypeResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetType:
		if (p->size < 0)
			delete (struct dss__PropertyGetType*)p->ptr;
		else
			delete[] (struct dss__PropertyGetType*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetIntResponse:
		if (p->size < 0)
			delete (struct dss__PropertySetIntResponse*)p->ptr;
		else
			delete[] (struct dss__PropertySetIntResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetInt:
		if (p->size < 0)
			delete (struct dss__PropertySetInt*)p->ptr;
		else
			delete[] (struct dss__PropertySetInt*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetStringResponse:
		if (p->size < 0)
			delete (struct dss__PropertySetStringResponse*)p->ptr;
		else
			delete[] (struct dss__PropertySetStringResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetString:
		if (p->size < 0)
			delete (struct dss__PropertySetString*)p->ptr;
		else
			delete[] (struct dss__PropertySetString*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		if (p->size < 0)
			delete (struct dss__PropertySetBoolResponse*)p->ptr;
		else
			delete[] (struct dss__PropertySetBoolResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetBool:
		if (p->size < 0)
			delete (struct dss__PropertySetBool*)p->ptr;
		else
			delete[] (struct dss__PropertySetBool*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetIntResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetIntResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetInt:
		if (p->size < 0)
			delete (struct dss__PropertyGetInt*)p->ptr;
		else
			delete[] (struct dss__PropertyGetInt*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetStringResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetStringResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetString:
		if (p->size < 0)
			delete (struct dss__PropertyGetString*)p->ptr;
		else
			delete[] (struct dss__PropertyGetString*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetBoolResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetBoolResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetBool:
		if (p->size < 0)
			delete (struct dss__PropertyGetBool*)p->ptr;
		else
			delete[] (struct dss__PropertyGetBool*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetChildrenResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetChildrenResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetChildren:
		if (p->size < 0)
			delete (struct dss__PropertyGetChildren*)p->ptr;
		else
			delete[] (struct dss__PropertyGetChildren*)p->ptr;
		break;
	case SOAP_TYPE_dss__StructureAddDeviceToZoneResponse:
		if (p->size < 0)
			delete (struct dss__StructureAddDeviceToZoneResponse*)p->ptr;
		else
			delete[] (struct dss__StructureAddDeviceToZoneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__StructureAddDeviceToZone:
		if (p->size < 0)
			delete (struct dss__StructureAddDeviceToZone*)p->ptr;
		else
			delete[] (struct dss__StructureAddDeviceToZone*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdss__Event:
		if (p->size < 0)
			delete (std::vector<dss__Event >*)p->ptr;
		else
			delete[] (std::vector<dss__Event >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfdss__Event:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<dss__Event >*)p)[len] = *(dss__Event *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{	short *p;
	p = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag?tag:"short", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{	long *p;
	p = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{	unsigned short *p;
	p = soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag?tag:"unsignedShort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{	unsigned long *p;
	p = soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_xsd__unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedInt(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (soap_out_xsd__unsignedInt(soap, tag?tag:"xsd:unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{	unsigned long *p;
	p = soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_xsd__unsignedLong);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedLong(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
	if (soap_out_xsd__unsignedLong(soap, tag?tag:"xsd:unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void dss__Event::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->dss__Event::name);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->dss__Event::parameter);
}

void dss__Event::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->dss__Event::name);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->dss__Event::parameter);
}

int dss__Event::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dss__Event(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event(struct soap *soap, const char *tag, int id, const dss__Event *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->dss__Event::name), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "parameter", -1, &(a->dss__Event::parameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dss__Event::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_dss__Event(soap, tag, this, type);
}

SOAP_FMAC3 dss__Event * SOAP_FMAC4 soap_in_dss__Event(struct soap *soap, const char *tag, dss__Event *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dss__Event *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event, sizeof(dss__Event), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_dss__Event)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (dss__Event *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->dss__Event::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "parameter", &(a->dss__Event::parameter), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (dss__Event *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event, 0, sizeof(dss__Event), 0, soap_copy_dss__Event);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int dss__Event::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dss__Event);
	if (this->soap_out(soap, tag?tag:"dss:Event", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *dss__Event::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dss__Event(soap, this, tag, type);
}

SOAP_FMAC3 dss__Event * SOAP_FMAC4 soap_get_dss__Event(struct soap *soap, dss__Event *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 dss__Event * SOAP_FMAC2 soap_instantiate_dss__Event(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (dss__Event);
		if (size)
			*size = sizeof(dss__Event);
	}
	else
	{	cp->ptr = (void*)new (dss__Event[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(dss__Event);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dss__Event*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dss__Event %p -> %p\n", q, p));
	*(dss__Event*)p = *(dss__Event*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new (std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new (struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__StructureAddDeviceToZone(struct soap *soap, struct dss__StructureAddDeviceToZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__StructureAddDeviceToZone(struct soap *soap, const struct dss__StructureAddDeviceToZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__StructureAddDeviceToZone(struct soap *soap, const char *tag, int id, const struct dss__StructureAddDeviceToZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__StructureAddDeviceToZone), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__StructureAddDeviceToZone * SOAP_FMAC4 soap_in_dss__StructureAddDeviceToZone(struct soap *soap, const char *tag, struct dss__StructureAddDeviceToZone *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__StructureAddDeviceToZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__StructureAddDeviceToZone, sizeof(struct dss__StructureAddDeviceToZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__StructureAddDeviceToZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__StructureAddDeviceToZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__StructureAddDeviceToZone, 0, sizeof(struct dss__StructureAddDeviceToZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__StructureAddDeviceToZone(struct soap *soap, const struct dss__StructureAddDeviceToZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__StructureAddDeviceToZone);
	if (soap_out_dss__StructureAddDeviceToZone(soap, tag?tag:"dss:StructureAddDeviceToZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__StructureAddDeviceToZone * SOAP_FMAC4 soap_get_dss__StructureAddDeviceToZone(struct soap *soap, struct dss__StructureAddDeviceToZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__StructureAddDeviceToZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__StructureAddDeviceToZone * SOAP_FMAC2 soap_instantiate_dss__StructureAddDeviceToZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__StructureAddDeviceToZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__StructureAddDeviceToZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__StructureAddDeviceToZone);
		if (size)
			*size = sizeof(struct dss__StructureAddDeviceToZone);
	}
	else
	{	cp->ptr = (void*)new (struct dss__StructureAddDeviceToZone[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__StructureAddDeviceToZone);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__StructureAddDeviceToZone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__StructureAddDeviceToZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__StructureAddDeviceToZone %p -> %p\n", q, p));
	*(struct dss__StructureAddDeviceToZone*)p = *(struct dss__StructureAddDeviceToZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__StructureAddDeviceToZoneResponse(struct soap *soap, struct dss__StructureAddDeviceToZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__StructureAddDeviceToZoneResponse(struct soap *soap, const struct dss__StructureAddDeviceToZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__StructureAddDeviceToZoneResponse(struct soap *soap, const char *tag, int id, const struct dss__StructureAddDeviceToZoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__StructureAddDeviceToZoneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__StructureAddDeviceToZoneResponse * SOAP_FMAC4 soap_in_dss__StructureAddDeviceToZoneResponse(struct soap *soap, const char *tag, struct dss__StructureAddDeviceToZoneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__StructureAddDeviceToZoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__StructureAddDeviceToZoneResponse, sizeof(struct dss__StructureAddDeviceToZoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__StructureAddDeviceToZoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__StructureAddDeviceToZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__StructureAddDeviceToZoneResponse, 0, sizeof(struct dss__StructureAddDeviceToZoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__StructureAddDeviceToZoneResponse(struct soap *soap, const struct dss__StructureAddDeviceToZoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__StructureAddDeviceToZoneResponse);
	if (soap_out_dss__StructureAddDeviceToZoneResponse(soap, tag?tag:"dss:StructureAddDeviceToZoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__StructureAddDeviceToZoneResponse * SOAP_FMAC4 soap_get_dss__StructureAddDeviceToZoneResponse(struct soap *soap, struct dss__StructureAddDeviceToZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__StructureAddDeviceToZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__StructureAddDeviceToZoneResponse * SOAP_FMAC2 soap_instantiate_dss__StructureAddDeviceToZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__StructureAddDeviceToZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__StructureAddDeviceToZoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__StructureAddDeviceToZoneResponse);
		if (size)
			*size = sizeof(struct dss__StructureAddDeviceToZoneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__StructureAddDeviceToZoneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__StructureAddDeviceToZoneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__StructureAddDeviceToZoneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__StructureAddDeviceToZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__StructureAddDeviceToZoneResponse %p -> %p\n", q, p));
	*(struct dss__StructureAddDeviceToZoneResponse*)p = *(struct dss__StructureAddDeviceToZoneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetChildren(struct soap *soap, struct dss__PropertyGetChildren *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetChildren(struct soap *soap, const struct dss__PropertyGetChildren *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetChildren(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetChildren *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetChildren), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetChildren * SOAP_FMAC4 soap_in_dss__PropertyGetChildren(struct soap *soap, const char *tag, struct dss__PropertyGetChildren *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetChildren *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetChildren, sizeof(struct dss__PropertyGetChildren), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetChildren(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetChildren *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetChildren, 0, sizeof(struct dss__PropertyGetChildren), 0, soap_copy_dss__PropertyGetChildren);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetChildren(struct soap *soap, const struct dss__PropertyGetChildren *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetChildren);
	if (soap_out_dss__PropertyGetChildren(soap, tag?tag:"dss:PropertyGetChildren", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetChildren * SOAP_FMAC4 soap_get_dss__PropertyGetChildren(struct soap *soap, struct dss__PropertyGetChildren *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetChildren(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetChildren * SOAP_FMAC2 soap_instantiate_dss__PropertyGetChildren(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetChildren(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetChildren, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetChildren);
		if (size)
			*size = sizeof(struct dss__PropertyGetChildren);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetChildren[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetChildren);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetChildren*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetChildren(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetChildren %p -> %p\n", q, p));
	*(struct dss__PropertyGetChildren*)p = *(struct dss__PropertyGetChildren*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetChildrenResponse(struct soap *soap, struct dss__PropertyGetChildrenResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetChildrenResponse(struct soap *soap, const struct dss__PropertyGetChildrenResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetChildrenResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetChildrenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetChildrenResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetChildrenResponse * SOAP_FMAC4 soap_in_dss__PropertyGetChildrenResponse(struct soap *soap, const char *tag, struct dss__PropertyGetChildrenResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetChildrenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetChildrenResponse, sizeof(struct dss__PropertyGetChildrenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetChildrenResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "result", &a->result, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetChildrenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetChildrenResponse, 0, sizeof(struct dss__PropertyGetChildrenResponse), 0, soap_copy_dss__PropertyGetChildrenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->result.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetChildrenResponse(struct soap *soap, const struct dss__PropertyGetChildrenResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetChildrenResponse);
	if (soap_out_dss__PropertyGetChildrenResponse(soap, tag?tag:"dss:PropertyGetChildrenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetChildrenResponse * SOAP_FMAC4 soap_get_dss__PropertyGetChildrenResponse(struct soap *soap, struct dss__PropertyGetChildrenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetChildrenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetChildrenResponse * SOAP_FMAC2 soap_instantiate_dss__PropertyGetChildrenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetChildrenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetChildrenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetChildrenResponse);
		if (size)
			*size = sizeof(struct dss__PropertyGetChildrenResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetChildrenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetChildrenResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetChildrenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetChildrenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetChildrenResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetChildrenResponse*)p = *(struct dss__PropertyGetChildrenResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetBool(struct soap *soap, struct dss__PropertyGetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetBool(struct soap *soap, const struct dss__PropertyGetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetBool(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetBool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetBool), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetBool * SOAP_FMAC4 soap_in_dss__PropertyGetBool(struct soap *soap, const char *tag, struct dss__PropertyGetBool *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetBool *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetBool, sizeof(struct dss__PropertyGetBool), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetBool(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetBool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetBool, 0, sizeof(struct dss__PropertyGetBool), 0, soap_copy_dss__PropertyGetBool);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetBool(struct soap *soap, const struct dss__PropertyGetBool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetBool);
	if (soap_out_dss__PropertyGetBool(soap, tag?tag:"dss:PropertyGetBool", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetBool * SOAP_FMAC4 soap_get_dss__PropertyGetBool(struct soap *soap, struct dss__PropertyGetBool *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetBool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetBool * SOAP_FMAC2 soap_instantiate_dss__PropertyGetBool(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetBool(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetBool, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetBool);
		if (size)
			*size = sizeof(struct dss__PropertyGetBool);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetBool[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetBool);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetBool*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetBool(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetBool %p -> %p\n", q, p));
	*(struct dss__PropertyGetBool*)p = *(struct dss__PropertyGetBool*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetBoolResponse(struct soap *soap, struct dss__PropertyGetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetBoolResponse(struct soap *soap, const struct dss__PropertyGetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetBoolResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetBoolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetBoolResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetBoolResponse * SOAP_FMAC4 soap_in_dss__PropertyGetBoolResponse(struct soap *soap, const char *tag, struct dss__PropertyGetBoolResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetBoolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetBoolResponse, sizeof(struct dss__PropertyGetBoolResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetBoolResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetBoolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetBoolResponse, 0, sizeof(struct dss__PropertyGetBoolResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetBoolResponse(struct soap *soap, const struct dss__PropertyGetBoolResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetBoolResponse);
	if (soap_out_dss__PropertyGetBoolResponse(soap, tag?tag:"dss:PropertyGetBoolResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetBoolResponse * SOAP_FMAC4 soap_get_dss__PropertyGetBoolResponse(struct soap *soap, struct dss__PropertyGetBoolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetBoolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetBoolResponse * SOAP_FMAC2 soap_instantiate_dss__PropertyGetBoolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetBoolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetBoolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetBoolResponse);
		if (size)
			*size = sizeof(struct dss__PropertyGetBoolResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetBoolResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetBoolResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetBoolResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetBoolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetBoolResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetBoolResponse*)p = *(struct dss__PropertyGetBoolResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetString(struct soap *soap, struct dss__PropertyGetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetString(struct soap *soap, const struct dss__PropertyGetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetString(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetString), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetString * SOAP_FMAC4 soap_in_dss__PropertyGetString(struct soap *soap, const char *tag, struct dss__PropertyGetString *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetString, sizeof(struct dss__PropertyGetString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetString(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetString, 0, sizeof(struct dss__PropertyGetString), 0, soap_copy_dss__PropertyGetString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetString(struct soap *soap, const struct dss__PropertyGetString *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetString);
	if (soap_out_dss__PropertyGetString(soap, tag?tag:"dss:PropertyGetString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetString * SOAP_FMAC4 soap_get_dss__PropertyGetString(struct soap *soap, struct dss__PropertyGetString *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetString * SOAP_FMAC2 soap_instantiate_dss__PropertyGetString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetString);
		if (size)
			*size = sizeof(struct dss__PropertyGetString);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetString[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetString);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetString*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetString %p -> %p\n", q, p));
	*(struct dss__PropertyGetString*)p = *(struct dss__PropertyGetString*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetStringResponse(struct soap *soap, struct dss__PropertyGetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetStringResponse(struct soap *soap, const struct dss__PropertyGetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetStringResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetStringResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetStringResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetStringResponse * SOAP_FMAC4 soap_in_dss__PropertyGetStringResponse(struct soap *soap, const char *tag, struct dss__PropertyGetStringResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetStringResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetStringResponse, sizeof(struct dss__PropertyGetStringResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetStringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetStringResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetStringResponse, 0, sizeof(struct dss__PropertyGetStringResponse), 0, soap_copy_dss__PropertyGetStringResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetStringResponse(struct soap *soap, const struct dss__PropertyGetStringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetStringResponse);
	if (soap_out_dss__PropertyGetStringResponse(soap, tag?tag:"dss:PropertyGetStringResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetStringResponse * SOAP_FMAC4 soap_get_dss__PropertyGetStringResponse(struct soap *soap, struct dss__PropertyGetStringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetStringResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetStringResponse * SOAP_FMAC2 soap_instantiate_dss__PropertyGetStringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetStringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetStringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetStringResponse);
		if (size)
			*size = sizeof(struct dss__PropertyGetStringResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetStringResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetStringResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetStringResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetStringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetStringResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetStringResponse*)p = *(struct dss__PropertyGetStringResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetInt(struct soap *soap, struct dss__PropertyGetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetInt(struct soap *soap, const struct dss__PropertyGetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetInt(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetInt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetInt), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetInt * SOAP_FMAC4 soap_in_dss__PropertyGetInt(struct soap *soap, const char *tag, struct dss__PropertyGetInt *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetInt, sizeof(struct dss__PropertyGetInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetInt(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetInt, 0, sizeof(struct dss__PropertyGetInt), 0, soap_copy_dss__PropertyGetInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetInt(struct soap *soap, const struct dss__PropertyGetInt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetInt);
	if (soap_out_dss__PropertyGetInt(soap, tag?tag:"dss:PropertyGetInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetInt * SOAP_FMAC4 soap_get_dss__PropertyGetInt(struct soap *soap, struct dss__PropertyGetInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetInt * SOAP_FMAC2 soap_instantiate_dss__PropertyGetInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetInt);
		if (size)
			*size = sizeof(struct dss__PropertyGetInt);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetInt[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetInt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetInt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetInt %p -> %p\n", q, p));
	*(struct dss__PropertyGetInt*)p = *(struct dss__PropertyGetInt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetIntResponse(struct soap *soap, struct dss__PropertyGetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetIntResponse(struct soap *soap, const struct dss__PropertyGetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetIntResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetIntResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetIntResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetIntResponse * SOAP_FMAC4 soap_in_dss__PropertyGetIntResponse(struct soap *soap, const char *tag, struct dss__PropertyGetIntResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetIntResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetIntResponse, sizeof(struct dss__PropertyGetIntResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetIntResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetIntResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetIntResponse, 0, sizeof(struct dss__PropertyGetIntResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetIntResponse(struct soap *soap, const struct dss__PropertyGetIntResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetIntResponse);
	if (soap_out_dss__PropertyGetIntResponse(soap, tag?tag:"dss:PropertyGetIntResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetIntResponse * SOAP_FMAC4 soap_get_dss__PropertyGetIntResponse(struct soap *soap, struct dss__PropertyGetIntResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetIntResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetIntResponse * SOAP_FMAC2 soap_instantiate_dss__PropertyGetIntResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetIntResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetIntResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetIntResponse);
		if (size)
			*size = sizeof(struct dss__PropertyGetIntResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetIntResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetIntResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetIntResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetIntResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetIntResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetIntResponse*)p = *(struct dss__PropertyGetIntResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetBool(struct soap *soap, struct dss__PropertySetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
	soap_default_bool(soap, &a->_value);
	a->_mayCreate = (bool)1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetBool(struct soap *soap, const struct dss__PropertySetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetBool(struct soap *soap, const char *tag, int id, const struct dss__PropertySetBool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetBool), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	if (soap_out_bool(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_bool(soap, "mayCreate", -1, &a->_mayCreate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetBool * SOAP_FMAC4 soap_in_dss__PropertySetBool(struct soap *soap, const char *tag, struct dss__PropertySetBool *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	size_t soap_flag__value = 1;
	size_t soap_flag__mayCreate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetBool *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetBool, sizeof(struct dss__PropertySetBool), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetBool(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_value, "xsd:boolean"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__mayCreate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_mayCreate, "xsd:boolean"))
				{	soap_flag__mayCreate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetBool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetBool, 0, sizeof(struct dss__PropertySetBool), 0, soap_copy_dss__PropertySetBool);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0 || soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetBool(struct soap *soap, const struct dss__PropertySetBool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetBool);
	if (soap_out_dss__PropertySetBool(soap, tag?tag:"dss:PropertySetBool", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertySetBool * SOAP_FMAC4 soap_get_dss__PropertySetBool(struct soap *soap, struct dss__PropertySetBool *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetBool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertySetBool * SOAP_FMAC2 soap_instantiate_dss__PropertySetBool(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetBool(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetBool, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertySetBool);
		if (size)
			*size = sizeof(struct dss__PropertySetBool);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertySetBool[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetBool);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetBool*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetBool(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetBool %p -> %p\n", q, p));
	*(struct dss__PropertySetBool*)p = *(struct dss__PropertySetBool*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetBoolResponse(struct soap *soap, struct dss__PropertySetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetBoolResponse(struct soap *soap, const struct dss__PropertySetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetBoolResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertySetBoolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetBoolResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetBoolResponse * SOAP_FMAC4 soap_in_dss__PropertySetBoolResponse(struct soap *soap, const char *tag, struct dss__PropertySetBoolResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetBoolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetBoolResponse, sizeof(struct dss__PropertySetBoolResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetBoolResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetBoolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetBoolResponse, 0, sizeof(struct dss__PropertySetBoolResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetBoolResponse(struct soap *soap, const struct dss__PropertySetBoolResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetBoolResponse);
	if (soap_out_dss__PropertySetBoolResponse(soap, tag?tag:"dss:PropertySetBoolResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertySetBoolResponse * SOAP_FMAC4 soap_get_dss__PropertySetBoolResponse(struct soap *soap, struct dss__PropertySetBoolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetBoolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertySetBoolResponse * SOAP_FMAC2 soap_instantiate_dss__PropertySetBoolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetBoolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetBoolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertySetBoolResponse);
		if (size)
			*size = sizeof(struct dss__PropertySetBoolResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertySetBoolResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetBoolResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetBoolResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetBoolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetBoolResponse %p -> %p\n", q, p));
	*(struct dss__PropertySetBoolResponse*)p = *(struct dss__PropertySetBoolResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetString(struct soap *soap, struct dss__PropertySetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
	soap_default_string(soap, &a->_value);
	a->_mayCreate = (bool)1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetString(struct soap *soap, const struct dss__PropertySetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
	soap_serialize_string(soap, &a->_value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetString(struct soap *soap, const char *tag, int id, const struct dss__PropertySetString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetString), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_bool(soap, "mayCreate", -1, &a->_mayCreate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetString * SOAP_FMAC4 soap_in_dss__PropertySetString(struct soap *soap, const char *tag, struct dss__PropertySetString *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	size_t soap_flag__value = 1;
	size_t soap_flag__mayCreate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetString, sizeof(struct dss__PropertySetString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetString(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap_flag__value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_value, "xsd:string"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__mayCreate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_mayCreate, "xsd:boolean"))
				{	soap_flag__mayCreate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetString, 0, sizeof(struct dss__PropertySetString), 0, soap_copy_dss__PropertySetString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetString(struct soap *soap, const struct dss__PropertySetString *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetString);
	if (soap_out_dss__PropertySetString(soap, tag?tag:"dss:PropertySetString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertySetString * SOAP_FMAC4 soap_get_dss__PropertySetString(struct soap *soap, struct dss__PropertySetString *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertySetString * SOAP_FMAC2 soap_instantiate_dss__PropertySetString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertySetString);
		if (size)
			*size = sizeof(struct dss__PropertySetString);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertySetString[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetString);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetString*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetString %p -> %p\n", q, p));
	*(struct dss__PropertySetString*)p = *(struct dss__PropertySetString*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetStringResponse(struct soap *soap, struct dss__PropertySetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetStringResponse(struct soap *soap, const struct dss__PropertySetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetStringResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertySetStringResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetStringResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetStringResponse * SOAP_FMAC4 soap_in_dss__PropertySetStringResponse(struct soap *soap, const char *tag, struct dss__PropertySetStringResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetStringResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetStringResponse, sizeof(struct dss__PropertySetStringResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetStringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetStringResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetStringResponse, 0, sizeof(struct dss__PropertySetStringResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetStringResponse(struct soap *soap, const struct dss__PropertySetStringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetStringResponse);
	if (soap_out_dss__PropertySetStringResponse(soap, tag?tag:"dss:PropertySetStringResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertySetStringResponse * SOAP_FMAC4 soap_get_dss__PropertySetStringResponse(struct soap *soap, struct dss__PropertySetStringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetStringResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertySetStringResponse * SOAP_FMAC2 soap_instantiate_dss__PropertySetStringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetStringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetStringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertySetStringResponse);
		if (size)
			*size = sizeof(struct dss__PropertySetStringResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertySetStringResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetStringResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetStringResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetStringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetStringResponse %p -> %p\n", q, p));
	*(struct dss__PropertySetStringResponse*)p = *(struct dss__PropertySetStringResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetInt(struct soap *soap, struct dss__PropertySetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
	soap_default_int(soap, &a->_value);
	a->_mayCreate = (bool)1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetInt(struct soap *soap, const struct dss__PropertySetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetInt(struct soap *soap, const char *tag, int id, const struct dss__PropertySetInt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetInt), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	if (soap_out_int(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_bool(soap, "mayCreate", -1, &a->_mayCreate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetInt * SOAP_FMAC4 soap_in_dss__PropertySetInt(struct soap *soap, const char *tag, struct dss__PropertySetInt *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	size_t soap_flag__value = 1;
	size_t soap_flag__mayCreate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetInt, sizeof(struct dss__PropertySetInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetInt(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_value, "xsd:int"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__mayCreate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_mayCreate, "xsd:boolean"))
				{	soap_flag__mayCreate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetInt, 0, sizeof(struct dss__PropertySetInt), 0, soap_copy_dss__PropertySetInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0 || soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetInt(struct soap *soap, const struct dss__PropertySetInt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetInt);
	if (soap_out_dss__PropertySetInt(soap, tag?tag:"dss:PropertySetInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertySetInt * SOAP_FMAC4 soap_get_dss__PropertySetInt(struct soap *soap, struct dss__PropertySetInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertySetInt * SOAP_FMAC2 soap_instantiate_dss__PropertySetInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertySetInt);
		if (size)
			*size = sizeof(struct dss__PropertySetInt);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertySetInt[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetInt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetInt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetInt %p -> %p\n", q, p));
	*(struct dss__PropertySetInt*)p = *(struct dss__PropertySetInt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetIntResponse(struct soap *soap, struct dss__PropertySetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetIntResponse(struct soap *soap, const struct dss__PropertySetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetIntResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertySetIntResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetIntResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetIntResponse * SOAP_FMAC4 soap_in_dss__PropertySetIntResponse(struct soap *soap, const char *tag, struct dss__PropertySetIntResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetIntResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetIntResponse, sizeof(struct dss__PropertySetIntResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetIntResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetIntResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetIntResponse, 0, sizeof(struct dss__PropertySetIntResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetIntResponse(struct soap *soap, const struct dss__PropertySetIntResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetIntResponse);
	if (soap_out_dss__PropertySetIntResponse(soap, tag?tag:"dss:PropertySetIntResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertySetIntResponse * SOAP_FMAC4 soap_get_dss__PropertySetIntResponse(struct soap *soap, struct dss__PropertySetIntResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetIntResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertySetIntResponse * SOAP_FMAC2 soap_instantiate_dss__PropertySetIntResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetIntResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetIntResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertySetIntResponse);
		if (size)
			*size = sizeof(struct dss__PropertySetIntResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertySetIntResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetIntResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetIntResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetIntResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetIntResponse %p -> %p\n", q, p));
	*(struct dss__PropertySetIntResponse*)p = *(struct dss__PropertySetIntResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetType(struct soap *soap, struct dss__PropertyGetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetType(struct soap *soap, const struct dss__PropertyGetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetType(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetType), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetType * SOAP_FMAC4 soap_in_dss__PropertyGetType(struct soap *soap, const char *tag, struct dss__PropertyGetType *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetType, sizeof(struct dss__PropertyGetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetType, 0, sizeof(struct dss__PropertyGetType), 0, soap_copy_dss__PropertyGetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetType(struct soap *soap, const struct dss__PropertyGetType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetType);
	if (soap_out_dss__PropertyGetType(soap, tag?tag:"dss:PropertyGetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetType * SOAP_FMAC4 soap_get_dss__PropertyGetType(struct soap *soap, struct dss__PropertyGetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetType * SOAP_FMAC2 soap_instantiate_dss__PropertyGetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetType);
		if (size)
			*size = sizeof(struct dss__PropertyGetType);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetType %p -> %p\n", q, p));
	*(struct dss__PropertyGetType*)p = *(struct dss__PropertyGetType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetTypeResponse(struct soap *soap, struct dss__PropertyGetTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetTypeResponse(struct soap *soap, const struct dss__PropertyGetTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetTypeResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetTypeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetTypeResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetTypeResponse * SOAP_FMAC4 soap_in_dss__PropertyGetTypeResponse(struct soap *soap, const char *tag, struct dss__PropertyGetTypeResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetTypeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetTypeResponse, sizeof(struct dss__PropertyGetTypeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetTypeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetTypeResponse, 0, sizeof(struct dss__PropertyGetTypeResponse), 0, soap_copy_dss__PropertyGetTypeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetTypeResponse(struct soap *soap, const struct dss__PropertyGetTypeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetTypeResponse);
	if (soap_out_dss__PropertyGetTypeResponse(soap, tag?tag:"dss:PropertyGetTypeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__PropertyGetTypeResponse * SOAP_FMAC4 soap_get_dss__PropertyGetTypeResponse(struct soap *soap, struct dss__PropertyGetTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__PropertyGetTypeResponse * SOAP_FMAC2 soap_instantiate_dss__PropertyGetTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetTypeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetTypeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__PropertyGetTypeResponse);
		if (size)
			*size = sizeof(struct dss__PropertyGetTypeResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__PropertyGetTypeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetTypeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetTypeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetTypeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetTypeResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetTypeResponse*)p = *(struct dss__PropertyGetTypeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventSubscribeTo(struct soap *soap, struct dss__EventSubscribeTo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventSubscribeTo(struct soap *soap, const struct dss__EventSubscribeTo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventSubscribeTo(struct soap *soap, const char *tag, int id, const struct dss__EventSubscribeTo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventSubscribeTo), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventSubscribeTo * SOAP_FMAC4 soap_in_dss__EventSubscribeTo(struct soap *soap, const char *tag, struct dss__EventSubscribeTo *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventSubscribeTo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventSubscribeTo, sizeof(struct dss__EventSubscribeTo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__EventSubscribeTo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventSubscribeTo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventSubscribeTo, 0, sizeof(struct dss__EventSubscribeTo), 0, soap_copy_dss__EventSubscribeTo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventSubscribeTo(struct soap *soap, const struct dss__EventSubscribeTo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventSubscribeTo);
	if (soap_out_dss__EventSubscribeTo(soap, tag?tag:"dss:EventSubscribeTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__EventSubscribeTo * SOAP_FMAC4 soap_get_dss__EventSubscribeTo(struct soap *soap, struct dss__EventSubscribeTo *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventSubscribeTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__EventSubscribeTo * SOAP_FMAC2 soap_instantiate_dss__EventSubscribeTo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventSubscribeTo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventSubscribeTo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__EventSubscribeTo);
		if (size)
			*size = sizeof(struct dss__EventSubscribeTo);
	}
	else
	{	cp->ptr = (void*)new (struct dss__EventSubscribeTo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventSubscribeTo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventSubscribeTo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventSubscribeTo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventSubscribeTo %p -> %p\n", q, p));
	*(struct dss__EventSubscribeTo*)p = *(struct dss__EventSubscribeTo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventSubscribeToResponse(struct soap *soap, struct dss__EventSubscribeToResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventSubscribeToResponse(struct soap *soap, const struct dss__EventSubscribeToResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventSubscribeToResponse(struct soap *soap, const char *tag, int id, const struct dss__EventSubscribeToResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventSubscribeToResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventSubscribeToResponse * SOAP_FMAC4 soap_in_dss__EventSubscribeToResponse(struct soap *soap, const char *tag, struct dss__EventSubscribeToResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventSubscribeToResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventSubscribeToResponse, sizeof(struct dss__EventSubscribeToResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__EventSubscribeToResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventSubscribeToResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventSubscribeToResponse, 0, sizeof(struct dss__EventSubscribeToResponse), 0, soap_copy_dss__EventSubscribeToResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventSubscribeToResponse(struct soap *soap, const struct dss__EventSubscribeToResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventSubscribeToResponse);
	if (soap_out_dss__EventSubscribeToResponse(soap, tag?tag:"dss:EventSubscribeToResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__EventSubscribeToResponse * SOAP_FMAC4 soap_get_dss__EventSubscribeToResponse(struct soap *soap, struct dss__EventSubscribeToResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventSubscribeToResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__EventSubscribeToResponse * SOAP_FMAC2 soap_instantiate_dss__EventSubscribeToResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventSubscribeToResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventSubscribeToResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__EventSubscribeToResponse);
		if (size)
			*size = sizeof(struct dss__EventSubscribeToResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__EventSubscribeToResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventSubscribeToResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventSubscribeToResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventSubscribeToResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventSubscribeToResponse %p -> %p\n", q, p));
	*(struct dss__EventSubscribeToResponse*)p = *(struct dss__EventSubscribeToResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventWaitFor(struct soap *soap, struct dss__EventWaitFor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_timeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventWaitFor(struct soap *soap, const struct dss__EventWaitFor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventWaitFor(struct soap *soap, const char *tag, int id, const struct dss__EventWaitFor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventWaitFor), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "timeout", -1, &a->_timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventWaitFor * SOAP_FMAC4 soap_in_dss__EventWaitFor(struct soap *soap, const char *tag, struct dss__EventWaitFor *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__timeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventWaitFor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventWaitFor, sizeof(struct dss__EventWaitFor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__EventWaitFor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_timeout, "xsd:int"))
				{	soap_flag__timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventWaitFor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventWaitFor, 0, sizeof(struct dss__EventWaitFor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__timeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventWaitFor(struct soap *soap, const struct dss__EventWaitFor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventWaitFor);
	if (soap_out_dss__EventWaitFor(soap, tag?tag:"dss:EventWaitFor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__EventWaitFor * SOAP_FMAC4 soap_get_dss__EventWaitFor(struct soap *soap, struct dss__EventWaitFor *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventWaitFor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__EventWaitFor * SOAP_FMAC2 soap_instantiate_dss__EventWaitFor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventWaitFor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventWaitFor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__EventWaitFor);
		if (size)
			*size = sizeof(struct dss__EventWaitFor);
	}
	else
	{	cp->ptr = (void*)new (struct dss__EventWaitFor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventWaitFor);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventWaitFor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventWaitFor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventWaitFor %p -> %p\n", q, p));
	*(struct dss__EventWaitFor*)p = *(struct dss__EventWaitFor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventWaitForResponse(struct soap *soap, struct dss__EventWaitForResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfdss__Event(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventWaitForResponse(struct soap *soap, const struct dss__EventWaitForResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdss__Event(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventWaitForResponse(struct soap *soap, const char *tag, int id, const struct dss__EventWaitForResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventWaitForResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdss__Event(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventWaitForResponse * SOAP_FMAC4 soap_in_dss__EventWaitForResponse(struct soap *soap, const char *tag, struct dss__EventWaitForResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventWaitForResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventWaitForResponse, sizeof(struct dss__EventWaitForResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__EventWaitForResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdss__Event(soap, "result", &a->result, "dss:Event"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventWaitForResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventWaitForResponse, 0, sizeof(struct dss__EventWaitForResponse), 0, soap_copy_dss__EventWaitForResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->result.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventWaitForResponse(struct soap *soap, const struct dss__EventWaitForResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventWaitForResponse);
	if (soap_out_dss__EventWaitForResponse(soap, tag?tag:"dss:EventWaitForResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__EventWaitForResponse * SOAP_FMAC4 soap_get_dss__EventWaitForResponse(struct soap *soap, struct dss__EventWaitForResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventWaitForResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__EventWaitForResponse * SOAP_FMAC2 soap_instantiate_dss__EventWaitForResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventWaitForResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventWaitForResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__EventWaitForResponse);
		if (size)
			*size = sizeof(struct dss__EventWaitForResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__EventWaitForResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventWaitForResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventWaitForResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventWaitForResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventWaitForResponse %p -> %p\n", q, p));
	*(struct dss__EventWaitForResponse*)p = *(struct dss__EventWaitForResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventRaise(struct soap *soap, struct dss__EventRaise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_eventName);
	soap_default_string(soap, &a->_context);
	soap_default_string(soap, &a->_parameter);
	soap_default_string(soap, &a->_location);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventRaise(struct soap *soap, const struct dss__EventRaise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_eventName);
	soap_serialize_string(soap, &a->_context);
	soap_serialize_string(soap, &a->_parameter);
	soap_serialize_string(soap, &a->_location);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventRaise(struct soap *soap, const char *tag, int id, const struct dss__EventRaise *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventRaise), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "eventName", -1, &a->_eventName, ""))
		return soap->error;
	if (soap_out_string(soap, "context", -1, &a->_context, ""))
		return soap->error;
	if (soap_out_string(soap, "parameter", -1, &a->_parameter, ""))
		return soap->error;
	if (soap_out_string(soap, "location", -1, &a->_location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventRaise * SOAP_FMAC4 soap_in_dss__EventRaise(struct soap *soap, const char *tag, struct dss__EventRaise *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__eventName = 1;
	size_t soap_flag__context = 1;
	size_t soap_flag__parameter = 1;
	size_t soap_flag__location = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventRaise *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventRaise, sizeof(struct dss__EventRaise), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__EventRaise(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__eventName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_eventName, "xsd:string"))
				{	soap_flag__eventName--;
					continue;
				}
			if (soap_flag__context && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_context, "xsd:string"))
				{	soap_flag__context--;
					continue;
				}
			if (soap_flag__parameter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_parameter, "xsd:string"))
				{	soap_flag__parameter--;
					continue;
				}
			if (soap_flag__location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_location, "xsd:string"))
				{	soap_flag__location--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventRaise *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventRaise, 0, sizeof(struct dss__EventRaise), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventRaise(struct soap *soap, const struct dss__EventRaise *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventRaise);
	if (soap_out_dss__EventRaise(soap, tag?tag:"dss:EventRaise", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__EventRaise * SOAP_FMAC4 soap_get_dss__EventRaise(struct soap *soap, struct dss__EventRaise *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventRaise(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__EventRaise * SOAP_FMAC2 soap_instantiate_dss__EventRaise(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventRaise(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventRaise, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__EventRaise);
		if (size)
			*size = sizeof(struct dss__EventRaise);
	}
	else
	{	cp->ptr = (void*)new (struct dss__EventRaise[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventRaise);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventRaise*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventRaise(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventRaise %p -> %p\n", q, p));
	*(struct dss__EventRaise*)p = *(struct dss__EventRaise*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventRaiseResponse(struct soap *soap, struct dss__EventRaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventRaiseResponse(struct soap *soap, const struct dss__EventRaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventRaiseResponse(struct soap *soap, const char *tag, int id, const struct dss__EventRaiseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventRaiseResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventRaiseResponse * SOAP_FMAC4 soap_in_dss__EventRaiseResponse(struct soap *soap, const char *tag, struct dss__EventRaiseResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventRaiseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventRaiseResponse, sizeof(struct dss__EventRaiseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__EventRaiseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventRaiseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventRaiseResponse, 0, sizeof(struct dss__EventRaiseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventRaiseResponse(struct soap *soap, const struct dss__EventRaiseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventRaiseResponse);
	if (soap_out_dss__EventRaiseResponse(soap, tag?tag:"dss:EventRaiseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__EventRaiseResponse * SOAP_FMAC4 soap_get_dss__EventRaiseResponse(struct soap *soap, struct dss__EventRaiseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventRaiseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__EventRaiseResponse * SOAP_FMAC2 soap_instantiate_dss__EventRaiseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventRaiseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventRaiseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__EventRaiseResponse);
		if (size)
			*size = sizeof(struct dss__EventRaiseResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__EventRaiseResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventRaiseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventRaiseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventRaiseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventRaiseResponse %p -> %p\n", q, p));
	*(struct dss__EventRaiseResponse*)p = *(struct dss__EventRaiseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetFunctionID(struct soap *soap, struct dss__DeviceGetFunctionID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetFunctionID(struct soap *soap, const struct dss__DeviceGetFunctionID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetFunctionID(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetFunctionID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetFunctionID), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionID * SOAP_FMAC4 soap_in_dss__DeviceGetFunctionID(struct soap *soap, const char *tag, struct dss__DeviceGetFunctionID *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetFunctionID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetFunctionID, sizeof(struct dss__DeviceGetFunctionID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetFunctionID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetFunctionID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetFunctionID, 0, sizeof(struct dss__DeviceGetFunctionID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetFunctionID(struct soap *soap, const struct dss__DeviceGetFunctionID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetFunctionID);
	if (soap_out_dss__DeviceGetFunctionID(soap, tag?tag:"dss:DeviceGetFunctionID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionID * SOAP_FMAC4 soap_get_dss__DeviceGetFunctionID(struct soap *soap, struct dss__DeviceGetFunctionID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetFunctionID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetFunctionID * SOAP_FMAC2 soap_instantiate_dss__DeviceGetFunctionID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetFunctionID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetFunctionID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetFunctionID);
		if (size)
			*size = sizeof(struct dss__DeviceGetFunctionID);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetFunctionID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetFunctionID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetFunctionID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetFunctionID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetFunctionID %p -> %p\n", q, p));
	*(struct dss__DeviceGetFunctionID*)p = *(struct dss__DeviceGetFunctionID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetFunctionIDResponse(struct soap *soap, struct dss__DeviceGetFunctionIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetFunctionIDResponse(struct soap *soap, const struct dss__DeviceGetFunctionIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetFunctionIDResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetFunctionIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetFunctionIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionIDResponse * SOAP_FMAC4 soap_in_dss__DeviceGetFunctionIDResponse(struct soap *soap, const char *tag, struct dss__DeviceGetFunctionIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetFunctionIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetFunctionIDResponse, sizeof(struct dss__DeviceGetFunctionIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetFunctionIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetFunctionIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetFunctionIDResponse, 0, sizeof(struct dss__DeviceGetFunctionIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetFunctionIDResponse(struct soap *soap, const struct dss__DeviceGetFunctionIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetFunctionIDResponse);
	if (soap_out_dss__DeviceGetFunctionIDResponse(soap, tag?tag:"dss:DeviceGetFunctionIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionIDResponse * SOAP_FMAC4 soap_get_dss__DeviceGetFunctionIDResponse(struct soap *soap, struct dss__DeviceGetFunctionIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetFunctionIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetFunctionIDResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceGetFunctionIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetFunctionIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetFunctionIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetFunctionIDResponse);
		if (size)
			*size = sizeof(struct dss__DeviceGetFunctionIDResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetFunctionIDResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetFunctionIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetFunctionIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetFunctionIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetFunctionIDResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetFunctionIDResponse*)p = *(struct dss__DeviceGetFunctionIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupGetName(struct soap *soap, struct dss__GroupGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupGetName(struct soap *soap, const struct dss__GroupGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupGetName(struct soap *soap, const char *tag, int id, const struct dss__GroupGetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupGetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupGetName * SOAP_FMAC4 soap_in_dss__GroupGetName(struct soap *soap, const char *tag, struct dss__GroupGetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupGetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupGetName, sizeof(struct dss__GroupGetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupGetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupGetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupGetName, 0, sizeof(struct dss__GroupGetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupGetName(struct soap *soap, const struct dss__GroupGetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupGetName);
	if (soap_out_dss__GroupGetName(soap, tag?tag:"dss:GroupGetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__GroupGetName * SOAP_FMAC4 soap_get_dss__GroupGetName(struct soap *soap, struct dss__GroupGetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupGetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__GroupGetName * SOAP_FMAC2 soap_instantiate_dss__GroupGetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupGetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupGetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__GroupGetName);
		if (size)
			*size = sizeof(struct dss__GroupGetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__GroupGetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupGetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupGetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupGetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupGetName %p -> %p\n", q, p));
	*(struct dss__GroupGetName*)p = *(struct dss__GroupGetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupGetNameResponse(struct soap *soap, struct dss__GroupGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupGetNameResponse(struct soap *soap, const struct dss__GroupGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupGetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__GroupGetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupGetNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupGetNameResponse * SOAP_FMAC4 soap_in_dss__GroupGetNameResponse(struct soap *soap, const char *tag, struct dss__GroupGetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupGetNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupGetNameResponse, sizeof(struct dss__GroupGetNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__GroupGetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupGetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupGetNameResponse, 0, sizeof(struct dss__GroupGetNameResponse), 0, soap_copy_dss__GroupGetNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupGetNameResponse(struct soap *soap, const struct dss__GroupGetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupGetNameResponse);
	if (soap_out_dss__GroupGetNameResponse(soap, tag?tag:"dss:GroupGetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__GroupGetNameResponse * SOAP_FMAC4 soap_get_dss__GroupGetNameResponse(struct soap *soap, struct dss__GroupGetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupGetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__GroupGetNameResponse * SOAP_FMAC2 soap_instantiate_dss__GroupGetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupGetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupGetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__GroupGetNameResponse);
		if (size)
			*size = sizeof(struct dss__GroupGetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__GroupGetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupGetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupGetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupGetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupGetNameResponse %p -> %p\n", q, p));
	*(struct dss__GroupGetNameResponse*)p = *(struct dss__GroupGetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupSetName(struct soap *soap, struct dss__GroupSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupSetName(struct soap *soap, const struct dss__GroupSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupSetName(struct soap *soap, const char *tag, int id, const struct dss__GroupSetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupSetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupSetName * SOAP_FMAC4 soap_in_dss__GroupSetName(struct soap *soap, const char *tag, struct dss__GroupSetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	size_t soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupSetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupSetName, sizeof(struct dss__GroupSetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupSetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupSetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupSetName, 0, sizeof(struct dss__GroupSetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupSetName(struct soap *soap, const struct dss__GroupSetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupSetName);
	if (soap_out_dss__GroupSetName(soap, tag?tag:"dss:GroupSetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__GroupSetName * SOAP_FMAC4 soap_get_dss__GroupSetName(struct soap *soap, struct dss__GroupSetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupSetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__GroupSetName * SOAP_FMAC2 soap_instantiate_dss__GroupSetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupSetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupSetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__GroupSetName);
		if (size)
			*size = sizeof(struct dss__GroupSetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__GroupSetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupSetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupSetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupSetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupSetName %p -> %p\n", q, p));
	*(struct dss__GroupSetName*)p = *(struct dss__GroupSetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupSetNameResponse(struct soap *soap, struct dss__GroupSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupSetNameResponse(struct soap *soap, const struct dss__GroupSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupSetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__GroupSetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupSetNameResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupSetNameResponse * SOAP_FMAC4 soap_in_dss__GroupSetNameResponse(struct soap *soap, const char *tag, struct dss__GroupSetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupSetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupSetNameResponse, sizeof(struct dss__GroupSetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupSetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupSetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupSetNameResponse, 0, sizeof(struct dss__GroupSetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupSetNameResponse(struct soap *soap, const struct dss__GroupSetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupSetNameResponse);
	if (soap_out_dss__GroupSetNameResponse(soap, tag?tag:"dss:GroupSetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__GroupSetNameResponse * SOAP_FMAC4 soap_get_dss__GroupSetNameResponse(struct soap *soap, struct dss__GroupSetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupSetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__GroupSetNameResponse * SOAP_FMAC2 soap_instantiate_dss__GroupSetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupSetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupSetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__GroupSetNameResponse);
		if (size)
			*size = sizeof(struct dss__GroupSetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__GroupSetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupSetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupSetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupSetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupSetNameResponse %p -> %p\n", q, p));
	*(struct dss__GroupSetNameResponse*)p = *(struct dss__GroupSetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneGetName(struct soap *soap, struct dss__ZoneGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneGetName(struct soap *soap, const struct dss__ZoneGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneGetName(struct soap *soap, const char *tag, int id, const struct dss__ZoneGetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneGetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneGetName * SOAP_FMAC4 soap_in_dss__ZoneGetName(struct soap *soap, const char *tag, struct dss__ZoneGetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneGetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneGetName, sizeof(struct dss__ZoneGetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneGetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneGetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneGetName, 0, sizeof(struct dss__ZoneGetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneGetName(struct soap *soap, const struct dss__ZoneGetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneGetName);
	if (soap_out_dss__ZoneGetName(soap, tag?tag:"dss:ZoneGetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneGetName * SOAP_FMAC4 soap_get_dss__ZoneGetName(struct soap *soap, struct dss__ZoneGetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneGetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneGetName * SOAP_FMAC2 soap_instantiate_dss__ZoneGetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneGetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneGetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneGetName);
		if (size)
			*size = sizeof(struct dss__ZoneGetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneGetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneGetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneGetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneGetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneGetName %p -> %p\n", q, p));
	*(struct dss__ZoneGetName*)p = *(struct dss__ZoneGetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneGetNameResponse(struct soap *soap, struct dss__ZoneGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneGetNameResponse(struct soap *soap, const struct dss__ZoneGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneGetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneGetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneGetNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneGetNameResponse * SOAP_FMAC4 soap_in_dss__ZoneGetNameResponse(struct soap *soap, const char *tag, struct dss__ZoneGetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneGetNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneGetNameResponse, sizeof(struct dss__ZoneGetNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ZoneGetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneGetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneGetNameResponse, 0, sizeof(struct dss__ZoneGetNameResponse), 0, soap_copy_dss__ZoneGetNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneGetNameResponse(struct soap *soap, const struct dss__ZoneGetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneGetNameResponse);
	if (soap_out_dss__ZoneGetNameResponse(soap, tag?tag:"dss:ZoneGetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneGetNameResponse * SOAP_FMAC4 soap_get_dss__ZoneGetNameResponse(struct soap *soap, struct dss__ZoneGetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneGetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneGetNameResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneGetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneGetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneGetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneGetNameResponse);
		if (size)
			*size = sizeof(struct dss__ZoneGetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneGetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneGetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneGetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneGetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneGetNameResponse %p -> %p\n", q, p));
	*(struct dss__ZoneGetNameResponse*)p = *(struct dss__ZoneGetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSetName(struct soap *soap, struct dss__ZoneSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSetName(struct soap *soap, const struct dss__ZoneSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSetName(struct soap *soap, const char *tag, int id, const struct dss__ZoneSetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSetName * SOAP_FMAC4 soap_in_dss__ZoneSetName(struct soap *soap, const char *tag, struct dss__ZoneSetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSetName, sizeof(struct dss__ZoneSetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSetName, 0, sizeof(struct dss__ZoneSetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSetName(struct soap *soap, const struct dss__ZoneSetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSetName);
	if (soap_out_dss__ZoneSetName(soap, tag?tag:"dss:ZoneSetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneSetName * SOAP_FMAC4 soap_get_dss__ZoneSetName(struct soap *soap, struct dss__ZoneSetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneSetName * SOAP_FMAC2 soap_instantiate_dss__ZoneSetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneSetName);
		if (size)
			*size = sizeof(struct dss__ZoneSetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneSetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSetName %p -> %p\n", q, p));
	*(struct dss__ZoneSetName*)p = *(struct dss__ZoneSetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSetNameResponse(struct soap *soap, struct dss__ZoneSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSetNameResponse(struct soap *soap, const struct dss__ZoneSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneSetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSetNameResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSetNameResponse * SOAP_FMAC4 soap_in_dss__ZoneSetNameResponse(struct soap *soap, const char *tag, struct dss__ZoneSetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSetNameResponse, sizeof(struct dss__ZoneSetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSetNameResponse, 0, sizeof(struct dss__ZoneSetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSetNameResponse(struct soap *soap, const struct dss__ZoneSetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSetNameResponse);
	if (soap_out_dss__ZoneSetNameResponse(soap, tag?tag:"dss:ZoneSetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneSetNameResponse * SOAP_FMAC4 soap_get_dss__ZoneSetNameResponse(struct soap *soap, struct dss__ZoneSetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneSetNameResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneSetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneSetNameResponse);
		if (size)
			*size = sizeof(struct dss__ZoneSetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneSetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSetNameResponse %p -> %p\n", q, p));
	*(struct dss__ZoneSetNameResponse*)p = *(struct dss__ZoneSetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDeleteZone(struct soap *soap, struct dss__ApartmentDeleteZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDeleteZone(struct soap *soap, const struct dss__ApartmentDeleteZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDeleteZone(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDeleteZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDeleteZone), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZone * SOAP_FMAC4 soap_in_dss__ApartmentDeleteZone(struct soap *soap, const char *tag, struct dss__ApartmentDeleteZone *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDeleteZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDeleteZone, sizeof(struct dss__ApartmentDeleteZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDeleteZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDeleteZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDeleteZone, 0, sizeof(struct dss__ApartmentDeleteZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDeleteZone(struct soap *soap, const struct dss__ApartmentDeleteZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDeleteZone);
	if (soap_out_dss__ApartmentDeleteZone(soap, tag?tag:"dss:ApartmentDeleteZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZone * SOAP_FMAC4 soap_get_dss__ApartmentDeleteZone(struct soap *soap, struct dss__ApartmentDeleteZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDeleteZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentDeleteZone * SOAP_FMAC2 soap_instantiate_dss__ApartmentDeleteZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDeleteZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDeleteZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentDeleteZone);
		if (size)
			*size = sizeof(struct dss__ApartmentDeleteZone);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentDeleteZone[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDeleteZone);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDeleteZone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDeleteZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDeleteZone %p -> %p\n", q, p));
	*(struct dss__ApartmentDeleteZone*)p = *(struct dss__ApartmentDeleteZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDeleteZoneResponse(struct soap *soap, struct dss__ApartmentDeleteZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDeleteZoneResponse(struct soap *soap, const struct dss__ApartmentDeleteZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDeleteZoneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDeleteZoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDeleteZoneResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZoneResponse * SOAP_FMAC4 soap_in_dss__ApartmentDeleteZoneResponse(struct soap *soap, const char *tag, struct dss__ApartmentDeleteZoneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDeleteZoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDeleteZoneResponse, sizeof(struct dss__ApartmentDeleteZoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDeleteZoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDeleteZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDeleteZoneResponse, 0, sizeof(struct dss__ApartmentDeleteZoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDeleteZoneResponse(struct soap *soap, const struct dss__ApartmentDeleteZoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDeleteZoneResponse);
	if (soap_out_dss__ApartmentDeleteZoneResponse(soap, tag?tag:"dss:ApartmentDeleteZoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZoneResponse * SOAP_FMAC4 soap_get_dss__ApartmentDeleteZoneResponse(struct soap *soap, struct dss__ApartmentDeleteZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDeleteZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentDeleteZoneResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentDeleteZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDeleteZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDeleteZoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentDeleteZoneResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentDeleteZoneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentDeleteZoneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDeleteZoneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDeleteZoneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDeleteZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDeleteZoneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentDeleteZoneResponse*)p = *(struct dss__ApartmentDeleteZoneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentAllocateZone(struct soap *soap, struct dss__ApartmentAllocateZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentAllocateZone(struct soap *soap, const struct dss__ApartmentAllocateZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentAllocateZone(struct soap *soap, const char *tag, int id, const struct dss__ApartmentAllocateZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentAllocateZone), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZone * SOAP_FMAC4 soap_in_dss__ApartmentAllocateZone(struct soap *soap, const char *tag, struct dss__ApartmentAllocateZone *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentAllocateZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentAllocateZone, sizeof(struct dss__ApartmentAllocateZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentAllocateZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentAllocateZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentAllocateZone, 0, sizeof(struct dss__ApartmentAllocateZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentAllocateZone(struct soap *soap, const struct dss__ApartmentAllocateZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentAllocateZone);
	if (soap_out_dss__ApartmentAllocateZone(soap, tag?tag:"dss:ApartmentAllocateZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZone * SOAP_FMAC4 soap_get_dss__ApartmentAllocateZone(struct soap *soap, struct dss__ApartmentAllocateZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentAllocateZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentAllocateZone * SOAP_FMAC2 soap_instantiate_dss__ApartmentAllocateZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentAllocateZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentAllocateZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentAllocateZone);
		if (size)
			*size = sizeof(struct dss__ApartmentAllocateZone);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentAllocateZone[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentAllocateZone);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentAllocateZone*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentAllocateZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentAllocateZone %p -> %p\n", q, p));
	*(struct dss__ApartmentAllocateZone*)p = *(struct dss__ApartmentAllocateZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentAllocateZoneResponse(struct soap *soap, struct dss__ApartmentAllocateZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentAllocateZoneResponse(struct soap *soap, const struct dss__ApartmentAllocateZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentAllocateZoneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentAllocateZoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentAllocateZoneResponse), type))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZoneResponse * SOAP_FMAC4 soap_in_dss__ApartmentAllocateZoneResponse(struct soap *soap, const char *tag, struct dss__ApartmentAllocateZoneResponse *a, const char *type)
{
	size_t soap_flag_zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentAllocateZoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentAllocateZoneResponse, sizeof(struct dss__ApartmentAllocateZoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentAllocateZoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zoneID", &a->zoneID, "xsd:int"))
				{	soap_flag_zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentAllocateZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentAllocateZoneResponse, 0, sizeof(struct dss__ApartmentAllocateZoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentAllocateZoneResponse(struct soap *soap, const struct dss__ApartmentAllocateZoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentAllocateZoneResponse);
	if (soap_out_dss__ApartmentAllocateZoneResponse(soap, tag?tag:"dss:ApartmentAllocateZoneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZoneResponse * SOAP_FMAC4 soap_get_dss__ApartmentAllocateZoneResponse(struct soap *soap, struct dss__ApartmentAllocateZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentAllocateZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentAllocateZoneResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentAllocateZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentAllocateZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentAllocateZoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentAllocateZoneResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentAllocateZoneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentAllocateZoneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentAllocateZoneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentAllocateZoneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentAllocateZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentAllocateZoneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentAllocateZoneResponse*)p = *(struct dss__ApartmentAllocateZoneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DSMeterSetName(struct soap *soap, struct dss__DSMeterSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_dsMeterID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DSMeterSetName(struct soap *soap, const struct dss__DSMeterSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_dsMeterID);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DSMeterSetName(struct soap *soap, const char *tag, int id, const struct dss__DSMeterSetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DSMeterSetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "dsMeterID", -1, &a->_dsMeterID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DSMeterSetName * SOAP_FMAC4 soap_in_dss__DSMeterSetName(struct soap *soap, const char *tag, struct dss__DSMeterSetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__dsMeterID = 1;
	size_t soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DSMeterSetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DSMeterSetName, sizeof(struct dss__DSMeterSetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DSMeterSetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__dsMeterID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_dsMeterID, "xsd:string"))
				{	soap_flag__dsMeterID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DSMeterSetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DSMeterSetName, 0, sizeof(struct dss__DSMeterSetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DSMeterSetName(struct soap *soap, const struct dss__DSMeterSetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DSMeterSetName);
	if (soap_out_dss__DSMeterSetName(soap, tag?tag:"dss:DSMeterSetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DSMeterSetName * SOAP_FMAC4 soap_get_dss__DSMeterSetName(struct soap *soap, struct dss__DSMeterSetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DSMeterSetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DSMeterSetName * SOAP_FMAC2 soap_instantiate_dss__DSMeterSetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DSMeterSetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DSMeterSetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DSMeterSetName);
		if (size)
			*size = sizeof(struct dss__DSMeterSetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DSMeterSetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DSMeterSetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DSMeterSetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DSMeterSetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DSMeterSetName %p -> %p\n", q, p));
	*(struct dss__DSMeterSetName*)p = *(struct dss__DSMeterSetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DSMeterSetNameResponse(struct soap *soap, struct dss__DSMeterSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DSMeterSetNameResponse(struct soap *soap, const struct dss__DSMeterSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DSMeterSetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__DSMeterSetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DSMeterSetNameResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DSMeterSetNameResponse * SOAP_FMAC4 soap_in_dss__DSMeterSetNameResponse(struct soap *soap, const char *tag, struct dss__DSMeterSetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DSMeterSetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DSMeterSetNameResponse, sizeof(struct dss__DSMeterSetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DSMeterSetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DSMeterSetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DSMeterSetNameResponse, 0, sizeof(struct dss__DSMeterSetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DSMeterSetNameResponse(struct soap *soap, const struct dss__DSMeterSetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DSMeterSetNameResponse);
	if (soap_out_dss__DSMeterSetNameResponse(soap, tag?tag:"dss:DSMeterSetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DSMeterSetNameResponse * SOAP_FMAC4 soap_get_dss__DSMeterSetNameResponse(struct soap *soap, struct dss__DSMeterSetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DSMeterSetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DSMeterSetNameResponse * SOAP_FMAC2 soap_instantiate_dss__DSMeterSetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DSMeterSetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DSMeterSetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DSMeterSetNameResponse);
		if (size)
			*size = sizeof(struct dss__DSMeterSetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DSMeterSetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DSMeterSetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DSMeterSetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DSMeterSetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DSMeterSetNameResponse %p -> %p\n", q, p));
	*(struct dss__DSMeterSetNameResponse*)p = *(struct dss__DSMeterSetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DSMeterGetName(struct soap *soap, struct dss__DSMeterGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_dsMeterID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DSMeterGetName(struct soap *soap, const struct dss__DSMeterGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_dsMeterID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DSMeterGetName(struct soap *soap, const char *tag, int id, const struct dss__DSMeterGetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DSMeterGetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "dsMeterID", -1, &a->_dsMeterID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DSMeterGetName * SOAP_FMAC4 soap_in_dss__DSMeterGetName(struct soap *soap, const char *tag, struct dss__DSMeterGetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__dsMeterID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DSMeterGetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DSMeterGetName, sizeof(struct dss__DSMeterGetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DSMeterGetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__dsMeterID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_dsMeterID, "xsd:string"))
				{	soap_flag__dsMeterID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DSMeterGetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DSMeterGetName, 0, sizeof(struct dss__DSMeterGetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DSMeterGetName(struct soap *soap, const struct dss__DSMeterGetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DSMeterGetName);
	if (soap_out_dss__DSMeterGetName(soap, tag?tag:"dss:DSMeterGetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DSMeterGetName * SOAP_FMAC4 soap_get_dss__DSMeterGetName(struct soap *soap, struct dss__DSMeterGetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DSMeterGetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DSMeterGetName * SOAP_FMAC2 soap_instantiate_dss__DSMeterGetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DSMeterGetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DSMeterGetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DSMeterGetName);
		if (size)
			*size = sizeof(struct dss__DSMeterGetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DSMeterGetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DSMeterGetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DSMeterGetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DSMeterGetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DSMeterGetName %p -> %p\n", q, p));
	*(struct dss__DSMeterGetName*)p = *(struct dss__DSMeterGetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DSMeterGetNameResponse(struct soap *soap, struct dss__DSMeterGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DSMeterGetNameResponse(struct soap *soap, const struct dss__DSMeterGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DSMeterGetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__DSMeterGetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DSMeterGetNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DSMeterGetNameResponse * SOAP_FMAC4 soap_in_dss__DSMeterGetNameResponse(struct soap *soap, const char *tag, struct dss__DSMeterGetNameResponse *a, const char *type)
{
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DSMeterGetNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DSMeterGetNameResponse, sizeof(struct dss__DSMeterGetNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__DSMeterGetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DSMeterGetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DSMeterGetNameResponse, 0, sizeof(struct dss__DSMeterGetNameResponse), 0, soap_copy_dss__DSMeterGetNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DSMeterGetNameResponse(struct soap *soap, const struct dss__DSMeterGetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DSMeterGetNameResponse);
	if (soap_out_dss__DSMeterGetNameResponse(soap, tag?tag:"dss:DSMeterGetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DSMeterGetNameResponse * SOAP_FMAC4 soap_get_dss__DSMeterGetNameResponse(struct soap *soap, struct dss__DSMeterGetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DSMeterGetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DSMeterGetNameResponse * SOAP_FMAC2 soap_instantiate_dss__DSMeterGetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DSMeterGetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DSMeterGetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DSMeterGetNameResponse);
		if (size)
			*size = sizeof(struct dss__DSMeterGetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DSMeterGetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DSMeterGetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DSMeterGetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DSMeterGetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DSMeterGetNameResponse %p -> %p\n", q, p));
	*(struct dss__DSMeterGetNameResponse*)p = *(struct dss__DSMeterGetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDSMeterIDs(struct soap *soap, struct dss__ApartmentGetDSMeterIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDSMeterIDs(struct soap *soap, const struct dss__ApartmentGetDSMeterIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDSMeterIDs(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDSMeterIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDSMeterIDs), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDSMeterIDs * SOAP_FMAC4 soap_in_dss__ApartmentGetDSMeterIDs(struct soap *soap, const char *tag, struct dss__ApartmentGetDSMeterIDs *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDSMeterIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDSMeterIDs, sizeof(struct dss__ApartmentGetDSMeterIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDSMeterIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDSMeterIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDSMeterIDs, 0, sizeof(struct dss__ApartmentGetDSMeterIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDSMeterIDs(struct soap *soap, const struct dss__ApartmentGetDSMeterIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDSMeterIDs);
	if (soap_out_dss__ApartmentGetDSMeterIDs(soap, tag?tag:"dss:ApartmentGetDSMeterIDs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetDSMeterIDs * SOAP_FMAC4 soap_get_dss__ApartmentGetDSMeterIDs(struct soap *soap, struct dss__ApartmentGetDSMeterIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDSMeterIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetDSMeterIDs * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetDSMeterIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDSMeterIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDSMeterIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDSMeterIDs);
		if (size)
			*size = sizeof(struct dss__ApartmentGetDSMeterIDs);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDSMeterIDs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDSMeterIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDSMeterIDs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDSMeterIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDSMeterIDs %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDSMeterIDs*)p = *(struct dss__ApartmentGetDSMeterIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, struct dss__ApartmentGetDSMeterIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->ids);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, const struct dss__ApartmentGetDSMeterIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDSMeterIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDSMeterIDsResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetDSMeterIDsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDSMeterIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse, sizeof(struct dss__ApartmentGetDSMeterIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDSMeterIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ids", &a->ids, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDSMeterIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse, 0, sizeof(struct dss__ApartmentGetDSMeterIDsResponse), 0, soap_copy_dss__ApartmentGetDSMeterIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ids.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, const struct dss__ApartmentGetDSMeterIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse);
	if (soap_out_dss__ApartmentGetDSMeterIDsResponse(soap, tag?tag:"dss:ApartmentGetDSMeterIDsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetDSMeterIDsResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, struct dss__ApartmentGetDSMeterIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDSMeterIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetDSMeterIDsResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDSMeterIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDSMeterIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDSMeterIDsResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentGetDSMeterIDsResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDSMeterIDsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDSMeterIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDSMeterIDsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDSMeterIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDSMeterIDsResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDSMeterIDsResponse*)p = *(struct dss__ApartmentGetDSMeterIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DSMeterGetPowerConsumption(struct soap *soap, struct dss__DSMeterGetPowerConsumption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_dsMeterID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DSMeterGetPowerConsumption(struct soap *soap, const struct dss__DSMeterGetPowerConsumption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_dsMeterID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DSMeterGetPowerConsumption(struct soap *soap, const char *tag, int id, const struct dss__DSMeterGetPowerConsumption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DSMeterGetPowerConsumption), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "dsMeterID", -1, &a->_dsMeterID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DSMeterGetPowerConsumption * SOAP_FMAC4 soap_in_dss__DSMeterGetPowerConsumption(struct soap *soap, const char *tag, struct dss__DSMeterGetPowerConsumption *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__dsMeterID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DSMeterGetPowerConsumption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DSMeterGetPowerConsumption, sizeof(struct dss__DSMeterGetPowerConsumption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DSMeterGetPowerConsumption(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__dsMeterID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_dsMeterID, "xsd:string"))
				{	soap_flag__dsMeterID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DSMeterGetPowerConsumption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DSMeterGetPowerConsumption, 0, sizeof(struct dss__DSMeterGetPowerConsumption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DSMeterGetPowerConsumption(struct soap *soap, const struct dss__DSMeterGetPowerConsumption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DSMeterGetPowerConsumption);
	if (soap_out_dss__DSMeterGetPowerConsumption(soap, tag?tag:"dss:DSMeterGetPowerConsumption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DSMeterGetPowerConsumption * SOAP_FMAC4 soap_get_dss__DSMeterGetPowerConsumption(struct soap *soap, struct dss__DSMeterGetPowerConsumption *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DSMeterGetPowerConsumption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DSMeterGetPowerConsumption * SOAP_FMAC2 soap_instantiate_dss__DSMeterGetPowerConsumption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DSMeterGetPowerConsumption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DSMeterGetPowerConsumption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DSMeterGetPowerConsumption);
		if (size)
			*size = sizeof(struct dss__DSMeterGetPowerConsumption);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DSMeterGetPowerConsumption[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DSMeterGetPowerConsumption);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DSMeterGetPowerConsumption*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DSMeterGetPowerConsumption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DSMeterGetPowerConsumption %p -> %p\n", q, p));
	*(struct dss__DSMeterGetPowerConsumption*)p = *(struct dss__DSMeterGetPowerConsumption*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, struct dss__DSMeterGetPowerConsumptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__unsignedInt(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, const struct dss__DSMeterGetPowerConsumptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, const char *tag, int id, const struct dss__DSMeterGetPowerConsumptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse), type))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DSMeterGetPowerConsumptionResponse * SOAP_FMAC4 soap_in_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, const char *tag, struct dss__DSMeterGetPowerConsumptionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DSMeterGetPowerConsumptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse, sizeof(struct dss__DSMeterGetPowerConsumptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DSMeterGetPowerConsumptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, "result", &a->result, "xsd:unsignedInt"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DSMeterGetPowerConsumptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse, 0, sizeof(struct dss__DSMeterGetPowerConsumptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, const struct dss__DSMeterGetPowerConsumptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse);
	if (soap_out_dss__DSMeterGetPowerConsumptionResponse(soap, tag?tag:"dss:DSMeterGetPowerConsumptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DSMeterGetPowerConsumptionResponse * SOAP_FMAC4 soap_get_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, struct dss__DSMeterGetPowerConsumptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DSMeterGetPowerConsumptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DSMeterGetPowerConsumptionResponse * SOAP_FMAC2 soap_instantiate_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DSMeterGetPowerConsumptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DSMeterGetPowerConsumptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DSMeterGetPowerConsumptionResponse);
		if (size)
			*size = sizeof(struct dss__DSMeterGetPowerConsumptionResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DSMeterGetPowerConsumptionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DSMeterGetPowerConsumptionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DSMeterGetPowerConsumptionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DSMeterGetPowerConsumptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DSMeterGetPowerConsumptionResponse %p -> %p\n", q, p));
	*(struct dss__DSMeterGetPowerConsumptionResponse*)p = *(struct dss__DSMeterGetPowerConsumptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetIsLocked(struct soap *soap, struct dss__DeviceGetIsLocked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetIsLocked(struct soap *soap, const struct dss__DeviceGetIsLocked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetIsLocked(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetIsLocked *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetIsLocked), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetIsLocked * SOAP_FMAC4 soap_in_dss__DeviceGetIsLocked(struct soap *soap, const char *tag, struct dss__DeviceGetIsLocked *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetIsLocked *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetIsLocked, sizeof(struct dss__DeviceGetIsLocked), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetIsLocked(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetIsLocked *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetIsLocked, 0, sizeof(struct dss__DeviceGetIsLocked), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetIsLocked(struct soap *soap, const struct dss__DeviceGetIsLocked *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetIsLocked);
	if (soap_out_dss__DeviceGetIsLocked(soap, tag?tag:"dss:DeviceGetIsLocked", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetIsLocked * SOAP_FMAC4 soap_get_dss__DeviceGetIsLocked(struct soap *soap, struct dss__DeviceGetIsLocked *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetIsLocked(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetIsLocked * SOAP_FMAC2 soap_instantiate_dss__DeviceGetIsLocked(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetIsLocked(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetIsLocked, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetIsLocked);
		if (size)
			*size = sizeof(struct dss__DeviceGetIsLocked);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetIsLocked[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetIsLocked);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetIsLocked*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetIsLocked(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetIsLocked %p -> %p\n", q, p));
	*(struct dss__DeviceGetIsLocked*)p = *(struct dss__DeviceGetIsLocked*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetIsLockedResponse(struct soap *soap, struct dss__DeviceGetIsLockedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetIsLockedResponse(struct soap *soap, const struct dss__DeviceGetIsLockedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetIsLockedResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetIsLockedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetIsLockedResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetIsLockedResponse * SOAP_FMAC4 soap_in_dss__DeviceGetIsLockedResponse(struct soap *soap, const char *tag, struct dss__DeviceGetIsLockedResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetIsLockedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetIsLockedResponse, sizeof(struct dss__DeviceGetIsLockedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetIsLockedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetIsLockedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetIsLockedResponse, 0, sizeof(struct dss__DeviceGetIsLockedResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetIsLockedResponse(struct soap *soap, const struct dss__DeviceGetIsLockedResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetIsLockedResponse);
	if (soap_out_dss__DeviceGetIsLockedResponse(soap, tag?tag:"dss:DeviceGetIsLockedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetIsLockedResponse * SOAP_FMAC4 soap_get_dss__DeviceGetIsLockedResponse(struct soap *soap, struct dss__DeviceGetIsLockedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetIsLockedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetIsLockedResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceGetIsLockedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetIsLockedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetIsLockedResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetIsLockedResponse);
		if (size)
			*size = sizeof(struct dss__DeviceGetIsLockedResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetIsLockedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetIsLockedResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetIsLockedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetIsLockedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetIsLockedResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetIsLockedResponse*)p = *(struct dss__DeviceGetIsLockedResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceUnlock(struct soap *soap, struct dss__DeviceUnlock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceUnlock(struct soap *soap, const struct dss__DeviceUnlock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceUnlock(struct soap *soap, const char *tag, int id, const struct dss__DeviceUnlock *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceUnlock), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceUnlock * SOAP_FMAC4 soap_in_dss__DeviceUnlock(struct soap *soap, const char *tag, struct dss__DeviceUnlock *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceUnlock *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceUnlock, sizeof(struct dss__DeviceUnlock), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceUnlock(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceUnlock *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceUnlock, 0, sizeof(struct dss__DeviceUnlock), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceUnlock(struct soap *soap, const struct dss__DeviceUnlock *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceUnlock);
	if (soap_out_dss__DeviceUnlock(soap, tag?tag:"dss:DeviceUnlock", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceUnlock * SOAP_FMAC4 soap_get_dss__DeviceUnlock(struct soap *soap, struct dss__DeviceUnlock *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceUnlock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceUnlock * SOAP_FMAC2 soap_instantiate_dss__DeviceUnlock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceUnlock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceUnlock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceUnlock);
		if (size)
			*size = sizeof(struct dss__DeviceUnlock);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceUnlock[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceUnlock);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceUnlock*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceUnlock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceUnlock %p -> %p\n", q, p));
	*(struct dss__DeviceUnlock*)p = *(struct dss__DeviceUnlock*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceUnlockResponse(struct soap *soap, struct dss__DeviceUnlockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceUnlockResponse(struct soap *soap, const struct dss__DeviceUnlockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceUnlockResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceUnlockResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceUnlockResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceUnlockResponse * SOAP_FMAC4 soap_in_dss__DeviceUnlockResponse(struct soap *soap, const char *tag, struct dss__DeviceUnlockResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceUnlockResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceUnlockResponse, sizeof(struct dss__DeviceUnlockResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceUnlockResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceUnlockResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceUnlockResponse, 0, sizeof(struct dss__DeviceUnlockResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceUnlockResponse(struct soap *soap, const struct dss__DeviceUnlockResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceUnlockResponse);
	if (soap_out_dss__DeviceUnlockResponse(soap, tag?tag:"dss:DeviceUnlockResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceUnlockResponse * SOAP_FMAC4 soap_get_dss__DeviceUnlockResponse(struct soap *soap, struct dss__DeviceUnlockResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceUnlockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceUnlockResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceUnlockResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceUnlockResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceUnlockResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceUnlockResponse);
		if (size)
			*size = sizeof(struct dss__DeviceUnlockResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceUnlockResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceUnlockResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceUnlockResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceUnlockResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceUnlockResponse %p -> %p\n", q, p));
	*(struct dss__DeviceUnlockResponse*)p = *(struct dss__DeviceUnlockResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceLock(struct soap *soap, struct dss__DeviceLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceLock(struct soap *soap, const struct dss__DeviceLock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceLock(struct soap *soap, const char *tag, int id, const struct dss__DeviceLock *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceLock), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceLock * SOAP_FMAC4 soap_in_dss__DeviceLock(struct soap *soap, const char *tag, struct dss__DeviceLock *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceLock *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceLock, sizeof(struct dss__DeviceLock), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceLock(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceLock *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceLock, 0, sizeof(struct dss__DeviceLock), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceLock(struct soap *soap, const struct dss__DeviceLock *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceLock);
	if (soap_out_dss__DeviceLock(soap, tag?tag:"dss:DeviceLock", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceLock * SOAP_FMAC4 soap_get_dss__DeviceLock(struct soap *soap, struct dss__DeviceLock *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceLock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceLock * SOAP_FMAC2 soap_instantiate_dss__DeviceLock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceLock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceLock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceLock);
		if (size)
			*size = sizeof(struct dss__DeviceLock);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceLock[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceLock);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceLock*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceLock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceLock %p -> %p\n", q, p));
	*(struct dss__DeviceLock*)p = *(struct dss__DeviceLock*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceLockResponse(struct soap *soap, struct dss__DeviceLockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceLockResponse(struct soap *soap, const struct dss__DeviceLockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceLockResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceLockResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceLockResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceLockResponse * SOAP_FMAC4 soap_in_dss__DeviceLockResponse(struct soap *soap, const char *tag, struct dss__DeviceLockResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceLockResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceLockResponse, sizeof(struct dss__DeviceLockResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceLockResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceLockResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceLockResponse, 0, sizeof(struct dss__DeviceLockResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceLockResponse(struct soap *soap, const struct dss__DeviceLockResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceLockResponse);
	if (soap_out_dss__DeviceLockResponse(soap, tag?tag:"dss:DeviceLockResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceLockResponse * SOAP_FMAC4 soap_get_dss__DeviceLockResponse(struct soap *soap, struct dss__DeviceLockResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceLockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceLockResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceLockResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceLockResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceLockResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceLockResponse);
		if (size)
			*size = sizeof(struct dss__DeviceLockResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceLockResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceLockResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceLockResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceLockResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceLockResponse %p -> %p\n", q, p));
	*(struct dss__DeviceLockResponse*)p = *(struct dss__DeviceLockResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetTags(struct soap *soap, struct dss__DeviceGetTags *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetTags(struct soap *soap, const struct dss__DeviceGetTags *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetTags(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetTags *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetTags), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetTags * SOAP_FMAC4 soap_in_dss__DeviceGetTags(struct soap *soap, const char *tag, struct dss__DeviceGetTags *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetTags *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetTags, sizeof(struct dss__DeviceGetTags), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetTags(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetTags *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetTags, 0, sizeof(struct dss__DeviceGetTags), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetTags(struct soap *soap, const struct dss__DeviceGetTags *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetTags);
	if (soap_out_dss__DeviceGetTags(soap, tag?tag:"dss:DeviceGetTags", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetTags * SOAP_FMAC4 soap_get_dss__DeviceGetTags(struct soap *soap, struct dss__DeviceGetTags *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetTags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetTags * SOAP_FMAC2 soap_instantiate_dss__DeviceGetTags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetTags(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetTags, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetTags);
		if (size)
			*size = sizeof(struct dss__DeviceGetTags);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetTags[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetTags);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetTags*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetTags(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetTags %p -> %p\n", q, p));
	*(struct dss__DeviceGetTags*)p = *(struct dss__DeviceGetTags*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetTagsResponse(struct soap *soap, struct dss__DeviceGetTagsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetTagsResponse(struct soap *soap, const struct dss__DeviceGetTagsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetTagsResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetTagsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetTagsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetTagsResponse * SOAP_FMAC4 soap_in_dss__DeviceGetTagsResponse(struct soap *soap, const char *tag, struct dss__DeviceGetTagsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetTagsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetTagsResponse, sizeof(struct dss__DeviceGetTagsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetTagsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "result", &a->result, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetTagsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetTagsResponse, 0, sizeof(struct dss__DeviceGetTagsResponse), 0, soap_copy_dss__DeviceGetTagsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->result.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetTagsResponse(struct soap *soap, const struct dss__DeviceGetTagsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetTagsResponse);
	if (soap_out_dss__DeviceGetTagsResponse(soap, tag?tag:"dss:DeviceGetTagsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetTagsResponse * SOAP_FMAC4 soap_get_dss__DeviceGetTagsResponse(struct soap *soap, struct dss__DeviceGetTagsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetTagsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetTagsResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceGetTagsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetTagsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetTagsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetTagsResponse);
		if (size)
			*size = sizeof(struct dss__DeviceGetTagsResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetTagsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetTagsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetTagsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetTagsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetTagsResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetTagsResponse*)p = *(struct dss__DeviceGetTagsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceHasTag(struct soap *soap, struct dss__DeviceHasTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_string(soap, &a->_tag);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceHasTag(struct soap *soap, const struct dss__DeviceHasTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
	soap_serialize_string(soap, &a->_tag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceHasTag(struct soap *soap, const char *tag, int id, const struct dss__DeviceHasTag *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceHasTag), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_string(soap, "tag", -1, &a->_tag, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceHasTag * SOAP_FMAC4 soap_in_dss__DeviceHasTag(struct soap *soap, const char *tag, struct dss__DeviceHasTag *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__tag = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceHasTag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceHasTag, sizeof(struct dss__DeviceHasTag), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceHasTag(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__tag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_tag, "xsd:string"))
				{	soap_flag__tag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceHasTag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceHasTag, 0, sizeof(struct dss__DeviceHasTag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceHasTag(struct soap *soap, const struct dss__DeviceHasTag *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceHasTag);
	if (soap_out_dss__DeviceHasTag(soap, tag?tag:"dss:DeviceHasTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceHasTag * SOAP_FMAC4 soap_get_dss__DeviceHasTag(struct soap *soap, struct dss__DeviceHasTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceHasTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceHasTag * SOAP_FMAC2 soap_instantiate_dss__DeviceHasTag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceHasTag(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceHasTag, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceHasTag);
		if (size)
			*size = sizeof(struct dss__DeviceHasTag);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceHasTag[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceHasTag);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceHasTag*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceHasTag(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceHasTag %p -> %p\n", q, p));
	*(struct dss__DeviceHasTag*)p = *(struct dss__DeviceHasTag*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceHasTagResponse(struct soap *soap, struct dss__DeviceHasTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceHasTagResponse(struct soap *soap, const struct dss__DeviceHasTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceHasTagResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceHasTagResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceHasTagResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceHasTagResponse * SOAP_FMAC4 soap_in_dss__DeviceHasTagResponse(struct soap *soap, const char *tag, struct dss__DeviceHasTagResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceHasTagResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceHasTagResponse, sizeof(struct dss__DeviceHasTagResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceHasTagResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceHasTagResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceHasTagResponse, 0, sizeof(struct dss__DeviceHasTagResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceHasTagResponse(struct soap *soap, const struct dss__DeviceHasTagResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceHasTagResponse);
	if (soap_out_dss__DeviceHasTagResponse(soap, tag?tag:"dss:DeviceHasTagResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceHasTagResponse * SOAP_FMAC4 soap_get_dss__DeviceHasTagResponse(struct soap *soap, struct dss__DeviceHasTagResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceHasTagResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceHasTagResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceHasTagResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceHasTagResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceHasTagResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceHasTagResponse);
		if (size)
			*size = sizeof(struct dss__DeviceHasTagResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceHasTagResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceHasTagResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceHasTagResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceHasTagResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceHasTagResponse %p -> %p\n", q, p));
	*(struct dss__DeviceHasTagResponse*)p = *(struct dss__DeviceHasTagResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceRemoveTag(struct soap *soap, struct dss__DeviceRemoveTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_string(soap, &a->_tag);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceRemoveTag(struct soap *soap, const struct dss__DeviceRemoveTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
	soap_serialize_string(soap, &a->_tag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceRemoveTag(struct soap *soap, const char *tag, int id, const struct dss__DeviceRemoveTag *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceRemoveTag), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_string(soap, "tag", -1, &a->_tag, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceRemoveTag * SOAP_FMAC4 soap_in_dss__DeviceRemoveTag(struct soap *soap, const char *tag, struct dss__DeviceRemoveTag *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__tag = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceRemoveTag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceRemoveTag, sizeof(struct dss__DeviceRemoveTag), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceRemoveTag(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__tag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_tag, "xsd:string"))
				{	soap_flag__tag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceRemoveTag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceRemoveTag, 0, sizeof(struct dss__DeviceRemoveTag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceRemoveTag(struct soap *soap, const struct dss__DeviceRemoveTag *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceRemoveTag);
	if (soap_out_dss__DeviceRemoveTag(soap, tag?tag:"dss:DeviceRemoveTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceRemoveTag * SOAP_FMAC4 soap_get_dss__DeviceRemoveTag(struct soap *soap, struct dss__DeviceRemoveTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceRemoveTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceRemoveTag * SOAP_FMAC2 soap_instantiate_dss__DeviceRemoveTag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceRemoveTag(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceRemoveTag, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceRemoveTag);
		if (size)
			*size = sizeof(struct dss__DeviceRemoveTag);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceRemoveTag[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceRemoveTag);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceRemoveTag*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceRemoveTag(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceRemoveTag %p -> %p\n", q, p));
	*(struct dss__DeviceRemoveTag*)p = *(struct dss__DeviceRemoveTag*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceRemoveTagResponse(struct soap *soap, struct dss__DeviceRemoveTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceRemoveTagResponse(struct soap *soap, const struct dss__DeviceRemoveTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceRemoveTagResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceRemoveTagResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceRemoveTagResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceRemoveTagResponse * SOAP_FMAC4 soap_in_dss__DeviceRemoveTagResponse(struct soap *soap, const char *tag, struct dss__DeviceRemoveTagResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceRemoveTagResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceRemoveTagResponse, sizeof(struct dss__DeviceRemoveTagResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceRemoveTagResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceRemoveTagResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceRemoveTagResponse, 0, sizeof(struct dss__DeviceRemoveTagResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceRemoveTagResponse(struct soap *soap, const struct dss__DeviceRemoveTagResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceRemoveTagResponse);
	if (soap_out_dss__DeviceRemoveTagResponse(soap, tag?tag:"dss:DeviceRemoveTagResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceRemoveTagResponse * SOAP_FMAC4 soap_get_dss__DeviceRemoveTagResponse(struct soap *soap, struct dss__DeviceRemoveTagResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceRemoveTagResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceRemoveTagResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceRemoveTagResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceRemoveTagResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceRemoveTagResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceRemoveTagResponse);
		if (size)
			*size = sizeof(struct dss__DeviceRemoveTagResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceRemoveTagResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceRemoveTagResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceRemoveTagResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceRemoveTagResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceRemoveTagResponse %p -> %p\n", q, p));
	*(struct dss__DeviceRemoveTagResponse*)p = *(struct dss__DeviceRemoveTagResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceAddTag(struct soap *soap, struct dss__DeviceAddTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_string(soap, &a->_tag);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceAddTag(struct soap *soap, const struct dss__DeviceAddTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
	soap_serialize_string(soap, &a->_tag);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceAddTag(struct soap *soap, const char *tag, int id, const struct dss__DeviceAddTag *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceAddTag), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_string(soap, "tag", -1, &a->_tag, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceAddTag * SOAP_FMAC4 soap_in_dss__DeviceAddTag(struct soap *soap, const char *tag, struct dss__DeviceAddTag *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__tag = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceAddTag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceAddTag, sizeof(struct dss__DeviceAddTag), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceAddTag(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__tag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_tag, "xsd:string"))
				{	soap_flag__tag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceAddTag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceAddTag, 0, sizeof(struct dss__DeviceAddTag), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceAddTag(struct soap *soap, const struct dss__DeviceAddTag *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceAddTag);
	if (soap_out_dss__DeviceAddTag(soap, tag?tag:"dss:DeviceAddTag", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceAddTag * SOAP_FMAC4 soap_get_dss__DeviceAddTag(struct soap *soap, struct dss__DeviceAddTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceAddTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceAddTag * SOAP_FMAC2 soap_instantiate_dss__DeviceAddTag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceAddTag(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceAddTag, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceAddTag);
		if (size)
			*size = sizeof(struct dss__DeviceAddTag);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceAddTag[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceAddTag);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceAddTag*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceAddTag(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceAddTag %p -> %p\n", q, p));
	*(struct dss__DeviceAddTag*)p = *(struct dss__DeviceAddTag*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceAddTagResponse(struct soap *soap, struct dss__DeviceAddTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceAddTagResponse(struct soap *soap, const struct dss__DeviceAddTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceAddTagResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceAddTagResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceAddTagResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceAddTagResponse * SOAP_FMAC4 soap_in_dss__DeviceAddTagResponse(struct soap *soap, const char *tag, struct dss__DeviceAddTagResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceAddTagResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceAddTagResponse, sizeof(struct dss__DeviceAddTagResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceAddTagResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceAddTagResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceAddTagResponse, 0, sizeof(struct dss__DeviceAddTagResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceAddTagResponse(struct soap *soap, const struct dss__DeviceAddTagResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceAddTagResponse);
	if (soap_out_dss__DeviceAddTagResponse(soap, tag?tag:"dss:DeviceAddTagResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceAddTagResponse * SOAP_FMAC4 soap_get_dss__DeviceAddTagResponse(struct soap *soap, struct dss__DeviceAddTagResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceAddTagResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceAddTagResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceAddTagResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceAddTagResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceAddTagResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceAddTagResponse);
		if (size)
			*size = sizeof(struct dss__DeviceAddTagResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceAddTagResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceAddTagResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceAddTagResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceAddTagResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceAddTagResponse %p -> %p\n", q, p));
	*(struct dss__DeviceAddTagResponse*)p = *(struct dss__DeviceAddTagResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetZoneID(struct soap *soap, struct dss__DeviceGetZoneID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetZoneID(struct soap *soap, const struct dss__DeviceGetZoneID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetZoneID(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetZoneID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetZoneID), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetZoneID * SOAP_FMAC4 soap_in_dss__DeviceGetZoneID(struct soap *soap, const char *tag, struct dss__DeviceGetZoneID *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetZoneID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetZoneID, sizeof(struct dss__DeviceGetZoneID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetZoneID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetZoneID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetZoneID, 0, sizeof(struct dss__DeviceGetZoneID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetZoneID(struct soap *soap, const struct dss__DeviceGetZoneID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetZoneID);
	if (soap_out_dss__DeviceGetZoneID(soap, tag?tag:"dss:DeviceGetZoneID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetZoneID * SOAP_FMAC4 soap_get_dss__DeviceGetZoneID(struct soap *soap, struct dss__DeviceGetZoneID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetZoneID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetZoneID * SOAP_FMAC2 soap_instantiate_dss__DeviceGetZoneID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetZoneID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetZoneID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetZoneID);
		if (size)
			*size = sizeof(struct dss__DeviceGetZoneID);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetZoneID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetZoneID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetZoneID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetZoneID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetZoneID %p -> %p\n", q, p));
	*(struct dss__DeviceGetZoneID*)p = *(struct dss__DeviceGetZoneID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetZoneIDResponse(struct soap *soap, struct dss__DeviceGetZoneIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetZoneIDResponse(struct soap *soap, const struct dss__DeviceGetZoneIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetZoneIDResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetZoneIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetZoneIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetZoneIDResponse * SOAP_FMAC4 soap_in_dss__DeviceGetZoneIDResponse(struct soap *soap, const char *tag, struct dss__DeviceGetZoneIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetZoneIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetZoneIDResponse, sizeof(struct dss__DeviceGetZoneIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetZoneIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetZoneIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetZoneIDResponse, 0, sizeof(struct dss__DeviceGetZoneIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetZoneIDResponse(struct soap *soap, const struct dss__DeviceGetZoneIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetZoneIDResponse);
	if (soap_out_dss__DeviceGetZoneIDResponse(soap, tag?tag:"dss:DeviceGetZoneIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetZoneIDResponse * SOAP_FMAC4 soap_get_dss__DeviceGetZoneIDResponse(struct soap *soap, struct dss__DeviceGetZoneIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetZoneIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetZoneIDResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceGetZoneIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetZoneIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetZoneIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetZoneIDResponse);
		if (size)
			*size = sizeof(struct dss__DeviceGetZoneIDResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetZoneIDResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetZoneIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetZoneIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetZoneIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetZoneIDResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetZoneIDResponse*)p = *(struct dss__DeviceGetZoneIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetName(struct soap *soap, struct dss__DeviceSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetName(struct soap *soap, const struct dss__DeviceSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetName(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetName * SOAP_FMAC4 soap_in_dss__DeviceSetName(struct soap *soap, const char *tag, struct dss__DeviceSetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetName, sizeof(struct dss__DeviceSetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetName, 0, sizeof(struct dss__DeviceSetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetName(struct soap *soap, const struct dss__DeviceSetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetName);
	if (soap_out_dss__DeviceSetName(soap, tag?tag:"dss:DeviceSetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSetName * SOAP_FMAC4 soap_get_dss__DeviceSetName(struct soap *soap, struct dss__DeviceSetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSetName * SOAP_FMAC2 soap_instantiate_dss__DeviceSetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSetName);
		if (size)
			*size = sizeof(struct dss__DeviceSetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetName %p -> %p\n", q, p));
	*(struct dss__DeviceSetName*)p = *(struct dss__DeviceSetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetNameResponse(struct soap *soap, struct dss__DeviceSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetNameResponse(struct soap *soap, const struct dss__DeviceSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetNameResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetNameResponse * SOAP_FMAC4 soap_in_dss__DeviceSetNameResponse(struct soap *soap, const char *tag, struct dss__DeviceSetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetNameResponse, sizeof(struct dss__DeviceSetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetNameResponse, 0, sizeof(struct dss__DeviceSetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetNameResponse(struct soap *soap, const struct dss__DeviceSetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetNameResponse);
	if (soap_out_dss__DeviceSetNameResponse(soap, tag?tag:"dss:DeviceSetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSetNameResponse * SOAP_FMAC4 soap_get_dss__DeviceSetNameResponse(struct soap *soap, struct dss__DeviceSetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSetNameResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceSetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSetNameResponse);
		if (size)
			*size = sizeof(struct dss__DeviceSetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetNameResponse %p -> %p\n", q, p));
	*(struct dss__DeviceSetNameResponse*)p = *(struct dss__DeviceSetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetName(struct soap *soap, struct dss__DeviceGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetName(struct soap *soap, const struct dss__DeviceGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetName(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetName * SOAP_FMAC4 soap_in_dss__DeviceGetName(struct soap *soap, const char *tag, struct dss__DeviceGetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetName, sizeof(struct dss__DeviceGetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetName, 0, sizeof(struct dss__DeviceGetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetName(struct soap *soap, const struct dss__DeviceGetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetName);
	if (soap_out_dss__DeviceGetName(soap, tag?tag:"dss:DeviceGetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetName * SOAP_FMAC4 soap_get_dss__DeviceGetName(struct soap *soap, struct dss__DeviceGetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetName * SOAP_FMAC2 soap_instantiate_dss__DeviceGetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetName);
		if (size)
			*size = sizeof(struct dss__DeviceGetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetName %p -> %p\n", q, p));
	*(struct dss__DeviceGetName*)p = *(struct dss__DeviceGetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetNameResponse(struct soap *soap, struct dss__DeviceGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetNameResponse(struct soap *soap, const struct dss__DeviceGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetNameResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetNameResponse * SOAP_FMAC4 soap_in_dss__DeviceGetNameResponse(struct soap *soap, const char *tag, struct dss__DeviceGetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetNameResponse, sizeof(struct dss__DeviceGetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetNameResponse, 0, sizeof(struct dss__DeviceGetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetNameResponse(struct soap *soap, const struct dss__DeviceGetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetNameResponse);
	if (soap_out_dss__DeviceGetNameResponse(soap, tag?tag:"dss:DeviceGetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetNameResponse * SOAP_FMAC4 soap_get_dss__DeviceGetNameResponse(struct soap *soap, struct dss__DeviceGetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetNameResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceGetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetNameResponse);
		if (size)
			*size = sizeof(struct dss__DeviceGetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetNameResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetNameResponse*)p = *(struct dss__DeviceGetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSaveScene(struct soap *soap, struct dss__DeviceSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSaveScene(struct soap *soap, const struct dss__DeviceSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSaveScene(struct soap *soap, const char *tag, int id, const struct dss__DeviceSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSaveScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSaveScene * SOAP_FMAC4 soap_in_dss__DeviceSaveScene(struct soap *soap, const char *tag, struct dss__DeviceSaveScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSaveScene, sizeof(struct dss__DeviceSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSaveScene, 0, sizeof(struct dss__DeviceSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSaveScene(struct soap *soap, const struct dss__DeviceSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSaveScene);
	if (soap_out_dss__DeviceSaveScene(soap, tag?tag:"dss:DeviceSaveScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSaveScene * SOAP_FMAC4 soap_get_dss__DeviceSaveScene(struct soap *soap, struct dss__DeviceSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSaveScene * SOAP_FMAC2 soap_instantiate_dss__DeviceSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSaveScene);
		if (size)
			*size = sizeof(struct dss__DeviceSaveScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSaveScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSaveScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSaveScene %p -> %p\n", q, p));
	*(struct dss__DeviceSaveScene*)p = *(struct dss__DeviceSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSaveSceneResponse(struct soap *soap, struct dss__DeviceSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSaveSceneResponse(struct soap *soap, const struct dss__DeviceSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSaveSceneResponse * SOAP_FMAC4 soap_in_dss__DeviceSaveSceneResponse(struct soap *soap, const char *tag, struct dss__DeviceSaveSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSaveSceneResponse, sizeof(struct dss__DeviceSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSaveSceneResponse, 0, sizeof(struct dss__DeviceSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSaveSceneResponse(struct soap *soap, const struct dss__DeviceSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSaveSceneResponse);
	if (soap_out_dss__DeviceSaveSceneResponse(soap, tag?tag:"dss:DeviceSaveSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSaveSceneResponse * SOAP_FMAC4 soap_get_dss__DeviceSaveSceneResponse(struct soap *soap, struct dss__DeviceSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSaveSceneResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSaveSceneResponse);
		if (size)
			*size = sizeof(struct dss__DeviceSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSaveSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSaveSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__DeviceSaveSceneResponse*)p = *(struct dss__DeviceSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceCallScene(struct soap *soap, struct dss__DeviceCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceCallScene(struct soap *soap, const struct dss__DeviceCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceCallScene(struct soap *soap, const char *tag, int id, const struct dss__DeviceCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceCallScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceCallScene * SOAP_FMAC4 soap_in_dss__DeviceCallScene(struct soap *soap, const char *tag, struct dss__DeviceCallScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceCallScene, sizeof(struct dss__DeviceCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceCallScene, 0, sizeof(struct dss__DeviceCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceCallScene(struct soap *soap, const struct dss__DeviceCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceCallScene);
	if (soap_out_dss__DeviceCallScene(soap, tag?tag:"dss:DeviceCallScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceCallScene * SOAP_FMAC4 soap_get_dss__DeviceCallScene(struct soap *soap, struct dss__DeviceCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceCallScene * SOAP_FMAC2 soap_instantiate_dss__DeviceCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceCallScene);
		if (size)
			*size = sizeof(struct dss__DeviceCallScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceCallScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceCallScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceCallScene %p -> %p\n", q, p));
	*(struct dss__DeviceCallScene*)p = *(struct dss__DeviceCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceCallSceneResponse(struct soap *soap, struct dss__DeviceCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceCallSceneResponse(struct soap *soap, const struct dss__DeviceCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceCallSceneResponse * SOAP_FMAC4 soap_in_dss__DeviceCallSceneResponse(struct soap *soap, const char *tag, struct dss__DeviceCallSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceCallSceneResponse, sizeof(struct dss__DeviceCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceCallSceneResponse, 0, sizeof(struct dss__DeviceCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceCallSceneResponse(struct soap *soap, const struct dss__DeviceCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceCallSceneResponse);
	if (soap_out_dss__DeviceCallSceneResponse(soap, tag?tag:"dss:DeviceCallSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceCallSceneResponse * SOAP_FMAC4 soap_get_dss__DeviceCallSceneResponse(struct soap *soap, struct dss__DeviceCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceCallSceneResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceCallSceneResponse);
		if (size)
			*size = sizeof(struct dss__DeviceCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceCallSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceCallSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__DeviceCallSceneResponse*)p = *(struct dss__DeviceCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetConfigWord(struct soap *soap, struct dss__DeviceGetConfigWord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_unsignedByte(soap, &a->_configClass);
	soap_default_unsignedByte(soap, &a->_configIndex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetConfigWord(struct soap *soap, const struct dss__DeviceGetConfigWord *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetConfigWord(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetConfigWord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetConfigWord), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "configClass", -1, &a->_configClass, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "configIndex", -1, &a->_configIndex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetConfigWord * SOAP_FMAC4 soap_in_dss__DeviceGetConfigWord(struct soap *soap, const char *tag, struct dss__DeviceGetConfigWord *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__configClass = 1;
	size_t soap_flag__configIndex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetConfigWord *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetConfigWord, sizeof(struct dss__DeviceGetConfigWord), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetConfigWord(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__configClass && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_configClass, "xsd:unsignedByte"))
				{	soap_flag__configClass--;
					continue;
				}
			if (soap_flag__configIndex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_configIndex, "xsd:unsignedByte"))
				{	soap_flag__configIndex--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetConfigWord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetConfigWord, 0, sizeof(struct dss__DeviceGetConfigWord), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__configClass > 0 || soap_flag__configIndex > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetConfigWord(struct soap *soap, const struct dss__DeviceGetConfigWord *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetConfigWord);
	if (soap_out_dss__DeviceGetConfigWord(soap, tag?tag:"dss:DeviceGetConfigWord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetConfigWord * SOAP_FMAC4 soap_get_dss__DeviceGetConfigWord(struct soap *soap, struct dss__DeviceGetConfigWord *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetConfigWord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetConfigWord * SOAP_FMAC2 soap_instantiate_dss__DeviceGetConfigWord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetConfigWord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetConfigWord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfigWord);
		if (size)
			*size = sizeof(struct dss__DeviceGetConfigWord);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfigWord[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetConfigWord);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetConfigWord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetConfigWord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetConfigWord %p -> %p\n", q, p));
	*(struct dss__DeviceGetConfigWord*)p = *(struct dss__DeviceGetConfigWord*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetConfigWordResponse(struct soap *soap, struct dss__DeviceGetConfigWordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedShort(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetConfigWordResponse(struct soap *soap, const struct dss__DeviceGetConfigWordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetConfigWordResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetConfigWordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetConfigWordResponse), type))
		return soap->error;
	if (soap_out_unsignedShort(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetConfigWordResponse * SOAP_FMAC4 soap_in_dss__DeviceGetConfigWordResponse(struct soap *soap, const char *tag, struct dss__DeviceGetConfigWordResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetConfigWordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetConfigWordResponse, sizeof(struct dss__DeviceGetConfigWordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetConfigWordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedShort(soap, "result", &a->result, "xsd:unsignedShort"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetConfigWordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetConfigWordResponse, 0, sizeof(struct dss__DeviceGetConfigWordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetConfigWordResponse(struct soap *soap, const struct dss__DeviceGetConfigWordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetConfigWordResponse);
	if (soap_out_dss__DeviceGetConfigWordResponse(soap, tag?tag:"dss:DeviceGetConfigWordResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetConfigWordResponse * SOAP_FMAC4 soap_get_dss__DeviceGetConfigWordResponse(struct soap *soap, struct dss__DeviceGetConfigWordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetConfigWordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetConfigWordResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceGetConfigWordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetConfigWordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetConfigWordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfigWordResponse);
		if (size)
			*size = sizeof(struct dss__DeviceGetConfigWordResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfigWordResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetConfigWordResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetConfigWordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetConfigWordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetConfigWordResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetConfigWordResponse*)p = *(struct dss__DeviceGetConfigWordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetConfig(struct soap *soap, struct dss__DeviceGetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_unsignedByte(soap, &a->_configClass);
	soap_default_unsignedByte(soap, &a->_configIndex);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetConfig(struct soap *soap, const struct dss__DeviceGetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetConfig(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetConfig), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "configClass", -1, &a->_configClass, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "configIndex", -1, &a->_configIndex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetConfig * SOAP_FMAC4 soap_in_dss__DeviceGetConfig(struct soap *soap, const char *tag, struct dss__DeviceGetConfig *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__configClass = 1;
	size_t soap_flag__configIndex = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetConfig, sizeof(struct dss__DeviceGetConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__configClass && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_configClass, "xsd:unsignedByte"))
				{	soap_flag__configClass--;
					continue;
				}
			if (soap_flag__configIndex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_configIndex, "xsd:unsignedByte"))
				{	soap_flag__configIndex--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetConfig, 0, sizeof(struct dss__DeviceGetConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__configClass > 0 || soap_flag__configIndex > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetConfig(struct soap *soap, const struct dss__DeviceGetConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetConfig);
	if (soap_out_dss__DeviceGetConfig(soap, tag?tag:"dss:DeviceGetConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetConfig * SOAP_FMAC4 soap_get_dss__DeviceGetConfig(struct soap *soap, struct dss__DeviceGetConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetConfig * SOAP_FMAC2 soap_instantiate_dss__DeviceGetConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfig);
		if (size)
			*size = sizeof(struct dss__DeviceGetConfig);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfig[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetConfig %p -> %p\n", q, p));
	*(struct dss__DeviceGetConfig*)p = *(struct dss__DeviceGetConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetConfigResponse(struct soap *soap, struct dss__DeviceGetConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedByte(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetConfigResponse(struct soap *soap, const struct dss__DeviceGetConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetConfigResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetConfigResponse), type))
		return soap->error;
	if (soap_out_unsignedByte(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetConfigResponse * SOAP_FMAC4 soap_in_dss__DeviceGetConfigResponse(struct soap *soap, const char *tag, struct dss__DeviceGetConfigResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetConfigResponse, sizeof(struct dss__DeviceGetConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, "result", &a->result, "xsd:unsignedByte"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetConfigResponse, 0, sizeof(struct dss__DeviceGetConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetConfigResponse(struct soap *soap, const struct dss__DeviceGetConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetConfigResponse);
	if (soap_out_dss__DeviceGetConfigResponse(soap, tag?tag:"dss:DeviceGetConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceGetConfigResponse * SOAP_FMAC4 soap_get_dss__DeviceGetConfigResponse(struct soap *soap, struct dss__DeviceGetConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceGetConfigResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceGetConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfigResponse);
		if (size)
			*size = sizeof(struct dss__DeviceGetConfigResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceGetConfigResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetConfigResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetConfigResponse*)p = *(struct dss__DeviceGetConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetConfig(struct soap *soap, struct dss__DeviceSetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_unsignedByte(soap, &a->_configClass);
	soap_default_unsignedByte(soap, &a->_configIndex);
	soap_default_unsignedByte(soap, &a->_value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetConfig(struct soap *soap, const struct dss__DeviceSetConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetConfig(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetConfig *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetConfig), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "configClass", -1, &a->_configClass, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "configIndex", -1, &a->_configIndex, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "value", -1, &a->_value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetConfig * SOAP_FMAC4 soap_in_dss__DeviceSetConfig(struct soap *soap, const char *tag, struct dss__DeviceSetConfig *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__configClass = 1;
	size_t soap_flag__configIndex = 1;
	size_t soap_flag__value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetConfig, sizeof(struct dss__DeviceSetConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__configClass && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_configClass, "xsd:unsignedByte"))
				{	soap_flag__configClass--;
					continue;
				}
			if (soap_flag__configIndex && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_configIndex, "xsd:unsignedByte"))
				{	soap_flag__configIndex--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_value, "xsd:unsignedByte"))
				{	soap_flag__value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetConfig, 0, sizeof(struct dss__DeviceSetConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__configClass > 0 || soap_flag__configIndex > 0 || soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetConfig(struct soap *soap, const struct dss__DeviceSetConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetConfig);
	if (soap_out_dss__DeviceSetConfig(soap, tag?tag:"dss:DeviceSetConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSetConfig * SOAP_FMAC4 soap_get_dss__DeviceSetConfig(struct soap *soap, struct dss__DeviceSetConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSetConfig * SOAP_FMAC2 soap_instantiate_dss__DeviceSetConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSetConfig);
		if (size)
			*size = sizeof(struct dss__DeviceSetConfig);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSetConfig[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetConfig %p -> %p\n", q, p));
	*(struct dss__DeviceSetConfig*)p = *(struct dss__DeviceSetConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetConfigResponse(struct soap *soap, struct dss__DeviceSetConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetConfigResponse(struct soap *soap, const struct dss__DeviceSetConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetConfigResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetConfigResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetConfigResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetConfigResponse * SOAP_FMAC4 soap_in_dss__DeviceSetConfigResponse(struct soap *soap, const char *tag, struct dss__DeviceSetConfigResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetConfigResponse, sizeof(struct dss__DeviceSetConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetConfigResponse, 0, sizeof(struct dss__DeviceSetConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetConfigResponse(struct soap *soap, const struct dss__DeviceSetConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetConfigResponse);
	if (soap_out_dss__DeviceSetConfigResponse(soap, tag?tag:"dss:DeviceSetConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSetConfigResponse * SOAP_FMAC4 soap_get_dss__DeviceSetConfigResponse(struct soap *soap, struct dss__DeviceSetConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSetConfigResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceSetConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSetConfigResponse);
		if (size)
			*size = sizeof(struct dss__DeviceSetConfigResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSetConfigResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetConfigResponse %p -> %p\n", q, p));
	*(struct dss__DeviceSetConfigResponse*)p = *(struct dss__DeviceSetConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetValue(struct soap *soap, struct dss__DeviceSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_unsignedByte(soap, &a->_value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetValue(struct soap *soap, const struct dss__DeviceSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetValue(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_unsignedByte(soap, "value", -1, &a->_value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetValue * SOAP_FMAC4 soap_in_dss__DeviceSetValue(struct soap *soap, const char *tag, struct dss__DeviceSetValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	size_t soap_flag__value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetValue, sizeof(struct dss__DeviceSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedByte(soap, NULL, &a->_value, "xsd:unsignedByte"))
				{	soap_flag__value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetValue, 0, sizeof(struct dss__DeviceSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetValue(struct soap *soap, const struct dss__DeviceSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetValue);
	if (soap_out_dss__DeviceSetValue(soap, tag?tag:"dss:DeviceSetValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSetValue * SOAP_FMAC4 soap_get_dss__DeviceSetValue(struct soap *soap, struct dss__DeviceSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSetValue * SOAP_FMAC2 soap_instantiate_dss__DeviceSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSetValue);
		if (size)
			*size = sizeof(struct dss__DeviceSetValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSetValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetValue %p -> %p\n", q, p));
	*(struct dss__DeviceSetValue*)p = *(struct dss__DeviceSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetValueResponse(struct soap *soap, struct dss__DeviceSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetValueResponse(struct soap *soap, const struct dss__DeviceSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetValueResponse * SOAP_FMAC4 soap_in_dss__DeviceSetValueResponse(struct soap *soap, const char *tag, struct dss__DeviceSetValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetValueResponse, sizeof(struct dss__DeviceSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetValueResponse, 0, sizeof(struct dss__DeviceSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetValueResponse(struct soap *soap, const struct dss__DeviceSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetValueResponse);
	if (soap_out_dss__DeviceSetValueResponse(soap, tag?tag:"dss:DeviceSetValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceSetValueResponse * SOAP_FMAC4 soap_get_dss__DeviceSetValueResponse(struct soap *soap, struct dss__DeviceSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceSetValueResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceSetValueResponse);
		if (size)
			*size = sizeof(struct dss__DeviceSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceSetValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetValueResponse %p -> %p\n", q, p));
	*(struct dss__DeviceSetValueResponse*)p = *(struct dss__DeviceSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceDecreaseValue(struct soap *soap, struct dss__DeviceDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceDecreaseValue(struct soap *soap, const struct dss__DeviceDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__DeviceDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceDecreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValue * SOAP_FMAC4 soap_in_dss__DeviceDecreaseValue(struct soap *soap, const char *tag, struct dss__DeviceDecreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceDecreaseValue, sizeof(struct dss__DeviceDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceDecreaseValue, 0, sizeof(struct dss__DeviceDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceDecreaseValue(struct soap *soap, const struct dss__DeviceDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceDecreaseValue);
	if (soap_out_dss__DeviceDecreaseValue(soap, tag?tag:"dss:DeviceDecreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValue * SOAP_FMAC4 soap_get_dss__DeviceDecreaseValue(struct soap *soap, struct dss__DeviceDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceDecreaseValue * SOAP_FMAC2 soap_instantiate_dss__DeviceDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceDecreaseValue);
		if (size)
			*size = sizeof(struct dss__DeviceDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceDecreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceDecreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceDecreaseValue %p -> %p\n", q, p));
	*(struct dss__DeviceDecreaseValue*)p = *(struct dss__DeviceDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceDecreaseValueResponse(struct soap *soap, struct dss__DeviceDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceDecreaseValueResponse(struct soap *soap, const struct dss__DeviceDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__DeviceDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__DeviceDecreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceDecreaseValueResponse, sizeof(struct dss__DeviceDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceDecreaseValueResponse, 0, sizeof(struct dss__DeviceDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceDecreaseValueResponse(struct soap *soap, const struct dss__DeviceDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceDecreaseValueResponse);
	if (soap_out_dss__DeviceDecreaseValueResponse(soap, tag?tag:"dss:DeviceDecreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__DeviceDecreaseValueResponse(struct soap *soap, struct dss__DeviceDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceDecreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceDecreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__DeviceDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceDecreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceDecreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__DeviceDecreaseValueResponse*)p = *(struct dss__DeviceDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceIncreaseValue(struct soap *soap, struct dss__DeviceIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceIncreaseValue(struct soap *soap, const struct dss__DeviceIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__DeviceIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceIncreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValue * SOAP_FMAC4 soap_in_dss__DeviceIncreaseValue(struct soap *soap, const char *tag, struct dss__DeviceIncreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceIncreaseValue, sizeof(struct dss__DeviceIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceIncreaseValue, 0, sizeof(struct dss__DeviceIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceIncreaseValue(struct soap *soap, const struct dss__DeviceIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceIncreaseValue);
	if (soap_out_dss__DeviceIncreaseValue(soap, tag?tag:"dss:DeviceIncreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValue * SOAP_FMAC4 soap_get_dss__DeviceIncreaseValue(struct soap *soap, struct dss__DeviceIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceIncreaseValue * SOAP_FMAC2 soap_instantiate_dss__DeviceIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceIncreaseValue);
		if (size)
			*size = sizeof(struct dss__DeviceIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceIncreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceIncreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceIncreaseValue %p -> %p\n", q, p));
	*(struct dss__DeviceIncreaseValue*)p = *(struct dss__DeviceIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceIncreaseValueResponse(struct soap *soap, struct dss__DeviceIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceIncreaseValueResponse(struct soap *soap, const struct dss__DeviceIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__DeviceIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__DeviceIncreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceIncreaseValueResponse, sizeof(struct dss__DeviceIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceIncreaseValueResponse, 0, sizeof(struct dss__DeviceIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceIncreaseValueResponse(struct soap *soap, const struct dss__DeviceIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceIncreaseValueResponse);
	if (soap_out_dss__DeviceIncreaseValueResponse(soap, tag?tag:"dss:DeviceIncreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__DeviceIncreaseValueResponse(struct soap *soap, struct dss__DeviceIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceIncreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceIncreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__DeviceIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceIncreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceIncreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__DeviceIncreaseValueResponse*)p = *(struct dss__DeviceIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOff(struct soap *soap, struct dss__DeviceTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOff(struct soap *soap, const struct dss__DeviceTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOff(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOff), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOff * SOAP_FMAC4 soap_in_dss__DeviceTurnOff(struct soap *soap, const char *tag, struct dss__DeviceTurnOff *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOff, sizeof(struct dss__DeviceTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOff, 0, sizeof(struct dss__DeviceTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOff(struct soap *soap, const struct dss__DeviceTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOff);
	if (soap_out_dss__DeviceTurnOff(soap, tag?tag:"dss:DeviceTurnOff", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceTurnOff * SOAP_FMAC4 soap_get_dss__DeviceTurnOff(struct soap *soap, struct dss__DeviceTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceTurnOff * SOAP_FMAC2 soap_instantiate_dss__DeviceTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOff);
		if (size)
			*size = sizeof(struct dss__DeviceTurnOff);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOff[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOff*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOff %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOff*)p = *(struct dss__DeviceTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOffResponse(struct soap *soap, struct dss__DeviceTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOffResponse(struct soap *soap, const struct dss__DeviceTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOffResponse * SOAP_FMAC4 soap_in_dss__DeviceTurnOffResponse(struct soap *soap, const char *tag, struct dss__DeviceTurnOffResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOffResponse, sizeof(struct dss__DeviceTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOffResponse, 0, sizeof(struct dss__DeviceTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOffResponse(struct soap *soap, const struct dss__DeviceTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOffResponse);
	if (soap_out_dss__DeviceTurnOffResponse(soap, tag?tag:"dss:DeviceTurnOffResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceTurnOffResponse * SOAP_FMAC4 soap_get_dss__DeviceTurnOffResponse(struct soap *soap, struct dss__DeviceTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceTurnOffResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOffResponse);
		if (size)
			*size = sizeof(struct dss__DeviceTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOffResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOffResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOffResponse*)p = *(struct dss__DeviceTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOn(struct soap *soap, struct dss__DeviceTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOn(struct soap *soap, const struct dss__DeviceTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOn(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOn), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOn * SOAP_FMAC4 soap_in_dss__DeviceTurnOn(struct soap *soap, const char *tag, struct dss__DeviceTurnOn *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOn, sizeof(struct dss__DeviceTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOn, 0, sizeof(struct dss__DeviceTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOn(struct soap *soap, const struct dss__DeviceTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOn);
	if (soap_out_dss__DeviceTurnOn(soap, tag?tag:"dss:DeviceTurnOn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceTurnOn * SOAP_FMAC4 soap_get_dss__DeviceTurnOn(struct soap *soap, struct dss__DeviceTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceTurnOn * SOAP_FMAC2 soap_instantiate_dss__DeviceTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOn);
		if (size)
			*size = sizeof(struct dss__DeviceTurnOn);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOn[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOn %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOn*)p = *(struct dss__DeviceTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOnResponse(struct soap *soap, struct dss__DeviceTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOnResponse(struct soap *soap, const struct dss__DeviceTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOnResponse * SOAP_FMAC4 soap_in_dss__DeviceTurnOnResponse(struct soap *soap, const char *tag, struct dss__DeviceTurnOnResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOnResponse, sizeof(struct dss__DeviceTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOnResponse, 0, sizeof(struct dss__DeviceTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOnResponse(struct soap *soap, const struct dss__DeviceTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOnResponse);
	if (soap_out_dss__DeviceTurnOnResponse(soap, tag?tag:"dss:DeviceTurnOnResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__DeviceTurnOnResponse * SOAP_FMAC4 soap_get_dss__DeviceTurnOnResponse(struct soap *soap, struct dss__DeviceTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__DeviceTurnOnResponse * SOAP_FMAC2 soap_instantiate_dss__DeviceTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOnResponse);
		if (size)
			*size = sizeof(struct dss__DeviceTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__DeviceTurnOnResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOnResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOnResponse*)p = *(struct dss__DeviceTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSaveScene(struct soap *soap, struct dss__ZoneSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSaveScene(struct soap *soap, const struct dss__ZoneSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSaveScene(struct soap *soap, const char *tag, int id, const struct dss__ZoneSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSaveScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSaveScene * SOAP_FMAC4 soap_in_dss__ZoneSaveScene(struct soap *soap, const char *tag, struct dss__ZoneSaveScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSaveScene, sizeof(struct dss__ZoneSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSaveScene, 0, sizeof(struct dss__ZoneSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSaveScene(struct soap *soap, const struct dss__ZoneSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSaveScene);
	if (soap_out_dss__ZoneSaveScene(soap, tag?tag:"dss:ZoneSaveScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneSaveScene * SOAP_FMAC4 soap_get_dss__ZoneSaveScene(struct soap *soap, struct dss__ZoneSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneSaveScene * SOAP_FMAC2 soap_instantiate_dss__ZoneSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneSaveScene);
		if (size)
			*size = sizeof(struct dss__ZoneSaveScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneSaveScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSaveScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSaveScene %p -> %p\n", q, p));
	*(struct dss__ZoneSaveScene*)p = *(struct dss__ZoneSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSaveSceneResponse(struct soap *soap, struct dss__ZoneSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSaveSceneResponse(struct soap *soap, const struct dss__ZoneSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSaveSceneResponse * SOAP_FMAC4 soap_in_dss__ZoneSaveSceneResponse(struct soap *soap, const char *tag, struct dss__ZoneSaveSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSaveSceneResponse, sizeof(struct dss__ZoneSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSaveSceneResponse, 0, sizeof(struct dss__ZoneSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSaveSceneResponse(struct soap *soap, const struct dss__ZoneSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSaveSceneResponse);
	if (soap_out_dss__ZoneSaveSceneResponse(soap, tag?tag:"dss:ZoneSaveSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneSaveSceneResponse * SOAP_FMAC4 soap_get_dss__ZoneSaveSceneResponse(struct soap *soap, struct dss__ZoneSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneSaveSceneResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneSaveSceneResponse);
		if (size)
			*size = sizeof(struct dss__ZoneSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneSaveSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSaveSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__ZoneSaveSceneResponse*)p = *(struct dss__ZoneSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneCallScene(struct soap *soap, struct dss__ZoneCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneCallScene(struct soap *soap, const struct dss__ZoneCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneCallScene(struct soap *soap, const char *tag, int id, const struct dss__ZoneCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneCallScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneCallScene * SOAP_FMAC4 soap_in_dss__ZoneCallScene(struct soap *soap, const char *tag, struct dss__ZoneCallScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneCallScene, sizeof(struct dss__ZoneCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneCallScene, 0, sizeof(struct dss__ZoneCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneCallScene(struct soap *soap, const struct dss__ZoneCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneCallScene);
	if (soap_out_dss__ZoneCallScene(soap, tag?tag:"dss:ZoneCallScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneCallScene * SOAP_FMAC4 soap_get_dss__ZoneCallScene(struct soap *soap, struct dss__ZoneCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneCallScene * SOAP_FMAC2 soap_instantiate_dss__ZoneCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneCallScene);
		if (size)
			*size = sizeof(struct dss__ZoneCallScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneCallScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneCallScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneCallScene %p -> %p\n", q, p));
	*(struct dss__ZoneCallScene*)p = *(struct dss__ZoneCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneCallSceneResponse(struct soap *soap, struct dss__ZoneCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneCallSceneResponse(struct soap *soap, const struct dss__ZoneCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneCallSceneResponse * SOAP_FMAC4 soap_in_dss__ZoneCallSceneResponse(struct soap *soap, const char *tag, struct dss__ZoneCallSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneCallSceneResponse, sizeof(struct dss__ZoneCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneCallSceneResponse, 0, sizeof(struct dss__ZoneCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneCallSceneResponse(struct soap *soap, const struct dss__ZoneCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneCallSceneResponse);
	if (soap_out_dss__ZoneCallSceneResponse(soap, tag?tag:"dss:ZoneCallSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneCallSceneResponse * SOAP_FMAC4 soap_get_dss__ZoneCallSceneResponse(struct soap *soap, struct dss__ZoneCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneCallSceneResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneCallSceneResponse);
		if (size)
			*size = sizeof(struct dss__ZoneCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneCallSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneCallSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__ZoneCallSceneResponse*)p = *(struct dss__ZoneCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSetValue(struct soap *soap, struct dss__ZoneSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_double(soap, &a->_value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSetValue(struct soap *soap, const struct dss__ZoneSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSetValue(struct soap *soap, const char *tag, int id, const struct dss__ZoneSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSetValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSetValue * SOAP_FMAC4 soap_in_dss__ZoneSetValue(struct soap *soap, const char *tag, struct dss__ZoneSetValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	size_t soap_flag__value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSetValue, sizeof(struct dss__ZoneSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSetValue, 0, sizeof(struct dss__ZoneSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSetValue(struct soap *soap, const struct dss__ZoneSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSetValue);
	if (soap_out_dss__ZoneSetValue(soap, tag?tag:"dss:ZoneSetValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneSetValue * SOAP_FMAC4 soap_get_dss__ZoneSetValue(struct soap *soap, struct dss__ZoneSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneSetValue * SOAP_FMAC2 soap_instantiate_dss__ZoneSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneSetValue);
		if (size)
			*size = sizeof(struct dss__ZoneSetValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneSetValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSetValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSetValue %p -> %p\n", q, p));
	*(struct dss__ZoneSetValue*)p = *(struct dss__ZoneSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSetValueResponse(struct soap *soap, struct dss__ZoneSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSetValueResponse(struct soap *soap, const struct dss__ZoneSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSetValueResponse * SOAP_FMAC4 soap_in_dss__ZoneSetValueResponse(struct soap *soap, const char *tag, struct dss__ZoneSetValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSetValueResponse, sizeof(struct dss__ZoneSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSetValueResponse, 0, sizeof(struct dss__ZoneSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSetValueResponse(struct soap *soap, const struct dss__ZoneSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSetValueResponse);
	if (soap_out_dss__ZoneSetValueResponse(soap, tag?tag:"dss:ZoneSetValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneSetValueResponse * SOAP_FMAC4 soap_get_dss__ZoneSetValueResponse(struct soap *soap, struct dss__ZoneSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneSetValueResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneSetValueResponse);
		if (size)
			*size = sizeof(struct dss__ZoneSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneSetValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSetValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSetValueResponse %p -> %p\n", q, p));
	*(struct dss__ZoneSetValueResponse*)p = *(struct dss__ZoneSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneDecreaseValue(struct soap *soap, struct dss__ZoneDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneDecreaseValue(struct soap *soap, const struct dss__ZoneDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ZoneDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneDecreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValue * SOAP_FMAC4 soap_in_dss__ZoneDecreaseValue(struct soap *soap, const char *tag, struct dss__ZoneDecreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneDecreaseValue, sizeof(struct dss__ZoneDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneDecreaseValue, 0, sizeof(struct dss__ZoneDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneDecreaseValue(struct soap *soap, const struct dss__ZoneDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneDecreaseValue);
	if (soap_out_dss__ZoneDecreaseValue(soap, tag?tag:"dss:ZoneDecreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValue * SOAP_FMAC4 soap_get_dss__ZoneDecreaseValue(struct soap *soap, struct dss__ZoneDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneDecreaseValue * SOAP_FMAC2 soap_instantiate_dss__ZoneDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneDecreaseValue);
		if (size)
			*size = sizeof(struct dss__ZoneDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneDecreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneDecreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneDecreaseValue %p -> %p\n", q, p));
	*(struct dss__ZoneDecreaseValue*)p = *(struct dss__ZoneDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneDecreaseValueResponse(struct soap *soap, struct dss__ZoneDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneDecreaseValueResponse(struct soap *soap, const struct dss__ZoneDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__ZoneDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__ZoneDecreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneDecreaseValueResponse, sizeof(struct dss__ZoneDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneDecreaseValueResponse, 0, sizeof(struct dss__ZoneDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneDecreaseValueResponse(struct soap *soap, const struct dss__ZoneDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneDecreaseValueResponse);
	if (soap_out_dss__ZoneDecreaseValueResponse(soap, tag?tag:"dss:ZoneDecreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__ZoneDecreaseValueResponse(struct soap *soap, struct dss__ZoneDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneDecreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneDecreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__ZoneDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneDecreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneDecreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ZoneDecreaseValueResponse*)p = *(struct dss__ZoneDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneIncreaseValue(struct soap *soap, struct dss__ZoneIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneIncreaseValue(struct soap *soap, const struct dss__ZoneIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ZoneIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneIncreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValue * SOAP_FMAC4 soap_in_dss__ZoneIncreaseValue(struct soap *soap, const char *tag, struct dss__ZoneIncreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneIncreaseValue, sizeof(struct dss__ZoneIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneIncreaseValue, 0, sizeof(struct dss__ZoneIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneIncreaseValue(struct soap *soap, const struct dss__ZoneIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneIncreaseValue);
	if (soap_out_dss__ZoneIncreaseValue(soap, tag?tag:"dss:ZoneIncreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValue * SOAP_FMAC4 soap_get_dss__ZoneIncreaseValue(struct soap *soap, struct dss__ZoneIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneIncreaseValue * SOAP_FMAC2 soap_instantiate_dss__ZoneIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneIncreaseValue);
		if (size)
			*size = sizeof(struct dss__ZoneIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneIncreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneIncreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneIncreaseValue %p -> %p\n", q, p));
	*(struct dss__ZoneIncreaseValue*)p = *(struct dss__ZoneIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneIncreaseValueResponse(struct soap *soap, struct dss__ZoneIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneIncreaseValueResponse(struct soap *soap, const struct dss__ZoneIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__ZoneIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__ZoneIncreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneIncreaseValueResponse, sizeof(struct dss__ZoneIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneIncreaseValueResponse, 0, sizeof(struct dss__ZoneIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneIncreaseValueResponse(struct soap *soap, const struct dss__ZoneIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneIncreaseValueResponse);
	if (soap_out_dss__ZoneIncreaseValueResponse(soap, tag?tag:"dss:ZoneIncreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__ZoneIncreaseValueResponse(struct soap *soap, struct dss__ZoneIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneIncreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneIncreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__ZoneIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneIncreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneIncreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ZoneIncreaseValueResponse*)p = *(struct dss__ZoneIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOff(struct soap *soap, struct dss__ZoneTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOff(struct soap *soap, const struct dss__ZoneTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOff(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOff), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOff * SOAP_FMAC4 soap_in_dss__ZoneTurnOff(struct soap *soap, const char *tag, struct dss__ZoneTurnOff *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOff, sizeof(struct dss__ZoneTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOff, 0, sizeof(struct dss__ZoneTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOff(struct soap *soap, const struct dss__ZoneTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOff);
	if (soap_out_dss__ZoneTurnOff(soap, tag?tag:"dss:ZoneTurnOff", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneTurnOff * SOAP_FMAC4 soap_get_dss__ZoneTurnOff(struct soap *soap, struct dss__ZoneTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneTurnOff * SOAP_FMAC2 soap_instantiate_dss__ZoneTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOff);
		if (size)
			*size = sizeof(struct dss__ZoneTurnOff);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOff[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOff*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOff %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOff*)p = *(struct dss__ZoneTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOffResponse(struct soap *soap, struct dss__ZoneTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOffResponse(struct soap *soap, const struct dss__ZoneTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOffResponse * SOAP_FMAC4 soap_in_dss__ZoneTurnOffResponse(struct soap *soap, const char *tag, struct dss__ZoneTurnOffResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOffResponse, sizeof(struct dss__ZoneTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOffResponse, 0, sizeof(struct dss__ZoneTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOffResponse(struct soap *soap, const struct dss__ZoneTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOffResponse);
	if (soap_out_dss__ZoneTurnOffResponse(soap, tag?tag:"dss:ZoneTurnOffResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneTurnOffResponse * SOAP_FMAC4 soap_get_dss__ZoneTurnOffResponse(struct soap *soap, struct dss__ZoneTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneTurnOffResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOffResponse);
		if (size)
			*size = sizeof(struct dss__ZoneTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOffResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOffResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOffResponse*)p = *(struct dss__ZoneTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOn(struct soap *soap, struct dss__ZoneTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOn(struct soap *soap, const struct dss__ZoneTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOn(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOn), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOn * SOAP_FMAC4 soap_in_dss__ZoneTurnOn(struct soap *soap, const char *tag, struct dss__ZoneTurnOn *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneID = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOn, sizeof(struct dss__ZoneTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOn, 0, sizeof(struct dss__ZoneTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOn(struct soap *soap, const struct dss__ZoneTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOn);
	if (soap_out_dss__ZoneTurnOn(soap, tag?tag:"dss:ZoneTurnOn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneTurnOn * SOAP_FMAC4 soap_get_dss__ZoneTurnOn(struct soap *soap, struct dss__ZoneTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneTurnOn * SOAP_FMAC2 soap_instantiate_dss__ZoneTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOn);
		if (size)
			*size = sizeof(struct dss__ZoneTurnOn);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOn[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOn %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOn*)p = *(struct dss__ZoneTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOnResponse(struct soap *soap, struct dss__ZoneTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOnResponse(struct soap *soap, const struct dss__ZoneTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOnResponse * SOAP_FMAC4 soap_in_dss__ZoneTurnOnResponse(struct soap *soap, const char *tag, struct dss__ZoneTurnOnResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOnResponse, sizeof(struct dss__ZoneTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOnResponse, 0, sizeof(struct dss__ZoneTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOnResponse(struct soap *soap, const struct dss__ZoneTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOnResponse);
	if (soap_out_dss__ZoneTurnOnResponse(soap, tag?tag:"dss:ZoneTurnOnResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ZoneTurnOnResponse * SOAP_FMAC4 soap_get_dss__ZoneTurnOnResponse(struct soap *soap, struct dss__ZoneTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ZoneTurnOnResponse * SOAP_FMAC2 soap_instantiate_dss__ZoneTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOnResponse);
		if (size)
			*size = sizeof(struct dss__ZoneTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ZoneTurnOnResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOnResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOnResponse*)p = *(struct dss__ZoneTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__CircuitRescan(struct soap *soap, struct dss__CircuitRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_dsid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__CircuitRescan(struct soap *soap, const struct dss__CircuitRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_dsid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__CircuitRescan(struct soap *soap, const char *tag, int id, const struct dss__CircuitRescan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__CircuitRescan), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "dsid", -1, &a->_dsid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__CircuitRescan * SOAP_FMAC4 soap_in_dss__CircuitRescan(struct soap *soap, const char *tag, struct dss__CircuitRescan *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__dsid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__CircuitRescan *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__CircuitRescan, sizeof(struct dss__CircuitRescan), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__CircuitRescan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__dsid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_dsid, "xsd:string"))
				{	soap_flag__dsid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__CircuitRescan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__CircuitRescan, 0, sizeof(struct dss__CircuitRescan), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__CircuitRescan(struct soap *soap, const struct dss__CircuitRescan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__CircuitRescan);
	if (soap_out_dss__CircuitRescan(soap, tag?tag:"dss:CircuitRescan", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__CircuitRescan * SOAP_FMAC4 soap_get_dss__CircuitRescan(struct soap *soap, struct dss__CircuitRescan *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__CircuitRescan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__CircuitRescan * SOAP_FMAC2 soap_instantiate_dss__CircuitRescan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__CircuitRescan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__CircuitRescan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__CircuitRescan);
		if (size)
			*size = sizeof(struct dss__CircuitRescan);
	}
	else
	{	cp->ptr = (void*)new (struct dss__CircuitRescan[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__CircuitRescan);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__CircuitRescan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__CircuitRescan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__CircuitRescan %p -> %p\n", q, p));
	*(struct dss__CircuitRescan*)p = *(struct dss__CircuitRescan*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__CircuitRescanResponse(struct soap *soap, struct dss__CircuitRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__CircuitRescanResponse(struct soap *soap, const struct dss__CircuitRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__CircuitRescanResponse(struct soap *soap, const char *tag, int id, const struct dss__CircuitRescanResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__CircuitRescanResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__CircuitRescanResponse * SOAP_FMAC4 soap_in_dss__CircuitRescanResponse(struct soap *soap, const char *tag, struct dss__CircuitRescanResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__CircuitRescanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__CircuitRescanResponse, sizeof(struct dss__CircuitRescanResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__CircuitRescanResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__CircuitRescanResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__CircuitRescanResponse, 0, sizeof(struct dss__CircuitRescanResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__CircuitRescanResponse(struct soap *soap, const struct dss__CircuitRescanResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__CircuitRescanResponse);
	if (soap_out_dss__CircuitRescanResponse(soap, tag?tag:"dss:CircuitRescanResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__CircuitRescanResponse * SOAP_FMAC4 soap_get_dss__CircuitRescanResponse(struct soap *soap, struct dss__CircuitRescanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__CircuitRescanResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__CircuitRescanResponse * SOAP_FMAC2 soap_instantiate_dss__CircuitRescanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__CircuitRescanResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__CircuitRescanResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__CircuitRescanResponse);
		if (size)
			*size = sizeof(struct dss__CircuitRescanResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__CircuitRescanResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__CircuitRescanResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__CircuitRescanResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__CircuitRescanResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__CircuitRescanResponse %p -> %p\n", q, p));
	*(struct dss__CircuitRescanResponse*)p = *(struct dss__CircuitRescanResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentRescan(struct soap *soap, struct dss__ApartmentRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentRescan(struct soap *soap, const struct dss__ApartmentRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentRescan(struct soap *soap, const char *tag, int id, const struct dss__ApartmentRescan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentRescan), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentRescan * SOAP_FMAC4 soap_in_dss__ApartmentRescan(struct soap *soap, const char *tag, struct dss__ApartmentRescan *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentRescan *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentRescan, sizeof(struct dss__ApartmentRescan), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentRescan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentRescan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentRescan, 0, sizeof(struct dss__ApartmentRescan), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentRescan(struct soap *soap, const struct dss__ApartmentRescan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentRescan);
	if (soap_out_dss__ApartmentRescan(soap, tag?tag:"dss:ApartmentRescan", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentRescan * SOAP_FMAC4 soap_get_dss__ApartmentRescan(struct soap *soap, struct dss__ApartmentRescan *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentRescan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentRescan * SOAP_FMAC2 soap_instantiate_dss__ApartmentRescan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentRescan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentRescan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentRescan);
		if (size)
			*size = sizeof(struct dss__ApartmentRescan);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentRescan[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentRescan);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentRescan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentRescan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentRescan %p -> %p\n", q, p));
	*(struct dss__ApartmentRescan*)p = *(struct dss__ApartmentRescan*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentRescanResponse(struct soap *soap, struct dss__ApartmentRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentRescanResponse(struct soap *soap, const struct dss__ApartmentRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentRescanResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentRescanResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentRescanResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentRescanResponse * SOAP_FMAC4 soap_in_dss__ApartmentRescanResponse(struct soap *soap, const char *tag, struct dss__ApartmentRescanResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentRescanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentRescanResponse, sizeof(struct dss__ApartmentRescanResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentRescanResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentRescanResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentRescanResponse, 0, sizeof(struct dss__ApartmentRescanResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentRescanResponse(struct soap *soap, const struct dss__ApartmentRescanResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentRescanResponse);
	if (soap_out_dss__ApartmentRescanResponse(soap, tag?tag:"dss:ApartmentRescanResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentRescanResponse * SOAP_FMAC4 soap_get_dss__ApartmentRescanResponse(struct soap *soap, struct dss__ApartmentRescanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentRescanResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentRescanResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentRescanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentRescanResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentRescanResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentRescanResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentRescanResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentRescanResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentRescanResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentRescanResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentRescanResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentRescanResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentRescanResponse*)p = *(struct dss__ApartmentRescanResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSaveScene(struct soap *soap, struct dss__ApartmentSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSaveScene(struct soap *soap, const struct dss__ApartmentSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSaveScene(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSaveScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSaveScene * SOAP_FMAC4 soap_in_dss__ApartmentSaveScene(struct soap *soap, const char *tag, struct dss__ApartmentSaveScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupID = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSaveScene, sizeof(struct dss__ApartmentSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSaveScene, 0, sizeof(struct dss__ApartmentSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSaveScene(struct soap *soap, const struct dss__ApartmentSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSaveScene);
	if (soap_out_dss__ApartmentSaveScene(soap, tag?tag:"dss:ApartmentSaveScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentSaveScene * SOAP_FMAC4 soap_get_dss__ApartmentSaveScene(struct soap *soap, struct dss__ApartmentSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentSaveScene * SOAP_FMAC2 soap_instantiate_dss__ApartmentSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentSaveScene);
		if (size)
			*size = sizeof(struct dss__ApartmentSaveScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentSaveScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSaveScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSaveScene %p -> %p\n", q, p));
	*(struct dss__ApartmentSaveScene*)p = *(struct dss__ApartmentSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSaveSceneResponse(struct soap *soap, struct dss__ApartmentSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSaveSceneResponse(struct soap *soap, const struct dss__ApartmentSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSaveSceneResponse * SOAP_FMAC4 soap_in_dss__ApartmentSaveSceneResponse(struct soap *soap, const char *tag, struct dss__ApartmentSaveSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSaveSceneResponse, sizeof(struct dss__ApartmentSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSaveSceneResponse, 0, sizeof(struct dss__ApartmentSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSaveSceneResponse(struct soap *soap, const struct dss__ApartmentSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSaveSceneResponse);
	if (soap_out_dss__ApartmentSaveSceneResponse(soap, tag?tag:"dss:ApartmentSaveSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentSaveSceneResponse * SOAP_FMAC4 soap_get_dss__ApartmentSaveSceneResponse(struct soap *soap, struct dss__ApartmentSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentSaveSceneResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentSaveSceneResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentSaveSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSaveSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentSaveSceneResponse*)p = *(struct dss__ApartmentSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCallScene(struct soap *soap, struct dss__ApartmentCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCallScene(struct soap *soap, const struct dss__ApartmentCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCallScene(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCallScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCallScene * SOAP_FMAC4 soap_in_dss__ApartmentCallScene(struct soap *soap, const char *tag, struct dss__ApartmentCallScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupID = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCallScene, sizeof(struct dss__ApartmentCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCallScene, 0, sizeof(struct dss__ApartmentCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCallScene(struct soap *soap, const struct dss__ApartmentCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCallScene);
	if (soap_out_dss__ApartmentCallScene(soap, tag?tag:"dss:ApartmentCallScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCallScene * SOAP_FMAC4 soap_get_dss__ApartmentCallScene(struct soap *soap, struct dss__ApartmentCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCallScene * SOAP_FMAC2 soap_instantiate_dss__ApartmentCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCallScene);
		if (size)
			*size = sizeof(struct dss__ApartmentCallScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCallScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCallScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCallScene %p -> %p\n", q, p));
	*(struct dss__ApartmentCallScene*)p = *(struct dss__ApartmentCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCallSceneResponse(struct soap *soap, struct dss__ApartmentCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCallSceneResponse(struct soap *soap, const struct dss__ApartmentCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCallSceneResponse * SOAP_FMAC4 soap_in_dss__ApartmentCallSceneResponse(struct soap *soap, const char *tag, struct dss__ApartmentCallSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCallSceneResponse, sizeof(struct dss__ApartmentCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCallSceneResponse, 0, sizeof(struct dss__ApartmentCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCallSceneResponse(struct soap *soap, const struct dss__ApartmentCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCallSceneResponse);
	if (soap_out_dss__ApartmentCallSceneResponse(soap, tag?tag:"dss:ApartmentCallSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCallSceneResponse * SOAP_FMAC4 soap_get_dss__ApartmentCallSceneResponse(struct soap *soap, struct dss__ApartmentCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCallSceneResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCallSceneResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCallSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCallSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCallSceneResponse*)p = *(struct dss__ApartmentCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSetValue(struct soap *soap, struct dss__ApartmentSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_double(soap, &a->_value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSetValue(struct soap *soap, const struct dss__ApartmentSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSetValue(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSetValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSetValue * SOAP_FMAC4 soap_in_dss__ApartmentSetValue(struct soap *soap, const char *tag, struct dss__ApartmentSetValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupID = 1;
	size_t soap_flag__value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSetValue, sizeof(struct dss__ApartmentSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSetValue, 0, sizeof(struct dss__ApartmentSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0 || soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSetValue(struct soap *soap, const struct dss__ApartmentSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSetValue);
	if (soap_out_dss__ApartmentSetValue(soap, tag?tag:"dss:ApartmentSetValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentSetValue * SOAP_FMAC4 soap_get_dss__ApartmentSetValue(struct soap *soap, struct dss__ApartmentSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentSetValue * SOAP_FMAC2 soap_instantiate_dss__ApartmentSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentSetValue);
		if (size)
			*size = sizeof(struct dss__ApartmentSetValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentSetValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSetValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSetValue %p -> %p\n", q, p));
	*(struct dss__ApartmentSetValue*)p = *(struct dss__ApartmentSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSetValueResponse(struct soap *soap, struct dss__ApartmentSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSetValueResponse(struct soap *soap, const struct dss__ApartmentSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSetValueResponse * SOAP_FMAC4 soap_in_dss__ApartmentSetValueResponse(struct soap *soap, const char *tag, struct dss__ApartmentSetValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSetValueResponse, sizeof(struct dss__ApartmentSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSetValueResponse, 0, sizeof(struct dss__ApartmentSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSetValueResponse(struct soap *soap, const struct dss__ApartmentSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSetValueResponse);
	if (soap_out_dss__ApartmentSetValueResponse(soap, tag?tag:"dss:ApartmentSetValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentSetValueResponse * SOAP_FMAC4 soap_get_dss__ApartmentSetValueResponse(struct soap *soap, struct dss__ApartmentSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentSetValueResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentSetValueResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentSetValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSetValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSetValueResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentSetValueResponse*)p = *(struct dss__ApartmentSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDecreaseValue(struct soap *soap, struct dss__ApartmentDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDecreaseValue(struct soap *soap, const struct dss__ApartmentDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDecreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValue * SOAP_FMAC4 soap_in_dss__ApartmentDecreaseValue(struct soap *soap, const char *tag, struct dss__ApartmentDecreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDecreaseValue, sizeof(struct dss__ApartmentDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDecreaseValue, 0, sizeof(struct dss__ApartmentDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDecreaseValue(struct soap *soap, const struct dss__ApartmentDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDecreaseValue);
	if (soap_out_dss__ApartmentDecreaseValue(soap, tag?tag:"dss:ApartmentDecreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValue * SOAP_FMAC4 soap_get_dss__ApartmentDecreaseValue(struct soap *soap, struct dss__ApartmentDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentDecreaseValue * SOAP_FMAC2 soap_instantiate_dss__ApartmentDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentDecreaseValue);
		if (size)
			*size = sizeof(struct dss__ApartmentDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentDecreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDecreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDecreaseValue %p -> %p\n", q, p));
	*(struct dss__ApartmentDecreaseValue*)p = *(struct dss__ApartmentDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDecreaseValueResponse(struct soap *soap, struct dss__ApartmentDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDecreaseValueResponse(struct soap *soap, const struct dss__ApartmentDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__ApartmentDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__ApartmentDecreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDecreaseValueResponse, sizeof(struct dss__ApartmentDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDecreaseValueResponse, 0, sizeof(struct dss__ApartmentDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDecreaseValueResponse(struct soap *soap, const struct dss__ApartmentDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDecreaseValueResponse);
	if (soap_out_dss__ApartmentDecreaseValueResponse(soap, tag?tag:"dss:ApartmentDecreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__ApartmentDecreaseValueResponse(struct soap *soap, struct dss__ApartmentDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentDecreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentDecreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentDecreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDecreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentDecreaseValueResponse*)p = *(struct dss__ApartmentDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentIncreaseValue(struct soap *soap, struct dss__ApartmentIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentIncreaseValue(struct soap *soap, const struct dss__ApartmentIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ApartmentIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentIncreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValue * SOAP_FMAC4 soap_in_dss__ApartmentIncreaseValue(struct soap *soap, const char *tag, struct dss__ApartmentIncreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentIncreaseValue, sizeof(struct dss__ApartmentIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentIncreaseValue, 0, sizeof(struct dss__ApartmentIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentIncreaseValue(struct soap *soap, const struct dss__ApartmentIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentIncreaseValue);
	if (soap_out_dss__ApartmentIncreaseValue(soap, tag?tag:"dss:ApartmentIncreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValue * SOAP_FMAC4 soap_get_dss__ApartmentIncreaseValue(struct soap *soap, struct dss__ApartmentIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentIncreaseValue * SOAP_FMAC2 soap_instantiate_dss__ApartmentIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentIncreaseValue);
		if (size)
			*size = sizeof(struct dss__ApartmentIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentIncreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentIncreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentIncreaseValue %p -> %p\n", q, p));
	*(struct dss__ApartmentIncreaseValue*)p = *(struct dss__ApartmentIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentIncreaseValueResponse(struct soap *soap, struct dss__ApartmentIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentIncreaseValueResponse(struct soap *soap, const struct dss__ApartmentIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__ApartmentIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__ApartmentIncreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentIncreaseValueResponse, sizeof(struct dss__ApartmentIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentIncreaseValueResponse, 0, sizeof(struct dss__ApartmentIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentIncreaseValueResponse(struct soap *soap, const struct dss__ApartmentIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentIncreaseValueResponse);
	if (soap_out_dss__ApartmentIncreaseValueResponse(soap, tag?tag:"dss:ApartmentIncreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__ApartmentIncreaseValueResponse(struct soap *soap, struct dss__ApartmentIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentIncreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentIncreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentIncreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentIncreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentIncreaseValueResponse*)p = *(struct dss__ApartmentIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOff(struct soap *soap, struct dss__ApartmentTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOff(struct soap *soap, const struct dss__ApartmentTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOff(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOff), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOff * SOAP_FMAC4 soap_in_dss__ApartmentTurnOff(struct soap *soap, const char *tag, struct dss__ApartmentTurnOff *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOff, sizeof(struct dss__ApartmentTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOff, 0, sizeof(struct dss__ApartmentTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOff(struct soap *soap, const struct dss__ApartmentTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOff);
	if (soap_out_dss__ApartmentTurnOff(soap, tag?tag:"dss:ApartmentTurnOff", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentTurnOff * SOAP_FMAC4 soap_get_dss__ApartmentTurnOff(struct soap *soap, struct dss__ApartmentTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentTurnOff * SOAP_FMAC2 soap_instantiate_dss__ApartmentTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOff);
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOff);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOff[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOff*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOff %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOff*)p = *(struct dss__ApartmentTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOffResponse(struct soap *soap, struct dss__ApartmentTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOffResponse(struct soap *soap, const struct dss__ApartmentTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOffResponse * SOAP_FMAC4 soap_in_dss__ApartmentTurnOffResponse(struct soap *soap, const char *tag, struct dss__ApartmentTurnOffResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOffResponse, sizeof(struct dss__ApartmentTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOffResponse, 0, sizeof(struct dss__ApartmentTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOffResponse(struct soap *soap, const struct dss__ApartmentTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOffResponse);
	if (soap_out_dss__ApartmentTurnOffResponse(soap, tag?tag:"dss:ApartmentTurnOffResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentTurnOffResponse * SOAP_FMAC4 soap_get_dss__ApartmentTurnOffResponse(struct soap *soap, struct dss__ApartmentTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentTurnOffResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOffResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOffResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOffResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOffResponse*)p = *(struct dss__ApartmentTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOn(struct soap *soap, struct dss__ApartmentTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOn(struct soap *soap, const struct dss__ApartmentTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOn(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOn), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOn * SOAP_FMAC4 soap_in_dss__ApartmentTurnOn(struct soap *soap, const char *tag, struct dss__ApartmentTurnOn *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOn, sizeof(struct dss__ApartmentTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOn, 0, sizeof(struct dss__ApartmentTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOn(struct soap *soap, const struct dss__ApartmentTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOn);
	if (soap_out_dss__ApartmentTurnOn(soap, tag?tag:"dss:ApartmentTurnOn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentTurnOn * SOAP_FMAC4 soap_get_dss__ApartmentTurnOn(struct soap *soap, struct dss__ApartmentTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentTurnOn * SOAP_FMAC2 soap_instantiate_dss__ApartmentTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOn);
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOn);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOn[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOn %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOn*)p = *(struct dss__ApartmentTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOnResponse(struct soap *soap, struct dss__ApartmentTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOnResponse(struct soap *soap, const struct dss__ApartmentTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOnResponse * SOAP_FMAC4 soap_in_dss__ApartmentTurnOnResponse(struct soap *soap, const char *tag, struct dss__ApartmentTurnOnResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOnResponse, sizeof(struct dss__ApartmentTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOnResponse, 0, sizeof(struct dss__ApartmentTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOnResponse(struct soap *soap, const struct dss__ApartmentTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOnResponse);
	if (soap_out_dss__ApartmentTurnOnResponse(soap, tag?tag:"dss:ApartmentTurnOnResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentTurnOnResponse * SOAP_FMAC4 soap_get_dss__ApartmentTurnOnResponse(struct soap *soap, struct dss__ApartmentTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentTurnOnResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOnResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentTurnOnResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOnResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOnResponse*)p = *(struct dss__ApartmentTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSaveScene(struct soap *soap, struct dss__SetSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSaveScene(struct soap *soap, const struct dss__SetSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSaveScene(struct soap *soap, const char *tag, int id, const struct dss__SetSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSaveScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSaveScene * SOAP_FMAC4 soap_in_dss__SetSaveScene(struct soap *soap, const char *tag, struct dss__SetSaveScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSaveScene, sizeof(struct dss__SetSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSaveScene, 0, sizeof(struct dss__SetSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSaveScene(struct soap *soap, const struct dss__SetSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSaveScene);
	if (soap_out_dss__SetSaveScene(soap, tag?tag:"dss:SetSaveScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetSaveScene * SOAP_FMAC4 soap_get_dss__SetSaveScene(struct soap *soap, struct dss__SetSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetSaveScene * SOAP_FMAC2 soap_instantiate_dss__SetSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetSaveScene);
		if (size)
			*size = sizeof(struct dss__SetSaveScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetSaveScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSaveScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSaveScene %p -> %p\n", q, p));
	*(struct dss__SetSaveScene*)p = *(struct dss__SetSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSaveSceneResponse(struct soap *soap, struct dss__SetSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSaveSceneResponse(struct soap *soap, const struct dss__SetSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__SetSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSaveSceneResponse * SOAP_FMAC4 soap_in_dss__SetSaveSceneResponse(struct soap *soap, const char *tag, struct dss__SetSaveSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSaveSceneResponse, sizeof(struct dss__SetSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSaveSceneResponse, 0, sizeof(struct dss__SetSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSaveSceneResponse(struct soap *soap, const struct dss__SetSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSaveSceneResponse);
	if (soap_out_dss__SetSaveSceneResponse(soap, tag?tag:"dss:SetSaveSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetSaveSceneResponse * SOAP_FMAC4 soap_get_dss__SetSaveSceneResponse(struct soap *soap, struct dss__SetSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetSaveSceneResponse * SOAP_FMAC2 soap_instantiate_dss__SetSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetSaveSceneResponse);
		if (size)
			*size = sizeof(struct dss__SetSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetSaveSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSaveSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__SetSaveSceneResponse*)p = *(struct dss__SetSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCallScene(struct soap *soap, struct dss__SetCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCallScene(struct soap *soap, const struct dss__SetCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCallScene(struct soap *soap, const char *tag, int id, const struct dss__SetCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCallScene), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCallScene * SOAP_FMAC4 soap_in_dss__SetCallScene(struct soap *soap, const char *tag, struct dss__SetCallScene *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCallScene, sizeof(struct dss__SetCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCallScene, 0, sizeof(struct dss__SetCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCallScene(struct soap *soap, const struct dss__SetCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCallScene);
	if (soap_out_dss__SetCallScene(soap, tag?tag:"dss:SetCallScene", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetCallScene * SOAP_FMAC4 soap_get_dss__SetCallScene(struct soap *soap, struct dss__SetCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetCallScene * SOAP_FMAC2 soap_instantiate_dss__SetCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetCallScene);
		if (size)
			*size = sizeof(struct dss__SetCallScene);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetCallScene[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCallScene*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCallScene %p -> %p\n", q, p));
	*(struct dss__SetCallScene*)p = *(struct dss__SetCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCallSceneResponse(struct soap *soap, struct dss__SetCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCallSceneResponse(struct soap *soap, const struct dss__SetCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__SetCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCallSceneResponse * SOAP_FMAC4 soap_in_dss__SetCallSceneResponse(struct soap *soap, const char *tag, struct dss__SetCallSceneResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCallSceneResponse, sizeof(struct dss__SetCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCallSceneResponse, 0, sizeof(struct dss__SetCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCallSceneResponse(struct soap *soap, const struct dss__SetCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCallSceneResponse);
	if (soap_out_dss__SetCallSceneResponse(soap, tag?tag:"dss:SetCallSceneResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetCallSceneResponse * SOAP_FMAC4 soap_get_dss__SetCallSceneResponse(struct soap *soap, struct dss__SetCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetCallSceneResponse * SOAP_FMAC2 soap_instantiate_dss__SetCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetCallSceneResponse);
		if (size)
			*size = sizeof(struct dss__SetCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetCallSceneResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCallSceneResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__SetCallSceneResponse*)p = *(struct dss__SetCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSetValue(struct soap *soap, struct dss__SetSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_double(soap, &a->_value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSetValue(struct soap *soap, const struct dss__SetSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSetValue(struct soap *soap, const char *tag, int id, const struct dss__SetSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSetValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSetValue * SOAP_FMAC4 soap_in_dss__SetSetValue(struct soap *soap, const char *tag, struct dss__SetSetValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSetValue, sizeof(struct dss__SetSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSetValue, 0, sizeof(struct dss__SetSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSetValue(struct soap *soap, const struct dss__SetSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSetValue);
	if (soap_out_dss__SetSetValue(soap, tag?tag:"dss:SetSetValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetSetValue * SOAP_FMAC4 soap_get_dss__SetSetValue(struct soap *soap, struct dss__SetSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetSetValue * SOAP_FMAC2 soap_instantiate_dss__SetSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetSetValue);
		if (size)
			*size = sizeof(struct dss__SetSetValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetSetValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSetValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSetValue %p -> %p\n", q, p));
	*(struct dss__SetSetValue*)p = *(struct dss__SetSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSetValueResponse(struct soap *soap, struct dss__SetSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSetValueResponse(struct soap *soap, const struct dss__SetSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__SetSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSetValueResponse * SOAP_FMAC4 soap_in_dss__SetSetValueResponse(struct soap *soap, const char *tag, struct dss__SetSetValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSetValueResponse, sizeof(struct dss__SetSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSetValueResponse, 0, sizeof(struct dss__SetSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSetValueResponse(struct soap *soap, const struct dss__SetSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSetValueResponse);
	if (soap_out_dss__SetSetValueResponse(soap, tag?tag:"dss:SetSetValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetSetValueResponse * SOAP_FMAC4 soap_get_dss__SetSetValueResponse(struct soap *soap, struct dss__SetSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetSetValueResponse * SOAP_FMAC2 soap_instantiate_dss__SetSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetSetValueResponse);
		if (size)
			*size = sizeof(struct dss__SetSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetSetValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSetValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSetValueResponse %p -> %p\n", q, p));
	*(struct dss__SetSetValueResponse*)p = *(struct dss__SetSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetDecreaseValue(struct soap *soap, struct dss__SetDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetDecreaseValue(struct soap *soap, const struct dss__SetDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__SetDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetDecreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetDecreaseValue * SOAP_FMAC4 soap_in_dss__SetDecreaseValue(struct soap *soap, const char *tag, struct dss__SetDecreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetDecreaseValue, sizeof(struct dss__SetDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetDecreaseValue, 0, sizeof(struct dss__SetDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetDecreaseValue(struct soap *soap, const struct dss__SetDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetDecreaseValue);
	if (soap_out_dss__SetDecreaseValue(soap, tag?tag:"dss:SetDecreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetDecreaseValue * SOAP_FMAC4 soap_get_dss__SetDecreaseValue(struct soap *soap, struct dss__SetDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetDecreaseValue * SOAP_FMAC2 soap_instantiate_dss__SetDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetDecreaseValue);
		if (size)
			*size = sizeof(struct dss__SetDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetDecreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetDecreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetDecreaseValue %p -> %p\n", q, p));
	*(struct dss__SetDecreaseValue*)p = *(struct dss__SetDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetDecreaseValueResponse(struct soap *soap, struct dss__SetDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetDecreaseValueResponse(struct soap *soap, const struct dss__SetDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__SetDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__SetDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__SetDecreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetDecreaseValueResponse, sizeof(struct dss__SetDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetDecreaseValueResponse, 0, sizeof(struct dss__SetDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetDecreaseValueResponse(struct soap *soap, const struct dss__SetDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetDecreaseValueResponse);
	if (soap_out_dss__SetDecreaseValueResponse(soap, tag?tag:"dss:SetDecreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__SetDecreaseValueResponse(struct soap *soap, struct dss__SetDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetDecreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__SetDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetDecreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__SetDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetDecreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetDecreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__SetDecreaseValueResponse*)p = *(struct dss__SetDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetIncreaseValue(struct soap *soap, struct dss__SetIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetIncreaseValue(struct soap *soap, const struct dss__SetIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__SetIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetIncreaseValue), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetIncreaseValue * SOAP_FMAC4 soap_in_dss__SetIncreaseValue(struct soap *soap, const char *tag, struct dss__SetIncreaseValue *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetIncreaseValue, sizeof(struct dss__SetIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetIncreaseValue, 0, sizeof(struct dss__SetIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetIncreaseValue(struct soap *soap, const struct dss__SetIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetIncreaseValue);
	if (soap_out_dss__SetIncreaseValue(soap, tag?tag:"dss:SetIncreaseValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetIncreaseValue * SOAP_FMAC4 soap_get_dss__SetIncreaseValue(struct soap *soap, struct dss__SetIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetIncreaseValue * SOAP_FMAC2 soap_instantiate_dss__SetIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetIncreaseValue);
		if (size)
			*size = sizeof(struct dss__SetIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetIncreaseValue[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetIncreaseValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetIncreaseValue %p -> %p\n", q, p));
	*(struct dss__SetIncreaseValue*)p = *(struct dss__SetIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetIncreaseValueResponse(struct soap *soap, struct dss__SetIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetIncreaseValueResponse(struct soap *soap, const struct dss__SetIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__SetIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__SetIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__SetIncreaseValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetIncreaseValueResponse, sizeof(struct dss__SetIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetIncreaseValueResponse, 0, sizeof(struct dss__SetIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetIncreaseValueResponse(struct soap *soap, const struct dss__SetIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetIncreaseValueResponse);
	if (soap_out_dss__SetIncreaseValueResponse(soap, tag?tag:"dss:SetIncreaseValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__SetIncreaseValueResponse(struct soap *soap, struct dss__SetIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetIncreaseValueResponse * SOAP_FMAC2 soap_instantiate_dss__SetIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetIncreaseValueResponse);
		if (size)
			*size = sizeof(struct dss__SetIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetIncreaseValueResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetIncreaseValueResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__SetIncreaseValueResponse*)p = *(struct dss__SetIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOff(struct soap *soap, struct dss__SetTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOff(struct soap *soap, const struct dss__SetTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOff(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOff), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOff * SOAP_FMAC4 soap_in_dss__SetTurnOff(struct soap *soap, const char *tag, struct dss__SetTurnOff *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOff, sizeof(struct dss__SetTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOff, 0, sizeof(struct dss__SetTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOff(struct soap *soap, const struct dss__SetTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOff);
	if (soap_out_dss__SetTurnOff(soap, tag?tag:"dss:SetTurnOff", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetTurnOff * SOAP_FMAC4 soap_get_dss__SetTurnOff(struct soap *soap, struct dss__SetTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetTurnOff * SOAP_FMAC2 soap_instantiate_dss__SetTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetTurnOff);
		if (size)
			*size = sizeof(struct dss__SetTurnOff);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetTurnOff[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOff*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOff %p -> %p\n", q, p));
	*(struct dss__SetTurnOff*)p = *(struct dss__SetTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOffResponse(struct soap *soap, struct dss__SetTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOffResponse(struct soap *soap, const struct dss__SetTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOffResponse * SOAP_FMAC4 soap_in_dss__SetTurnOffResponse(struct soap *soap, const char *tag, struct dss__SetTurnOffResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOffResponse, sizeof(struct dss__SetTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOffResponse, 0, sizeof(struct dss__SetTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOffResponse(struct soap *soap, const struct dss__SetTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOffResponse);
	if (soap_out_dss__SetTurnOffResponse(soap, tag?tag:"dss:SetTurnOffResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetTurnOffResponse * SOAP_FMAC4 soap_get_dss__SetTurnOffResponse(struct soap *soap, struct dss__SetTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetTurnOffResponse * SOAP_FMAC2 soap_instantiate_dss__SetTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetTurnOffResponse);
		if (size)
			*size = sizeof(struct dss__SetTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetTurnOffResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOffResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__SetTurnOffResponse*)p = *(struct dss__SetTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOn(struct soap *soap, struct dss__SetTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOn(struct soap *soap, const struct dss__SetTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOn(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOn), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOn * SOAP_FMAC4 soap_in_dss__SetTurnOn(struct soap *soap, const char *tag, struct dss__SetTurnOn *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOn, sizeof(struct dss__SetTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOn, 0, sizeof(struct dss__SetTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOn(struct soap *soap, const struct dss__SetTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOn);
	if (soap_out_dss__SetTurnOn(soap, tag?tag:"dss:SetTurnOn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetTurnOn * SOAP_FMAC4 soap_get_dss__SetTurnOn(struct soap *soap, struct dss__SetTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetTurnOn * SOAP_FMAC2 soap_instantiate_dss__SetTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetTurnOn);
		if (size)
			*size = sizeof(struct dss__SetTurnOn);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetTurnOn[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOn %p -> %p\n", q, p));
	*(struct dss__SetTurnOn*)p = *(struct dss__SetTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOnResponse(struct soap *soap, struct dss__SetTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOnResponse(struct soap *soap, const struct dss__SetTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOnResponse * SOAP_FMAC4 soap_in_dss__SetTurnOnResponse(struct soap *soap, const char *tag, struct dss__SetTurnOnResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOnResponse, sizeof(struct dss__SetTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOnResponse, 0, sizeof(struct dss__SetTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOnResponse(struct soap *soap, const struct dss__SetTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOnResponse);
	if (soap_out_dss__SetTurnOnResponse(soap, tag?tag:"dss:SetTurnOnResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetTurnOnResponse * SOAP_FMAC4 soap_get_dss__SetTurnOnResponse(struct soap *soap, struct dss__SetTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetTurnOnResponse * SOAP_FMAC2 soap_instantiate_dss__SetTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetTurnOnResponse);
		if (size)
			*size = sizeof(struct dss__SetTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetTurnOnResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOnResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__SetTurnOnResponse*)p = *(struct dss__SetTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneIDs(struct soap *soap, struct dss__ApartmentGetZoneIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneIDs(struct soap *soap, const struct dss__ApartmentGetZoneIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneIDs(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneIDs), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDs * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneIDs(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneIDs *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneIDs, sizeof(struct dss__ApartmentGetZoneIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneIDs, 0, sizeof(struct dss__ApartmentGetZoneIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneIDs(struct soap *soap, const struct dss__ApartmentGetZoneIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneIDs);
	if (soap_out_dss__ApartmentGetZoneIDs(soap, tag?tag:"dss:ApartmentGetZoneIDs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDs * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneIDs(struct soap *soap, struct dss__ApartmentGetZoneIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetZoneIDs * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetZoneIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneIDs);
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneIDs);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneIDs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneIDs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneIDs %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneIDs*)p = *(struct dss__ApartmentGetZoneIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneIDsResponse(struct soap *soap, struct dss__ApartmentGetZoneIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfint(soap, &a->zoneIDs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const struct dss__ApartmentGetZoneIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->zoneIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "zoneIDs", -1, &a->zoneIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDsResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneIDsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse, sizeof(struct dss__ApartmentGetZoneIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "zoneIDs", &a->zoneIDs, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse, 0, sizeof(struct dss__ApartmentGetZoneIDsResponse), 0, soap_copy_dss__ApartmentGetZoneIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->zoneIDs.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const struct dss__ApartmentGetZoneIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse);
	if (soap_out_dss__ApartmentGetZoneIDsResponse(soap, tag?tag:"dss:ApartmentGetZoneIDsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDsResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneIDsResponse(struct soap *soap, struct dss__ApartmentGetZoneIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetZoneIDsResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetZoneIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneIDsResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneIDsResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneIDsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneIDsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneIDsResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneIDsResponse*)p = *(struct dss__ApartmentGetZoneIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneByName(struct soap *soap, struct dss__ApartmentGetZoneByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_zoneName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneByName(struct soap *soap, const struct dss__ApartmentGetZoneByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_zoneName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneByName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneByName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "zoneName", -1, &a->_zoneName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByName * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneByName(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneByName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__zoneName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneByName, sizeof(struct dss__ApartmentGetZoneByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_zoneName, "xsd:string"))
				{	soap_flag__zoneName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneByName, 0, sizeof(struct dss__ApartmentGetZoneByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneByName(struct soap *soap, const struct dss__ApartmentGetZoneByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneByName);
	if (soap_out_dss__ApartmentGetZoneByName(soap, tag?tag:"dss:ApartmentGetZoneByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByName * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneByName(struct soap *soap, struct dss__ApartmentGetZoneByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetZoneByName * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetZoneByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneByName);
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneByName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneByName %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneByName*)p = *(struct dss__ApartmentGetZoneByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneByNameResponse(struct soap *soap, struct dss__ApartmentGetZoneByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const struct dss__ApartmentGetZoneByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneByNameResponse *a, const char *type)
{
	size_t soap_flag_zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse, sizeof(struct dss__ApartmentGetZoneByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zoneID", &a->zoneID, "xsd:int"))
				{	soap_flag_zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse, 0, sizeof(struct dss__ApartmentGetZoneByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const struct dss__ApartmentGetZoneByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse);
	if (soap_out_dss__ApartmentGetZoneByNameResponse(soap, tag?tag:"dss:ApartmentGetZoneByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneByNameResponse(struct soap *soap, struct dss__ApartmentGetZoneByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetZoneByNameResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetZoneByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneByNameResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneByNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetZoneByNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneByNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneByNameResponse*)p = *(struct dss__ApartmentGetZoneByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetGroupByName(struct soap *soap, struct dss__ApartmentGetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetGroupByName(struct soap *soap, const struct dss__ApartmentGetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetGroupByName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetGroupByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetGroupByName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByName * SOAP_FMAC4 soap_in_dss__ApartmentGetGroupByName(struct soap *soap, const char *tag, struct dss__ApartmentGetGroupByName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetGroupByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetGroupByName, sizeof(struct dss__ApartmentGetGroupByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetGroupByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetGroupByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetGroupByName, 0, sizeof(struct dss__ApartmentGetGroupByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetGroupByName(struct soap *soap, const struct dss__ApartmentGetGroupByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetGroupByName);
	if (soap_out_dss__ApartmentGetGroupByName(soap, tag?tag:"dss:ApartmentGetGroupByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByName * SOAP_FMAC4 soap_get_dss__ApartmentGetGroupByName(struct soap *soap, struct dss__ApartmentGetGroupByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetGroupByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetGroupByName * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetGroupByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetGroupByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetGroupByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetGroupByName);
		if (size)
			*size = sizeof(struct dss__ApartmentGetGroupByName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetGroupByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetGroupByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetGroupByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetGroupByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetGroupByName %p -> %p\n", q, p));
	*(struct dss__ApartmentGetGroupByName*)p = *(struct dss__ApartmentGetGroupByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetGroupByNameResponse(struct soap *soap, struct dss__ApartmentGetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const struct dss__ApartmentGetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetGroupByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetGroupByNameResponse *a, const char *type)
{
	size_t soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetGroupByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse, sizeof(struct dss__ApartmentGetGroupByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetGroupByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupID", &a->groupID, "xsd:int"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetGroupByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse, 0, sizeof(struct dss__ApartmentGetGroupByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const struct dss__ApartmentGetGroupByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse);
	if (soap_out_dss__ApartmentGetGroupByNameResponse(soap, tag?tag:"dss:ApartmentGetGroupByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetGroupByNameResponse(struct soap *soap, struct dss__ApartmentGetGroupByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetGroupByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetGroupByNameResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetGroupByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetGroupByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetGroupByNameResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentGetGroupByNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetGroupByNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetGroupByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetGroupByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetGroupByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetGroupByNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetGroupByNameResponse*)p = *(struct dss__ApartmentGetGroupByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetGetContainedDevices(struct soap *soap, struct dss__SetGetContainedDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetGetContainedDevices(struct soap *soap, const struct dss__SetGetContainedDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetGetContainedDevices(struct soap *soap, const char *tag, int id, const struct dss__SetGetContainedDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetGetContainedDevices), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetGetContainedDevices * SOAP_FMAC4 soap_in_dss__SetGetContainedDevices(struct soap *soap, const char *tag, struct dss__SetGetContainedDevices *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetGetContainedDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetGetContainedDevices, sizeof(struct dss__SetGetContainedDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetGetContainedDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetGetContainedDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetGetContainedDevices, 0, sizeof(struct dss__SetGetContainedDevices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetGetContainedDevices(struct soap *soap, const struct dss__SetGetContainedDevices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetGetContainedDevices);
	if (soap_out_dss__SetGetContainedDevices(soap, tag?tag:"dss:SetGetContainedDevices", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetGetContainedDevices * SOAP_FMAC4 soap_get_dss__SetGetContainedDevices(struct soap *soap, struct dss__SetGetContainedDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetGetContainedDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetGetContainedDevices * SOAP_FMAC2 soap_instantiate_dss__SetGetContainedDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetGetContainedDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetGetContainedDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetGetContainedDevices);
		if (size)
			*size = sizeof(struct dss__SetGetContainedDevices);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetGetContainedDevices[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetGetContainedDevices);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetGetContainedDevices*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetGetContainedDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetGetContainedDevices %p -> %p\n", q, p));
	*(struct dss__SetGetContainedDevices*)p = *(struct dss__SetGetContainedDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetGetContainedDevicesResponse(struct soap *soap, struct dss__SetGetContainedDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->deviceIDs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetGetContainedDevicesResponse(struct soap *soap, const struct dss__SetGetContainedDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->deviceIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetGetContainedDevicesResponse(struct soap *soap, const char *tag, int id, const struct dss__SetGetContainedDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetGetContainedDevicesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "deviceIDs", -1, &a->deviceIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetGetContainedDevicesResponse * SOAP_FMAC4 soap_in_dss__SetGetContainedDevicesResponse(struct soap *soap, const char *tag, struct dss__SetGetContainedDevicesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetGetContainedDevicesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetGetContainedDevicesResponse, sizeof(struct dss__SetGetContainedDevicesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetGetContainedDevicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "deviceIDs", &a->deviceIDs, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetGetContainedDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetGetContainedDevicesResponse, 0, sizeof(struct dss__SetGetContainedDevicesResponse), 0, soap_copy_dss__SetGetContainedDevicesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->deviceIDs.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetGetContainedDevicesResponse(struct soap *soap, const struct dss__SetGetContainedDevicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetGetContainedDevicesResponse);
	if (soap_out_dss__SetGetContainedDevicesResponse(soap, tag?tag:"dss:SetGetContainedDevicesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetGetContainedDevicesResponse * SOAP_FMAC4 soap_get_dss__SetGetContainedDevicesResponse(struct soap *soap, struct dss__SetGetContainedDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetGetContainedDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetGetContainedDevicesResponse * SOAP_FMAC2 soap_instantiate_dss__SetGetContainedDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetGetContainedDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetGetContainedDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetGetContainedDevicesResponse);
		if (size)
			*size = sizeof(struct dss__SetGetContainedDevicesResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetGetContainedDevicesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetGetContainedDevicesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetGetContainedDevicesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetGetContainedDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetGetContainedDevicesResponse %p -> %p\n", q, p));
	*(struct dss__SetGetContainedDevicesResponse*)p = *(struct dss__SetGetContainedDevicesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetByGroup(struct soap *soap, struct dss__SetByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetByGroup(struct soap *soap, const struct dss__SetByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetByGroup(struct soap *soap, const char *tag, int id, const struct dss__SetByGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetByGroup), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetByGroup * SOAP_FMAC4 soap_in_dss__SetByGroup(struct soap *soap, const char *tag, struct dss__SetByGroup *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetByGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetByGroup, sizeof(struct dss__SetByGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetByGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetByGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetByGroup, 0, sizeof(struct dss__SetByGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetByGroup(struct soap *soap, const struct dss__SetByGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetByGroup);
	if (soap_out_dss__SetByGroup(soap, tag?tag:"dss:SetByGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetByGroup * SOAP_FMAC4 soap_get_dss__SetByGroup(struct soap *soap, struct dss__SetByGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetByGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetByGroup * SOAP_FMAC2 soap_instantiate_dss__SetByGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetByGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetByGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetByGroup);
		if (size)
			*size = sizeof(struct dss__SetByGroup);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetByGroup[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetByGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetByGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetByGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetByGroup %p -> %p\n", q, p));
	*(struct dss__SetByGroup*)p = *(struct dss__SetByGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetByGroupResponse(struct soap *soap, struct dss__SetByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetByGroupResponse(struct soap *soap, const struct dss__SetByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetByGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__SetByGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetByGroupResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetByGroupResponse * SOAP_FMAC4 soap_in_dss__SetByGroupResponse(struct soap *soap, const char *tag, struct dss__SetByGroupResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetByGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetByGroupResponse, sizeof(struct dss__SetByGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetByGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetByGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetByGroupResponse, 0, sizeof(struct dss__SetByGroupResponse), 0, soap_copy_dss__SetByGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetByGroupResponse(struct soap *soap, const struct dss__SetByGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetByGroupResponse);
	if (soap_out_dss__SetByGroupResponse(soap, tag?tag:"dss:SetByGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetByGroupResponse * SOAP_FMAC4 soap_get_dss__SetByGroupResponse(struct soap *soap, struct dss__SetByGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetByGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetByGroupResponse * SOAP_FMAC2 soap_instantiate_dss__SetByGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetByGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetByGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetByGroupResponse);
		if (size)
			*size = sizeof(struct dss__SetByGroupResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetByGroupResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetByGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetByGroupResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetByGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetByGroupResponse %p -> %p\n", q, p));
	*(struct dss__SetByGroupResponse*)p = *(struct dss__SetByGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemove(struct soap *soap, struct dss__SetRemove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_setSpecToRemove);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemove(struct soap *soap, const struct dss__SetRemove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_setSpecToRemove);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemove(struct soap *soap, const char *tag, int id, const struct dss__SetRemove *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemove), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpecToRemove", -1, &a->_setSpecToRemove, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemove * SOAP_FMAC4 soap_in_dss__SetRemove(struct soap *soap, const char *tag, struct dss__SetRemove *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__setSpecToRemove = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemove, sizeof(struct dss__SetRemove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetRemove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__setSpecToRemove && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpecToRemove, "xsd:string"))
				{	soap_flag__setSpecToRemove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemove, 0, sizeof(struct dss__SetRemove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemove(struct soap *soap, const struct dss__SetRemove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemove);
	if (soap_out_dss__SetRemove(soap, tag?tag:"dss:SetRemove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetRemove * SOAP_FMAC4 soap_get_dss__SetRemove(struct soap *soap, struct dss__SetRemove *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetRemove * SOAP_FMAC2 soap_instantiate_dss__SetRemove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetRemove);
		if (size)
			*size = sizeof(struct dss__SetRemove);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetRemove[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemove);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemove*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemove %p -> %p\n", q, p));
	*(struct dss__SetRemove*)p = *(struct dss__SetRemove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemoveResponse(struct soap *soap, struct dss__SetRemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemoveResponse(struct soap *soap, const struct dss__SetRemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemoveResponse(struct soap *soap, const char *tag, int id, const struct dss__SetRemoveResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemoveResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemoveResponse * SOAP_FMAC4 soap_in_dss__SetRemoveResponse(struct soap *soap, const char *tag, struct dss__SetRemoveResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemoveResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemoveResponse, sizeof(struct dss__SetRemoveResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetRemoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemoveResponse, 0, sizeof(struct dss__SetRemoveResponse), 0, soap_copy_dss__SetRemoveResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemoveResponse(struct soap *soap, const struct dss__SetRemoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemoveResponse);
	if (soap_out_dss__SetRemoveResponse(soap, tag?tag:"dss:SetRemoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetRemoveResponse * SOAP_FMAC4 soap_get_dss__SetRemoveResponse(struct soap *soap, struct dss__SetRemoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetRemoveResponse * SOAP_FMAC2 soap_instantiate_dss__SetRemoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemoveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemoveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetRemoveResponse);
		if (size)
			*size = sizeof(struct dss__SetRemoveResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetRemoveResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemoveResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemoveResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemoveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemoveResponse %p -> %p\n", q, p));
	*(struct dss__SetRemoveResponse*)p = *(struct dss__SetRemoveResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCombine(struct soap *soap, struct dss__SetCombine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec1);
	soap_default_string(soap, &a->_setSpec2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCombine(struct soap *soap, const struct dss__SetCombine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec1);
	soap_serialize_string(soap, &a->_setSpec2);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCombine(struct soap *soap, const char *tag, int id, const struct dss__SetCombine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCombine), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec1", -1, &a->_setSpec1, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec2", -1, &a->_setSpec2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCombine * SOAP_FMAC4 soap_in_dss__SetCombine(struct soap *soap, const char *tag, struct dss__SetCombine *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec1 = 1;
	size_t soap_flag__setSpec2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCombine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCombine, sizeof(struct dss__SetCombine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetCombine(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec1, "xsd:string"))
				{	soap_flag__setSpec1--;
					continue;
				}
			if (soap_flag__setSpec2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec2, "xsd:string"))
				{	soap_flag__setSpec2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCombine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCombine, 0, sizeof(struct dss__SetCombine), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCombine(struct soap *soap, const struct dss__SetCombine *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCombine);
	if (soap_out_dss__SetCombine(soap, tag?tag:"dss:SetCombine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetCombine * SOAP_FMAC4 soap_get_dss__SetCombine(struct soap *soap, struct dss__SetCombine *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCombine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetCombine * SOAP_FMAC2 soap_instantiate_dss__SetCombine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCombine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCombine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetCombine);
		if (size)
			*size = sizeof(struct dss__SetCombine);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetCombine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCombine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCombine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCombine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCombine %p -> %p\n", q, p));
	*(struct dss__SetCombine*)p = *(struct dss__SetCombine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCombineResponse(struct soap *soap, struct dss__SetCombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCombineResponse(struct soap *soap, const struct dss__SetCombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCombineResponse(struct soap *soap, const char *tag, int id, const struct dss__SetCombineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCombineResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCombineResponse * SOAP_FMAC4 soap_in_dss__SetCombineResponse(struct soap *soap, const char *tag, struct dss__SetCombineResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCombineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCombineResponse, sizeof(struct dss__SetCombineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetCombineResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCombineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCombineResponse, 0, sizeof(struct dss__SetCombineResponse), 0, soap_copy_dss__SetCombineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCombineResponse(struct soap *soap, const struct dss__SetCombineResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCombineResponse);
	if (soap_out_dss__SetCombineResponse(soap, tag?tag:"dss:SetCombineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetCombineResponse * SOAP_FMAC4 soap_get_dss__SetCombineResponse(struct soap *soap, struct dss__SetCombineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCombineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetCombineResponse * SOAP_FMAC2 soap_instantiate_dss__SetCombineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCombineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCombineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetCombineResponse);
		if (size)
			*size = sizeof(struct dss__SetCombineResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetCombineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCombineResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCombineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCombineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCombineResponse %p -> %p\n", q, p));
	*(struct dss__SetCombineResponse*)p = *(struct dss__SetCombineResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemoveDevice(struct soap *soap, struct dss__SetRemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemoveDevice(struct soap *soap, const struct dss__SetRemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__SetRemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemoveDevice), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemoveDevice * SOAP_FMAC4 soap_in_dss__SetRemoveDevice(struct soap *soap, const char *tag, struct dss__SetRemoveDevice *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemoveDevice, sizeof(struct dss__SetRemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetRemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemoveDevice, 0, sizeof(struct dss__SetRemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemoveDevice(struct soap *soap, const struct dss__SetRemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemoveDevice);
	if (soap_out_dss__SetRemoveDevice(soap, tag?tag:"dss:SetRemoveDevice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetRemoveDevice * SOAP_FMAC4 soap_get_dss__SetRemoveDevice(struct soap *soap, struct dss__SetRemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetRemoveDevice * SOAP_FMAC2 soap_instantiate_dss__SetRemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetRemoveDevice);
		if (size)
			*size = sizeof(struct dss__SetRemoveDevice);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetRemoveDevice[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemoveDevice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemoveDevice %p -> %p\n", q, p));
	*(struct dss__SetRemoveDevice*)p = *(struct dss__SetRemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemoveDeviceResponse(struct soap *soap, struct dss__SetRemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemoveDeviceResponse(struct soap *soap, const struct dss__SetRemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__SetRemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__SetRemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__SetRemoveDeviceResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemoveDeviceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemoveDeviceResponse, sizeof(struct dss__SetRemoveDeviceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetRemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemoveDeviceResponse, 0, sizeof(struct dss__SetRemoveDeviceResponse), 0, soap_copy_dss__SetRemoveDeviceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemoveDeviceResponse(struct soap *soap, const struct dss__SetRemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemoveDeviceResponse);
	if (soap_out_dss__SetRemoveDeviceResponse(soap, tag?tag:"dss:SetRemoveDeviceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetRemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__SetRemoveDeviceResponse(struct soap *soap, struct dss__SetRemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetRemoveDeviceResponse * SOAP_FMAC2 soap_instantiate_dss__SetRemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetRemoveDeviceResponse);
		if (size)
			*size = sizeof(struct dss__SetRemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetRemoveDeviceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemoveDeviceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__SetRemoveDeviceResponse*)p = *(struct dss__SetRemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByID(struct soap *soap, struct dss__SetAddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByID(struct soap *soap, const struct dss__SetAddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByID(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByID), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByID * SOAP_FMAC4 soap_in_dss__SetAddDeviceByID(struct soap *soap, const char *tag, struct dss__SetAddDeviceByID *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByID, sizeof(struct dss__SetAddDeviceByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByID, 0, sizeof(struct dss__SetAddDeviceByID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByID(struct soap *soap, const struct dss__SetAddDeviceByID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByID);
	if (soap_out_dss__SetAddDeviceByID(soap, tag?tag:"dss:SetAddDeviceByID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetAddDeviceByID * SOAP_FMAC4 soap_get_dss__SetAddDeviceByID(struct soap *soap, struct dss__SetAddDeviceByID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetAddDeviceByID * SOAP_FMAC2 soap_instantiate_dss__SetAddDeviceByID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByID);
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByID);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByID[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByID %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByID*)p = *(struct dss__SetAddDeviceByID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByIDResponse(struct soap *soap, struct dss__SetAddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByIDResponse(struct soap *soap, const struct dss__SetAddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByIDResponse(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByIDResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByIDResponse * SOAP_FMAC4 soap_in_dss__SetAddDeviceByIDResponse(struct soap *soap, const char *tag, struct dss__SetAddDeviceByIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByIDResponse, sizeof(struct dss__SetAddDeviceByIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByIDResponse, 0, sizeof(struct dss__SetAddDeviceByIDResponse), 0, soap_copy_dss__SetAddDeviceByIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByIDResponse(struct soap *soap, const struct dss__SetAddDeviceByIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByIDResponse);
	if (soap_out_dss__SetAddDeviceByIDResponse(soap, tag?tag:"dss:SetAddDeviceByIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetAddDeviceByIDResponse * SOAP_FMAC4 soap_get_dss__SetAddDeviceByIDResponse(struct soap *soap, struct dss__SetAddDeviceByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetAddDeviceByIDResponse * SOAP_FMAC2 soap_instantiate_dss__SetAddDeviceByIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByIDResponse);
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByIDResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByIDResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByIDResponse %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByIDResponse*)p = *(struct dss__SetAddDeviceByIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByName(struct soap *soap, struct dss__SetAddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByName(struct soap *soap, const struct dss__SetAddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByName(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByName * SOAP_FMAC4 soap_in_dss__SetAddDeviceByName(struct soap *soap, const char *tag, struct dss__SetAddDeviceByName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__setSpec = 1;
	size_t soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByName, sizeof(struct dss__SetAddDeviceByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByName, 0, sizeof(struct dss__SetAddDeviceByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByName(struct soap *soap, const struct dss__SetAddDeviceByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByName);
	if (soap_out_dss__SetAddDeviceByName(soap, tag?tag:"dss:SetAddDeviceByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetAddDeviceByName * SOAP_FMAC4 soap_get_dss__SetAddDeviceByName(struct soap *soap, struct dss__SetAddDeviceByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetAddDeviceByName * SOAP_FMAC2 soap_instantiate_dss__SetAddDeviceByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByName);
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByName %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByName*)p = *(struct dss__SetAddDeviceByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByNameResponse(struct soap *soap, struct dss__SetAddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByNameResponse(struct soap *soap, const struct dss__SetAddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByNameResponse * SOAP_FMAC4 soap_in_dss__SetAddDeviceByNameResponse(struct soap *soap, const char *tag, struct dss__SetAddDeviceByNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByNameResponse, sizeof(struct dss__SetAddDeviceByNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByNameResponse, 0, sizeof(struct dss__SetAddDeviceByNameResponse), 0, soap_copy_dss__SetAddDeviceByNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByNameResponse(struct soap *soap, const struct dss__SetAddDeviceByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByNameResponse);
	if (soap_out_dss__SetAddDeviceByNameResponse(soap, tag?tag:"dss:SetAddDeviceByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SetAddDeviceByNameResponse * SOAP_FMAC4 soap_get_dss__SetAddDeviceByNameResponse(struct soap *soap, struct dss__SetAddDeviceByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SetAddDeviceByNameResponse * SOAP_FMAC2 soap_instantiate_dss__SetAddDeviceByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByNameResponse);
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SetAddDeviceByNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByNameResponse %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByNameResponse*)p = *(struct dss__SetAddDeviceByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSetName(struct soap *soap, struct dss__ApartmentSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSetName(struct soap *soap, const struct dss__ApartmentSetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSetName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSetName * SOAP_FMAC4 soap_in_dss__ApartmentSetName(struct soap *soap, const char *tag, struct dss__ApartmentSetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSetName, sizeof(struct dss__ApartmentSetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSetName, 0, sizeof(struct dss__ApartmentSetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSetName(struct soap *soap, const struct dss__ApartmentSetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSetName);
	if (soap_out_dss__ApartmentSetName(soap, tag?tag:"dss:ApartmentSetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentSetName * SOAP_FMAC4 soap_get_dss__ApartmentSetName(struct soap *soap, struct dss__ApartmentSetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentSetName * SOAP_FMAC2 soap_instantiate_dss__ApartmentSetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentSetName);
		if (size)
			*size = sizeof(struct dss__ApartmentSetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentSetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSetName %p -> %p\n", q, p));
	*(struct dss__ApartmentSetName*)p = *(struct dss__ApartmentSetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSetNameResponse(struct soap *soap, struct dss__ApartmentSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSetNameResponse(struct soap *soap, const struct dss__ApartmentSetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSetNameResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSetNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentSetNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentSetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSetNameResponse, sizeof(struct dss__ApartmentSetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSetNameResponse, 0, sizeof(struct dss__ApartmentSetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSetNameResponse(struct soap *soap, const struct dss__ApartmentSetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSetNameResponse);
	if (soap_out_dss__ApartmentSetNameResponse(soap, tag?tag:"dss:ApartmentSetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentSetNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentSetNameResponse(struct soap *soap, struct dss__ApartmentSetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentSetNameResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentSetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentSetNameResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentSetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentSetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSetNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentSetNameResponse*)p = *(struct dss__ApartmentSetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetName(struct soap *soap, struct dss__ApartmentGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetName(struct soap *soap, const struct dss__ApartmentGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetName * SOAP_FMAC4 soap_in_dss__ApartmentGetName(struct soap *soap, const char *tag, struct dss__ApartmentGetName *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetName, sizeof(struct dss__ApartmentGetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetName, 0, sizeof(struct dss__ApartmentGetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetName(struct soap *soap, const struct dss__ApartmentGetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetName);
	if (soap_out_dss__ApartmentGetName(soap, tag?tag:"dss:ApartmentGetName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetName * SOAP_FMAC4 soap_get_dss__ApartmentGetName(struct soap *soap, struct dss__ApartmentGetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetName * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetName);
		if (size)
			*size = sizeof(struct dss__ApartmentGetName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetName %p -> %p\n", q, p));
	*(struct dss__ApartmentGetName*)p = *(struct dss__ApartmentGetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetNameResponse(struct soap *soap, struct dss__ApartmentGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetNameResponse(struct soap *soap, const struct dss__ApartmentGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetNameResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetNameResponse, sizeof(struct dss__ApartmentGetNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetNameResponse, 0, sizeof(struct dss__ApartmentGetNameResponse), 0, soap_copy_dss__ApartmentGetNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetNameResponse(struct soap *soap, const struct dss__ApartmentGetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetNameResponse);
	if (soap_out_dss__ApartmentGetNameResponse(soap, tag?tag:"dss:ApartmentGetNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetNameResponse(struct soap *soap, struct dss__ApartmentGetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetNameResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetNameResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentGetNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetNameResponse*)p = *(struct dss__ApartmentGetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDeviceIDByName(struct soap *soap, struct dss__ApartmentGetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_deviceName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDeviceIDByName(struct soap *soap, const struct dss__ApartmentGetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_deviceName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDeviceIDByName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDeviceIDByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByName), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceName", -1, &a->_deviceName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByName * SOAP_FMAC4 soap_in_dss__ApartmentGetDeviceIDByName(struct soap *soap, const char *tag, struct dss__ApartmentGetDeviceIDByName *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__deviceName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDeviceIDByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByName, sizeof(struct dss__ApartmentGetDeviceIDByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDeviceIDByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceName, "xsd:string"))
				{	soap_flag__deviceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDeviceIDByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDeviceIDByName, 0, sizeof(struct dss__ApartmentGetDeviceIDByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDeviceIDByName(struct soap *soap, const struct dss__ApartmentGetDeviceIDByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDeviceIDByName);
	if (soap_out_dss__ApartmentGetDeviceIDByName(soap, tag?tag:"dss:ApartmentGetDeviceIDByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByName * SOAP_FMAC4 soap_get_dss__ApartmentGetDeviceIDByName(struct soap *soap, struct dss__ApartmentGetDeviceIDByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDeviceIDByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetDeviceIDByName * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetDeviceIDByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDeviceIDByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDeviceIDByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDeviceIDByName);
		if (size)
			*size = sizeof(struct dss__ApartmentGetDeviceIDByName);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDeviceIDByName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDeviceIDByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDeviceIDByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDeviceIDByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDeviceIDByName %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDeviceIDByName*)p = *(struct dss__ApartmentGetDeviceIDByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, struct dss__ApartmentGetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const struct dss__ApartmentGetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDeviceIDByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetDeviceIDByNameResponse *a, const char *type)
{
	size_t soap_flag_deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDeviceIDByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse, sizeof(struct dss__ApartmentGetDeviceIDByNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDeviceIDByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "deviceID", &a->deviceID, "xsd:string"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDeviceIDByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse, 0, sizeof(struct dss__ApartmentGetDeviceIDByNameResponse), 0, soap_copy_dss__ApartmentGetDeviceIDByNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const struct dss__ApartmentGetDeviceIDByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse);
	if (soap_out_dss__ApartmentGetDeviceIDByNameResponse(soap, tag?tag:"dss:ApartmentGetDeviceIDByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, struct dss__ApartmentGetDeviceIDByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDeviceIDByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetDeviceIDByNameResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDeviceIDByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDeviceIDByNameResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentGetDeviceIDByNameResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDeviceIDByNameResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDeviceIDByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDeviceIDByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDeviceIDByNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDeviceIDByNameResponse*)p = *(struct dss__ApartmentGetDeviceIDByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDevices(struct soap *soap, struct dss__ApartmentGetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDevices(struct soap *soap, const struct dss__ApartmentGetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDevices(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDevices), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDevices * SOAP_FMAC4 soap_in_dss__ApartmentGetDevices(struct soap *soap, const char *tag, struct dss__ApartmentGetDevices *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDevices, sizeof(struct dss__ApartmentGetDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDevices, 0, sizeof(struct dss__ApartmentGetDevices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDevices(struct soap *soap, const struct dss__ApartmentGetDevices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDevices);
	if (soap_out_dss__ApartmentGetDevices(soap, tag?tag:"dss:ApartmentGetDevices", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetDevices * SOAP_FMAC4 soap_get_dss__ApartmentGetDevices(struct soap *soap, struct dss__ApartmentGetDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetDevices * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDevices);
		if (size)
			*size = sizeof(struct dss__ApartmentGetDevices);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDevices[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDevices);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDevices*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDevices %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDevices*)p = *(struct dss__ApartmentGetDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDevicesResponse(struct soap *soap, struct dss__ApartmentGetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDevicesResponse(struct soap *soap, const struct dss__ApartmentGetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDevicesResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDevicesResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDevicesResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetDevicesResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetDevicesResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDevicesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDevicesResponse, sizeof(struct dss__ApartmentGetDevicesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDevicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDevicesResponse, 0, sizeof(struct dss__ApartmentGetDevicesResponse), 0, soap_copy_dss__ApartmentGetDevicesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDevicesResponse(struct soap *soap, const struct dss__ApartmentGetDevicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDevicesResponse);
	if (soap_out_dss__ApartmentGetDevicesResponse(soap, tag?tag:"dss:ApartmentGetDevicesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentGetDevicesResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetDevicesResponse(struct soap *soap, struct dss__ApartmentGetDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentGetDevicesResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentGetDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDevicesResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentGetDevicesResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentGetDevicesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDevicesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDevicesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDevicesResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDevicesResponse*)p = *(struct dss__ApartmentGetDevicesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__vectorTemplateOfstd__string(soap, &a->_names);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->_names);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "names", -1, &a->_names, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNames * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceNames *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames, sizeof(struct dss__ApartmentCreateSetFromDeviceNames), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, NULL, &a->_names, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceNames), 0, soap_copy_dss__ApartmentCreateSetFromDeviceNames);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_names.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNames *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames);
	if (soap_out_dss__ApartmentCreateSetFromDeviceNames(soap, tag?tag:"dss:ApartmentCreateSetFromDeviceNames", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNames * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCreateSetFromDeviceNames * SOAP_FMAC2 soap_instantiate_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceNames);
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceNames);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceNames[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceNames);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceNames*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceNames %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceNames*)p = *(struct dss__ApartmentCreateSetFromDeviceNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceNamesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceNamesResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse, sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse), 0, soap_copy_dss__ApartmentCreateSetFromDeviceNamesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNamesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse);
	if (soap_out_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, tag?tag:"dss:ApartmentCreateSetFromDeviceNamesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCreateSetFromDeviceNamesResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceNamesResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceNamesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceNamesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceNamesResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceNamesResponse*)p = *(struct dss__ApartmentCreateSetFromDeviceNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_std__vectorTemplateOfstd__string(soap, &a->_ids);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->_ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ids", -1, &a->_ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDs * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceIDs *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceIDs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs, sizeof(struct dss__ApartmentCreateSetFromDeviceIDs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, NULL, &a->_ids, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceIDs), 0, soap_copy_dss__ApartmentCreateSetFromDeviceIDs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_ids.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs);
	if (soap_out_dss__ApartmentCreateSetFromDeviceIDs(soap, tag?tag:"dss:ApartmentCreateSetFromDeviceIDs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDs * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCreateSetFromDeviceIDs * SOAP_FMAC2 soap_instantiate_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceIDs);
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceIDs);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceIDs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceIDs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceIDs %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceIDs*)p = *(struct dss__ApartmentCreateSetFromDeviceIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceIDsResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse, sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse), 0, soap_copy_dss__ApartmentCreateSetFromDeviceIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse);
	if (soap_out_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, tag?tag:"dss:ApartmentCreateSetFromDeviceIDsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCreateSetFromDeviceIDsResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceIDsResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromDeviceIDsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceIDsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceIDsResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceIDsResponse*)p = *(struct dss__ApartmentCreateSetFromDeviceIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromGroup(struct soap *soap, struct dss__ApartmentCreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromGroup(struct soap *soap, const struct dss__ApartmentCreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromGroup(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroup), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroup * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromGroup(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromGroup *a, const char *type)
{
	size_t soap_flag__token = 1;
	size_t soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroup, sizeof(struct dss__ApartmentCreateSetFromGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromGroup, 0, sizeof(struct dss__ApartmentCreateSetFromGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromGroup(struct soap *soap, const struct dss__ApartmentCreateSetFromGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromGroup);
	if (soap_out_dss__ApartmentCreateSetFromGroup(soap, tag?tag:"dss:ApartmentCreateSetFromGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroup * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromGroup(struct soap *soap, struct dss__ApartmentCreateSetFromGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCreateSetFromGroup * SOAP_FMAC2 soap_instantiate_dss__ApartmentCreateSetFromGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromGroup);
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromGroup);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromGroup[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromGroup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromGroup %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromGroup*)p = *(struct dss__ApartmentCreateSetFromGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, struct dss__ApartmentCreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroupResponse * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromGroupResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse, sizeof(struct dss__ApartmentCreateSetFromGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse, 0, sizeof(struct dss__ApartmentCreateSetFromGroupResponse), 0, soap_copy_dss__ApartmentCreateSetFromGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse);
	if (soap_out_dss__ApartmentCreateSetFromGroupResponse(soap, tag?tag:"dss:ApartmentCreateSetFromGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroupResponse * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, struct dss__ApartmentCreateSetFromGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__ApartmentCreateSetFromGroupResponse * SOAP_FMAC2 soap_instantiate_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromGroupResponse);
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromGroupResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__ApartmentCreateSetFromGroupResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromGroupResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromGroupResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromGroupResponse*)p = *(struct dss__ApartmentCreateSetFromGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOff(struct soap *soap, struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOff(struct soap *soap, const struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOff(struct soap *soap, const char *tag, int id, const struct dss__SignOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOff), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_in_dss__SignOff(struct soap *soap, const char *tag, struct dss__SignOff *a, const char *type)
{
	size_t soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOff, sizeof(struct dss__SignOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_token, "xsd:string"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOff, 0, sizeof(struct dss__SignOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOff(struct soap *soap, const struct dss__SignOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOff);
	if (soap_out_dss__SignOff(soap, tag?tag:"dss:SignOff", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_get_dss__SignOff(struct soap *soap, struct dss__SignOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SignOff * SOAP_FMAC2 soap_instantiate_dss__SignOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SignOff);
		if (size)
			*size = sizeof(struct dss__SignOff);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SignOff[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOff*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOff %p -> %p\n", q, p));
	*(struct dss__SignOff*)p = *(struct dss__SignOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOffResponse(struct soap *soap, const char *tag, int id, const struct dss__SignOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOffResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_in_dss__SignOffResponse(struct soap *soap, const char *tag, struct dss__SignOffResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOffResponse, sizeof(struct dss__SignOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOffResponse, 0, sizeof(struct dss__SignOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOffResponse);
	if (soap_out_dss__SignOffResponse(soap, tag?tag:"dss:SignOffResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_get_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__SignOffResponse * SOAP_FMAC2 soap_instantiate_dss__SignOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__SignOffResponse);
		if (size)
			*size = sizeof(struct dss__SignOffResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__SignOffResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOffResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOffResponse %p -> %p\n", q, p));
	*(struct dss__SignOffResponse*)p = *(struct dss__SignOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Authenticate(struct soap *soap, struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_userName);
	soap_default_string(soap, &a->_password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_userName);
	soap_serialize_string(soap, &a->_password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Authenticate(struct soap *soap, const char *tag, int id, const struct dss__Authenticate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Authenticate), type))
		return soap->error;
	if (soap_out_string(soap, "userName", -1, &a->_userName, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->_password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_in_dss__Authenticate(struct soap *soap, const char *tag, struct dss__Authenticate *a, const char *type)
{
	size_t soap_flag__userName = 1;
	size_t soap_flag__password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Authenticate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Authenticate, sizeof(struct dss__Authenticate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Authenticate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__userName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_userName, "xsd:string"))
				{	soap_flag__userName--;
					continue;
				}
			if (soap_flag__password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_password, "xsd:string"))
				{	soap_flag__password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Authenticate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Authenticate, 0, sizeof(struct dss__Authenticate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Authenticate);
	if (soap_out_dss__Authenticate(soap, tag?tag:"dss:Authenticate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_get_dss__Authenticate(struct soap *soap, struct dss__Authenticate *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Authenticate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__Authenticate * SOAP_FMAC2 soap_instantiate_dss__Authenticate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Authenticate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Authenticate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__Authenticate);
		if (size)
			*size = sizeof(struct dss__Authenticate);
	}
	else
	{	cp->ptr = (void*)new (struct dss__Authenticate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Authenticate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Authenticate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Authenticate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Authenticate %p -> %p\n", q, p));
	*(struct dss__Authenticate*)p = *(struct dss__Authenticate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->token);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__AuthenticateResponse(struct soap *soap, const char *tag, int id, const struct dss__AuthenticateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__AuthenticateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "token", -1, &a->token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_in_dss__AuthenticateResponse(struct soap *soap, const char *tag, struct dss__AuthenticateResponse *a, const char *type)
{
	size_t soap_flag_token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__AuthenticateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__AuthenticateResponse, sizeof(struct dss__AuthenticateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__AuthenticateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__AuthenticateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__AuthenticateResponse, 0, sizeof(struct dss__AuthenticateResponse), 0, soap_copy_dss__AuthenticateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__AuthenticateResponse);
	if (soap_out_dss__AuthenticateResponse(soap, tag?tag:"dss:AuthenticateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_get_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__AuthenticateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct dss__AuthenticateResponse * SOAP_FMAC2 soap_instantiate_dss__AuthenticateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__AuthenticateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__AuthenticateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (struct dss__AuthenticateResponse);
		if (size)
			*size = sizeof(struct dss__AuthenticateResponse);
	}
	else
	{	cp->ptr = (void*)new (struct dss__AuthenticateResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__AuthenticateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__AuthenticateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__AuthenticateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__AuthenticateResponse %p -> %p\n", q, p));
	*(struct dss__AuthenticateResponse*)p = *(struct dss__AuthenticateResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdss__Event(struct soap *soap, std::vector<dss__Event >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdss__Event(struct soap *soap, const std::vector<dss__Event >*a)
{
	for (std::vector<dss__Event >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdss__Event(struct soap *soap, const char *tag, int id, const std::vector<dss__Event >*a, const char *type)
{
	for (std::vector<dss__Event >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<dss__Event >* SOAP_FMAC4 soap_in_std__vectorTemplateOfdss__Event(struct soap *soap, const char *tag, std::vector<dss__Event >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfdss__Event(soap, -1)))
		return NULL;
	dss__Event n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_dss__Event, SOAP_TYPE_std__vectorTemplateOfdss__Event, sizeof(dss__Event), 0))
				break;
			if (!soap_in_dss__Event(soap, tag, NULL, "dss:Event"))
				break;
		}
		else
		{
			if (!soap_in_dss__Event(soap, tag, &n, "dss:Event"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<dss__Event > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfdss__Event(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfdss__Event(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfdss__Event, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::vector<dss__Event >);
		if (size)
			*size = sizeof(std::vector<dss__Event >);
	}
	else
	{	cp->ptr = (void*)new (std::vector<dss__Event >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<dss__Event >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<dss__Event >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfdss__Event(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<dss__Event > %p -> %p\n", q, p));
	*(std::vector<dss__Event >*)p = *(std::vector<dss__Event >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::vector<int >);
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new (std::vector<int >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new (std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new (std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
