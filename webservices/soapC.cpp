/* soapC.cpp
   Generated by gSOAP 2.7.10 from model_soap.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.10 2009-10-06 15:04:05 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_in_unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_dss__Event:
		return soap_in_dss__Event(soap, NULL, NULL, "dss:Event");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_dss__PropertyGetChildren:
		return soap_in_dss__PropertyGetChildren(soap, NULL, NULL, "dss:PropertyGetChildren");
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		return soap_in_dss__PropertyGetChildrenResponse(soap, NULL, NULL, "dss:PropertyGetChildrenResponse");
	case SOAP_TYPE_dss__PropertyGetBool:
		return soap_in_dss__PropertyGetBool(soap, NULL, NULL, "dss:PropertyGetBool");
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		return soap_in_dss__PropertyGetBoolResponse(soap, NULL, NULL, "dss:PropertyGetBoolResponse");
	case SOAP_TYPE_dss__PropertyGetString:
		return soap_in_dss__PropertyGetString(soap, NULL, NULL, "dss:PropertyGetString");
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		return soap_in_dss__PropertyGetStringResponse(soap, NULL, NULL, "dss:PropertyGetStringResponse");
	case SOAP_TYPE_dss__PropertyGetInt:
		return soap_in_dss__PropertyGetInt(soap, NULL, NULL, "dss:PropertyGetInt");
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		return soap_in_dss__PropertyGetIntResponse(soap, NULL, NULL, "dss:PropertyGetIntResponse");
	case SOAP_TYPE_dss__PropertySetBool:
		return soap_in_dss__PropertySetBool(soap, NULL, NULL, "dss:PropertySetBool");
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		return soap_in_dss__PropertySetBoolResponse(soap, NULL, NULL, "dss:PropertySetBoolResponse");
	case SOAP_TYPE_dss__PropertySetString:
		return soap_in_dss__PropertySetString(soap, NULL, NULL, "dss:PropertySetString");
	case SOAP_TYPE_dss__PropertySetStringResponse:
		return soap_in_dss__PropertySetStringResponse(soap, NULL, NULL, "dss:PropertySetStringResponse");
	case SOAP_TYPE_dss__PropertySetInt:
		return soap_in_dss__PropertySetInt(soap, NULL, NULL, "dss:PropertySetInt");
	case SOAP_TYPE_dss__PropertySetIntResponse:
		return soap_in_dss__PropertySetIntResponse(soap, NULL, NULL, "dss:PropertySetIntResponse");
	case SOAP_TYPE_dss__PropertyGetType:
		return soap_in_dss__PropertyGetType(soap, NULL, NULL, "dss:PropertyGetType");
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		return soap_in_dss__PropertyGetTypeResponse(soap, NULL, NULL, "dss:PropertyGetTypeResponse");
	case SOAP_TYPE_dss__EventSubscribeTo:
		return soap_in_dss__EventSubscribeTo(soap, NULL, NULL, "dss:EventSubscribeTo");
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		return soap_in_dss__EventSubscribeToResponse(soap, NULL, NULL, "dss:EventSubscribeToResponse");
	case SOAP_TYPE_dss__EventWaitFor:
		return soap_in_dss__EventWaitFor(soap, NULL, NULL, "dss:EventWaitFor");
	case SOAP_TYPE_dss__EventWaitForResponse:
		return soap_in_dss__EventWaitForResponse(soap, NULL, NULL, "dss:EventWaitForResponse");
	case SOAP_TYPE_dss__EventRaise:
		return soap_in_dss__EventRaise(soap, NULL, NULL, "dss:EventRaise");
	case SOAP_TYPE_dss__EventRaiseResponse:
		return soap_in_dss__EventRaiseResponse(soap, NULL, NULL, "dss:EventRaiseResponse");
	case SOAP_TYPE_dss__SwitchGetGroupID:
		return soap_in_dss__SwitchGetGroupID(soap, NULL, NULL, "dss:SwitchGetGroupID");
	case SOAP_TYPE_dss__SwitchGetGroupIDResponse:
		return soap_in_dss__SwitchGetGroupIDResponse(soap, NULL, NULL, "dss:SwitchGetGroupIDResponse");
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		return soap_in_dss__DeviceGetFunctionID(soap, NULL, NULL, "dss:DeviceGetFunctionID");
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		return soap_in_dss__DeviceGetFunctionIDResponse(soap, NULL, NULL, "dss:DeviceGetFunctionIDResponse");
	case SOAP_TYPE_dss__GroupRemoveDevice:
		return soap_in_dss__GroupRemoveDevice(soap, NULL, NULL, "dss:GroupRemoveDevice");
	case SOAP_TYPE_dss__GroupRemoveDeviceResponse:
		return soap_in_dss__GroupRemoveDeviceResponse(soap, NULL, NULL, "dss:GroupRemoveDeviceResponse");
	case SOAP_TYPE_dss__GroupAddDevice:
		return soap_in_dss__GroupAddDevice(soap, NULL, NULL, "dss:GroupAddDevice");
	case SOAP_TYPE_dss__GroupAddDeviceResponse:
		return soap_in_dss__GroupAddDeviceResponse(soap, NULL, NULL, "dss:GroupAddDeviceResponse");
	case SOAP_TYPE_dss__GroupRemoveUserGroup:
		return soap_in_dss__GroupRemoveUserGroup(soap, NULL, NULL, "dss:GroupRemoveUserGroup");
	case SOAP_TYPE_dss__GroupRemoveUserGroupResponse:
		return soap_in_dss__GroupRemoveUserGroupResponse(soap, NULL, NULL, "dss:GroupRemoveUserGroupResponse");
	case SOAP_TYPE_dss__ApartmentAllocateUserGroup:
		return soap_in_dss__ApartmentAllocateUserGroup(soap, NULL, NULL, "dss:ApartmentAllocateUserGroup");
	case SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse:
		return soap_in_dss__ApartmentAllocateUserGroupResponse(soap, NULL, NULL, "dss:ApartmentAllocateUserGroupResponse");
	case SOAP_TYPE_dss__Zone_SetName:
		return soap_in_dss__Zone_SetName(soap, NULL, NULL, "dss:Zone-SetName");
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		return soap_in_dss__Zone_SetNameResponse(soap, NULL, NULL, "dss:Zone-SetNameResponse");
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		return soap_in_dss__Zone_RemoveDevice(soap, NULL, NULL, "dss:Zone-RemoveDevice");
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		return soap_in_dss__Zone_RemoveDeviceResponse(soap, NULL, NULL, "dss:Zone-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Zone_AddDevice:
		return soap_in_dss__Zone_AddDevice(soap, NULL, NULL, "dss:Zone-AddDevice");
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		return soap_in_dss__Zone_AddDeviceResponse(soap, NULL, NULL, "dss:Zone-AddDeviceResponse");
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		return soap_in_dss__ApartmentDeleteZone(soap, NULL, NULL, "dss:ApartmentDeleteZone");
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		return soap_in_dss__ApartmentDeleteZoneResponse(soap, NULL, NULL, "dss:ApartmentDeleteZoneResponse");
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		return soap_in_dss__ApartmentAllocateZone(soap, NULL, NULL, "dss:ApartmentAllocateZone");
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		return soap_in_dss__ApartmentAllocateZoneResponse(soap, NULL, NULL, "dss:ApartmentAllocateZoneResponse");
	case SOAP_TYPE_dss__ModulatorGetName:
		return soap_in_dss__ModulatorGetName(soap, NULL, NULL, "dss:ModulatorGetName");
	case SOAP_TYPE_dss__ModulatorGetNameResponse:
		return soap_in_dss__ModulatorGetNameResponse(soap, NULL, NULL, "dss:ModulatorGetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetModulatorIDs:
		return soap_in_dss__ApartmentGetModulatorIDs(soap, NULL, NULL, "dss:ApartmentGetModulatorIDs");
	case SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse:
		return soap_in_dss__ApartmentGetModulatorIDsResponse(soap, NULL, NULL, "dss:ApartmentGetModulatorIDsResponse");
	case SOAP_TYPE_dss__ModulatorGetPowerConsumption:
		return soap_in_dss__ModulatorGetPowerConsumption(soap, NULL, NULL, "dss:ModulatorGetPowerConsumption");
	case SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse:
		return soap_in_dss__ModulatorGetPowerConsumptionResponse(soap, NULL, NULL, "dss:ModulatorGetPowerConsumptionResponse");
	case SOAP_TYPE_dss__DeviceGetZoneID:
		return soap_in_dss__DeviceGetZoneID(soap, NULL, NULL, "dss:DeviceGetZoneID");
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		return soap_in_dss__DeviceGetZoneIDResponse(soap, NULL, NULL, "dss:DeviceGetZoneIDResponse");
	case SOAP_TYPE_dss__DeviceGetName:
		return soap_in_dss__DeviceGetName(soap, NULL, NULL, "dss:DeviceGetName");
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		return soap_in_dss__DeviceGetNameResponse(soap, NULL, NULL, "dss:DeviceGetNameResponse");
	case SOAP_TYPE_dss__DeviceSaveScene:
		return soap_in_dss__DeviceSaveScene(soap, NULL, NULL, "dss:DeviceSaveScene");
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		return soap_in_dss__DeviceSaveSceneResponse(soap, NULL, NULL, "dss:DeviceSaveSceneResponse");
	case SOAP_TYPE_dss__DeviceCallScene:
		return soap_in_dss__DeviceCallScene(soap, NULL, NULL, "dss:DeviceCallScene");
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		return soap_in_dss__DeviceCallSceneResponse(soap, NULL, NULL, "dss:DeviceCallSceneResponse");
	case SOAP_TYPE_dss__DeviceGetValue:
		return soap_in_dss__DeviceGetValue(soap, NULL, NULL, "dss:DeviceGetValue");
	case SOAP_TYPE_dss__DeviceGetValueResponse:
		return soap_in_dss__DeviceGetValueResponse(soap, NULL, NULL, "dss:DeviceGetValueResponse");
	case SOAP_TYPE_dss__DeviceSetValue:
		return soap_in_dss__DeviceSetValue(soap, NULL, NULL, "dss:DeviceSetValue");
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		return soap_in_dss__DeviceSetValueResponse(soap, NULL, NULL, "dss:DeviceSetValueResponse");
	case SOAP_TYPE_dss__DeviceEndDim:
		return soap_in_dss__DeviceEndDim(soap, NULL, NULL, "dss:DeviceEndDim");
	case SOAP_TYPE_dss__DeviceEndDimResponse:
		return soap_in_dss__DeviceEndDimResponse(soap, NULL, NULL, "dss:DeviceEndDimResponse");
	case SOAP_TYPE_dss__DeviceStartDim:
		return soap_in_dss__DeviceStartDim(soap, NULL, NULL, "dss:DeviceStartDim");
	case SOAP_TYPE_dss__DeviceStartDimResponse:
		return soap_in_dss__DeviceStartDimResponse(soap, NULL, NULL, "dss:DeviceStartDimResponse");
	case SOAP_TYPE_dss__DeviceDisable:
		return soap_in_dss__DeviceDisable(soap, NULL, NULL, "dss:DeviceDisable");
	case SOAP_TYPE_dss__DeviceDisableResponse:
		return soap_in_dss__DeviceDisableResponse(soap, NULL, NULL, "dss:DeviceDisableResponse");
	case SOAP_TYPE_dss__DeviceEnable:
		return soap_in_dss__DeviceEnable(soap, NULL, NULL, "dss:DeviceEnable");
	case SOAP_TYPE_dss__DeviceEnableResponse:
		return soap_in_dss__DeviceEnableResponse(soap, NULL, NULL, "dss:DeviceEnableResponse");
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		return soap_in_dss__DeviceDecreaseValue(soap, NULL, NULL, "dss:DeviceDecreaseValue");
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		return soap_in_dss__DeviceDecreaseValueResponse(soap, NULL, NULL, "dss:DeviceDecreaseValueResponse");
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		return soap_in_dss__DeviceIncreaseValue(soap, NULL, NULL, "dss:DeviceIncreaseValue");
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		return soap_in_dss__DeviceIncreaseValueResponse(soap, NULL, NULL, "dss:DeviceIncreaseValueResponse");
	case SOAP_TYPE_dss__DeviceTurnOff:
		return soap_in_dss__DeviceTurnOff(soap, NULL, NULL, "dss:DeviceTurnOff");
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		return soap_in_dss__DeviceTurnOffResponse(soap, NULL, NULL, "dss:DeviceTurnOffResponse");
	case SOAP_TYPE_dss__DeviceTurnOn:
		return soap_in_dss__DeviceTurnOn(soap, NULL, NULL, "dss:DeviceTurnOn");
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		return soap_in_dss__DeviceTurnOnResponse(soap, NULL, NULL, "dss:DeviceTurnOnResponse");
	case SOAP_TYPE_dss__ZoneSaveScene:
		return soap_in_dss__ZoneSaveScene(soap, NULL, NULL, "dss:ZoneSaveScene");
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		return soap_in_dss__ZoneSaveSceneResponse(soap, NULL, NULL, "dss:ZoneSaveSceneResponse");
	case SOAP_TYPE_dss__ZoneCallScene:
		return soap_in_dss__ZoneCallScene(soap, NULL, NULL, "dss:ZoneCallScene");
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		return soap_in_dss__ZoneCallSceneResponse(soap, NULL, NULL, "dss:ZoneCallSceneResponse");
	case SOAP_TYPE_dss__ZoneSetValue:
		return soap_in_dss__ZoneSetValue(soap, NULL, NULL, "dss:ZoneSetValue");
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		return soap_in_dss__ZoneSetValueResponse(soap, NULL, NULL, "dss:ZoneSetValueResponse");
	case SOAP_TYPE_dss__ZoneEndDim:
		return soap_in_dss__ZoneEndDim(soap, NULL, NULL, "dss:ZoneEndDim");
	case SOAP_TYPE_dss__ZoneEndDimResponse:
		return soap_in_dss__ZoneEndDimResponse(soap, NULL, NULL, "dss:ZoneEndDimResponse");
	case SOAP_TYPE_dss__ZoneStartDim:
		return soap_in_dss__ZoneStartDim(soap, NULL, NULL, "dss:ZoneStartDim");
	case SOAP_TYPE_dss__ZoneStartDimResponse:
		return soap_in_dss__ZoneStartDimResponse(soap, NULL, NULL, "dss:ZoneStartDimResponse");
	case SOAP_TYPE_dss__ZoneDisable:
		return soap_in_dss__ZoneDisable(soap, NULL, NULL, "dss:ZoneDisable");
	case SOAP_TYPE_dss__ZoneDisableResponse:
		return soap_in_dss__ZoneDisableResponse(soap, NULL, NULL, "dss:ZoneDisableResponse");
	case SOAP_TYPE_dss__ZoneEnable:
		return soap_in_dss__ZoneEnable(soap, NULL, NULL, "dss:ZoneEnable");
	case SOAP_TYPE_dss__ZoneEnableResponse:
		return soap_in_dss__ZoneEnableResponse(soap, NULL, NULL, "dss:ZoneEnableResponse");
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		return soap_in_dss__ZoneDecreaseValue(soap, NULL, NULL, "dss:ZoneDecreaseValue");
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		return soap_in_dss__ZoneDecreaseValueResponse(soap, NULL, NULL, "dss:ZoneDecreaseValueResponse");
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		return soap_in_dss__ZoneIncreaseValue(soap, NULL, NULL, "dss:ZoneIncreaseValue");
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		return soap_in_dss__ZoneIncreaseValueResponse(soap, NULL, NULL, "dss:ZoneIncreaseValueResponse");
	case SOAP_TYPE_dss__ZoneTurnOff:
		return soap_in_dss__ZoneTurnOff(soap, NULL, NULL, "dss:ZoneTurnOff");
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		return soap_in_dss__ZoneTurnOffResponse(soap, NULL, NULL, "dss:ZoneTurnOffResponse");
	case SOAP_TYPE_dss__ZoneTurnOn:
		return soap_in_dss__ZoneTurnOn(soap, NULL, NULL, "dss:ZoneTurnOn");
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		return soap_in_dss__ZoneTurnOnResponse(soap, NULL, NULL, "dss:ZoneTurnOnResponse");
	case SOAP_TYPE_dss__CircuitRescan:
		return soap_in_dss__CircuitRescan(soap, NULL, NULL, "dss:CircuitRescan");
	case SOAP_TYPE_dss__CircuitRescanResponse:
		return soap_in_dss__CircuitRescanResponse(soap, NULL, NULL, "dss:CircuitRescanResponse");
	case SOAP_TYPE_dss__ApartmentRescan:
		return soap_in_dss__ApartmentRescan(soap, NULL, NULL, "dss:ApartmentRescan");
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		return soap_in_dss__ApartmentRescanResponse(soap, NULL, NULL, "dss:ApartmentRescanResponse");
	case SOAP_TYPE_dss__ApartmentSaveScene:
		return soap_in_dss__ApartmentSaveScene(soap, NULL, NULL, "dss:ApartmentSaveScene");
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		return soap_in_dss__ApartmentSaveSceneResponse(soap, NULL, NULL, "dss:ApartmentSaveSceneResponse");
	case SOAP_TYPE_dss__ApartmentCallScene:
		return soap_in_dss__ApartmentCallScene(soap, NULL, NULL, "dss:ApartmentCallScene");
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		return soap_in_dss__ApartmentCallSceneResponse(soap, NULL, NULL, "dss:ApartmentCallSceneResponse");
	case SOAP_TYPE_dss__ApartmentSetValue:
		return soap_in_dss__ApartmentSetValue(soap, NULL, NULL, "dss:ApartmentSetValue");
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		return soap_in_dss__ApartmentSetValueResponse(soap, NULL, NULL, "dss:ApartmentSetValueResponse");
	case SOAP_TYPE_dss__ApartmentEndDim:
		return soap_in_dss__ApartmentEndDim(soap, NULL, NULL, "dss:ApartmentEndDim");
	case SOAP_TYPE_dss__ApartmentEndDimResponse:
		return soap_in_dss__ApartmentEndDimResponse(soap, NULL, NULL, "dss:ApartmentEndDimResponse");
	case SOAP_TYPE_dss__ApartmentStartDim:
		return soap_in_dss__ApartmentStartDim(soap, NULL, NULL, "dss:ApartmentStartDim");
	case SOAP_TYPE_dss__ApartmentStartDimResponse:
		return soap_in_dss__ApartmentStartDimResponse(soap, NULL, NULL, "dss:ApartmentStartDimResponse");
	case SOAP_TYPE_dss__ApartmentDisable:
		return soap_in_dss__ApartmentDisable(soap, NULL, NULL, "dss:ApartmentDisable");
	case SOAP_TYPE_dss__ApartmentDisableResponse:
		return soap_in_dss__ApartmentDisableResponse(soap, NULL, NULL, "dss:ApartmentDisableResponse");
	case SOAP_TYPE_dss__ApartmentEnable:
		return soap_in_dss__ApartmentEnable(soap, NULL, NULL, "dss:ApartmentEnable");
	case SOAP_TYPE_dss__ApartmentEnableResponse:
		return soap_in_dss__ApartmentEnableResponse(soap, NULL, NULL, "dss:ApartmentEnableResponse");
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		return soap_in_dss__ApartmentDecreaseValue(soap, NULL, NULL, "dss:ApartmentDecreaseValue");
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		return soap_in_dss__ApartmentDecreaseValueResponse(soap, NULL, NULL, "dss:ApartmentDecreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		return soap_in_dss__ApartmentIncreaseValue(soap, NULL, NULL, "dss:ApartmentIncreaseValue");
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		return soap_in_dss__ApartmentIncreaseValueResponse(soap, NULL, NULL, "dss:ApartmentIncreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentTurnOff:
		return soap_in_dss__ApartmentTurnOff(soap, NULL, NULL, "dss:ApartmentTurnOff");
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		return soap_in_dss__ApartmentTurnOffResponse(soap, NULL, NULL, "dss:ApartmentTurnOffResponse");
	case SOAP_TYPE_dss__ApartmentTurnOn:
		return soap_in_dss__ApartmentTurnOn(soap, NULL, NULL, "dss:ApartmentTurnOn");
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		return soap_in_dss__ApartmentTurnOnResponse(soap, NULL, NULL, "dss:ApartmentTurnOnResponse");
	case SOAP_TYPE_dss__SetSaveScene:
		return soap_in_dss__SetSaveScene(soap, NULL, NULL, "dss:SetSaveScene");
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		return soap_in_dss__SetSaveSceneResponse(soap, NULL, NULL, "dss:SetSaveSceneResponse");
	case SOAP_TYPE_dss__SetCallScene:
		return soap_in_dss__SetCallScene(soap, NULL, NULL, "dss:SetCallScene");
	case SOAP_TYPE_dss__SetCallSceneResponse:
		return soap_in_dss__SetCallSceneResponse(soap, NULL, NULL, "dss:SetCallSceneResponse");
	case SOAP_TYPE_dss__SetSetValue:
		return soap_in_dss__SetSetValue(soap, NULL, NULL, "dss:SetSetValue");
	case SOAP_TYPE_dss__SetSetValueResponse:
		return soap_in_dss__SetSetValueResponse(soap, NULL, NULL, "dss:SetSetValueResponse");
	case SOAP_TYPE_dss__SetEndDim:
		return soap_in_dss__SetEndDim(soap, NULL, NULL, "dss:SetEndDim");
	case SOAP_TYPE_dss__SetEndDimResponse:
		return soap_in_dss__SetEndDimResponse(soap, NULL, NULL, "dss:SetEndDimResponse");
	case SOAP_TYPE_dss__SetStartDim:
		return soap_in_dss__SetStartDim(soap, NULL, NULL, "dss:SetStartDim");
	case SOAP_TYPE_dss__SetStartDimResponse:
		return soap_in_dss__SetStartDimResponse(soap, NULL, NULL, "dss:SetStartDimResponse");
	case SOAP_TYPE_dss__SetDisable:
		return soap_in_dss__SetDisable(soap, NULL, NULL, "dss:SetDisable");
	case SOAP_TYPE_dss__SetDisableResponse:
		return soap_in_dss__SetDisableResponse(soap, NULL, NULL, "dss:SetDisableResponse");
	case SOAP_TYPE_dss__SetEnable:
		return soap_in_dss__SetEnable(soap, NULL, NULL, "dss:SetEnable");
	case SOAP_TYPE_dss__SetEnableResponse:
		return soap_in_dss__SetEnableResponse(soap, NULL, NULL, "dss:SetEnableResponse");
	case SOAP_TYPE_dss__SetDecreaseValue:
		return soap_in_dss__SetDecreaseValue(soap, NULL, NULL, "dss:SetDecreaseValue");
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		return soap_in_dss__SetDecreaseValueResponse(soap, NULL, NULL, "dss:SetDecreaseValueResponse");
	case SOAP_TYPE_dss__SetIncreaseValue:
		return soap_in_dss__SetIncreaseValue(soap, NULL, NULL, "dss:SetIncreaseValue");
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		return soap_in_dss__SetIncreaseValueResponse(soap, NULL, NULL, "dss:SetIncreaseValueResponse");
	case SOAP_TYPE_dss__SetTurnOff:
		return soap_in_dss__SetTurnOff(soap, NULL, NULL, "dss:SetTurnOff");
	case SOAP_TYPE_dss__SetTurnOffResponse:
		return soap_in_dss__SetTurnOffResponse(soap, NULL, NULL, "dss:SetTurnOffResponse");
	case SOAP_TYPE_dss__SetTurnOn:
		return soap_in_dss__SetTurnOn(soap, NULL, NULL, "dss:SetTurnOn");
	case SOAP_TYPE_dss__SetTurnOnResponse:
		return soap_in_dss__SetTurnOnResponse(soap, NULL, NULL, "dss:SetTurnOnResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		return soap_in_dss__ApartmentGetZoneIDs(soap, NULL, NULL, "dss:ApartmentGetZoneIDs");
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		return soap_in_dss__ApartmentGetZoneIDsResponse(soap, NULL, NULL, "dss:ApartmentGetZoneIDsResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		return soap_in_dss__ApartmentGetZoneByName(soap, NULL, NULL, "dss:ApartmentGetZoneByName");
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		return soap_in_dss__ApartmentGetZoneByNameResponse(soap, NULL, NULL, "dss:ApartmentGetZoneByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		return soap_in_dss__ApartmentGetGroupByName(soap, NULL, NULL, "dss:ApartmentGetGroupByName");
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		return soap_in_dss__ApartmentGetGroupByNameResponse(soap, NULL, NULL, "dss:ApartmentGetGroupByNameResponse");
	case SOAP_TYPE_dss__SetGetContainedDevices:
		return soap_in_dss__SetGetContainedDevices(soap, NULL, NULL, "dss:SetGetContainedDevices");
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		return soap_in_dss__SetGetContainedDevicesResponse(soap, NULL, NULL, "dss:SetGetContainedDevicesResponse");
	case SOAP_TYPE_dss__SetByGroup:
		return soap_in_dss__SetByGroup(soap, NULL, NULL, "dss:SetByGroup");
	case SOAP_TYPE_dss__SetByGroupResponse:
		return soap_in_dss__SetByGroupResponse(soap, NULL, NULL, "dss:SetByGroupResponse");
	case SOAP_TYPE_dss__SetRemove:
		return soap_in_dss__SetRemove(soap, NULL, NULL, "dss:SetRemove");
	case SOAP_TYPE_dss__SetRemoveResponse:
		return soap_in_dss__SetRemoveResponse(soap, NULL, NULL, "dss:SetRemoveResponse");
	case SOAP_TYPE_dss__SetCombine:
		return soap_in_dss__SetCombine(soap, NULL, NULL, "dss:SetCombine");
	case SOAP_TYPE_dss__SetCombineResponse:
		return soap_in_dss__SetCombineResponse(soap, NULL, NULL, "dss:SetCombineResponse");
	case SOAP_TYPE_dss__SetRemoveDevice:
		return soap_in_dss__SetRemoveDevice(soap, NULL, NULL, "dss:SetRemoveDevice");
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		return soap_in_dss__SetRemoveDeviceResponse(soap, NULL, NULL, "dss:SetRemoveDeviceResponse");
	case SOAP_TYPE_dss__SetAddDeviceByID:
		return soap_in_dss__SetAddDeviceByID(soap, NULL, NULL, "dss:SetAddDeviceByID");
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		return soap_in_dss__SetAddDeviceByIDResponse(soap, NULL, NULL, "dss:SetAddDeviceByIDResponse");
	case SOAP_TYPE_dss__SetAddDeviceByName:
		return soap_in_dss__SetAddDeviceByName(soap, NULL, NULL, "dss:SetAddDeviceByName");
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		return soap_in_dss__SetAddDeviceByNameResponse(soap, NULL, NULL, "dss:SetAddDeviceByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		return soap_in_dss__ApartmentGetDeviceIDByName(soap, NULL, NULL, "dss:ApartmentGetDeviceIDByName");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		return soap_in_dss__ApartmentGetDeviceIDByNameResponse(soap, NULL, NULL, "dss:ApartmentGetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDevices:
		return soap_in_dss__ApartmentGetDevices(soap, NULL, NULL, "dss:ApartmentGetDevices");
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		return soap_in_dss__ApartmentGetDevicesResponse(soap, NULL, NULL, "dss:ApartmentGetDevicesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		return soap_in_dss__ApartmentCreateSetFromDeviceNames(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceNames");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		return soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		return soap_in_dss__ApartmentCreateSetFromDeviceIDs(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		return soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, NULL, NULL, "dss:ApartmentCreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		return soap_in_dss__ApartmentCreateSetFromGroup(soap, NULL, NULL, "dss:ApartmentCreateSetFromGroup");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		return soap_in_dss__ApartmentCreateSetFromGroupResponse(soap, NULL, NULL, "dss:ApartmentCreateSetFromGroupResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_in_dss__SignOff(soap, NULL, NULL, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_in_dss__SignOffResponse(soap, NULL, NULL, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_in_dss__Authenticate(soap, NULL, NULL, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, "dss:AuthenticateResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "dss:Event"))
		{	*type = SOAP_TYPE_dss__Event;
			return soap_in_dss__Event(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLong;
			return soap_in_unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetChildren"))
		{	*type = SOAP_TYPE_dss__PropertyGetChildren;
			return soap_in_dss__PropertyGetChildren(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetChildrenResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetChildrenResponse;
			return soap_in_dss__PropertyGetChildrenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetBool"))
		{	*type = SOAP_TYPE_dss__PropertyGetBool;
			return soap_in_dss__PropertyGetBool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetBoolResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetBoolResponse;
			return soap_in_dss__PropertyGetBoolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetString"))
		{	*type = SOAP_TYPE_dss__PropertyGetString;
			return soap_in_dss__PropertyGetString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetStringResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetStringResponse;
			return soap_in_dss__PropertyGetStringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetInt"))
		{	*type = SOAP_TYPE_dss__PropertyGetInt;
			return soap_in_dss__PropertyGetInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetIntResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetIntResponse;
			return soap_in_dss__PropertyGetIntResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetBool"))
		{	*type = SOAP_TYPE_dss__PropertySetBool;
			return soap_in_dss__PropertySetBool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetBoolResponse"))
		{	*type = SOAP_TYPE_dss__PropertySetBoolResponse;
			return soap_in_dss__PropertySetBoolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetString"))
		{	*type = SOAP_TYPE_dss__PropertySetString;
			return soap_in_dss__PropertySetString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetStringResponse"))
		{	*type = SOAP_TYPE_dss__PropertySetStringResponse;
			return soap_in_dss__PropertySetStringResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetInt"))
		{	*type = SOAP_TYPE_dss__PropertySetInt;
			return soap_in_dss__PropertySetInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertySetIntResponse"))
		{	*type = SOAP_TYPE_dss__PropertySetIntResponse;
			return soap_in_dss__PropertySetIntResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetType"))
		{	*type = SOAP_TYPE_dss__PropertyGetType;
			return soap_in_dss__PropertyGetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:PropertyGetTypeResponse"))
		{	*type = SOAP_TYPE_dss__PropertyGetTypeResponse;
			return soap_in_dss__PropertyGetTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventSubscribeTo"))
		{	*type = SOAP_TYPE_dss__EventSubscribeTo;
			return soap_in_dss__EventSubscribeTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventSubscribeToResponse"))
		{	*type = SOAP_TYPE_dss__EventSubscribeToResponse;
			return soap_in_dss__EventSubscribeToResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventWaitFor"))
		{	*type = SOAP_TYPE_dss__EventWaitFor;
			return soap_in_dss__EventWaitFor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventWaitForResponse"))
		{	*type = SOAP_TYPE_dss__EventWaitForResponse;
			return soap_in_dss__EventWaitForResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventRaise"))
		{	*type = SOAP_TYPE_dss__EventRaise;
			return soap_in_dss__EventRaise(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:EventRaiseResponse"))
		{	*type = SOAP_TYPE_dss__EventRaiseResponse;
			return soap_in_dss__EventRaiseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SwitchGetGroupID"))
		{	*type = SOAP_TYPE_dss__SwitchGetGroupID;
			return soap_in_dss__SwitchGetGroupID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SwitchGetGroupIDResponse"))
		{	*type = SOAP_TYPE_dss__SwitchGetGroupIDResponse;
			return soap_in_dss__SwitchGetGroupIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetFunctionID"))
		{	*type = SOAP_TYPE_dss__DeviceGetFunctionID;
			return soap_in_dss__DeviceGetFunctionID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetFunctionIDResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetFunctionIDResponse;
			return soap_in_dss__DeviceGetFunctionIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupRemoveDevice"))
		{	*type = SOAP_TYPE_dss__GroupRemoveDevice;
			return soap_in_dss__GroupRemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupRemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__GroupRemoveDeviceResponse;
			return soap_in_dss__GroupRemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupAddDevice"))
		{	*type = SOAP_TYPE_dss__GroupAddDevice;
			return soap_in_dss__GroupAddDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupAddDeviceResponse"))
		{	*type = SOAP_TYPE_dss__GroupAddDeviceResponse;
			return soap_in_dss__GroupAddDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupRemoveUserGroup"))
		{	*type = SOAP_TYPE_dss__GroupRemoveUserGroup;
			return soap_in_dss__GroupRemoveUserGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:GroupRemoveUserGroupResponse"))
		{	*type = SOAP_TYPE_dss__GroupRemoveUserGroupResponse;
			return soap_in_dss__GroupRemoveUserGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentAllocateUserGroup"))
		{	*type = SOAP_TYPE_dss__ApartmentAllocateUserGroup;
			return soap_in_dss__ApartmentAllocateUserGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentAllocateUserGroupResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse;
			return soap_in_dss__ApartmentAllocateUserGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-SetName"))
		{	*type = SOAP_TYPE_dss__Zone_SetName;
			return soap_in_dss__Zone_SetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-SetNameResponse"))
		{	*type = SOAP_TYPE_dss__Zone_SetNameResponse;
			return soap_in_dss__Zone_SetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-RemoveDevice"))
		{	*type = SOAP_TYPE_dss__Zone_RemoveDevice;
			return soap_in_dss__Zone_RemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-RemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Zone_RemoveDeviceResponse;
			return soap_in_dss__Zone_RemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-AddDevice"))
		{	*type = SOAP_TYPE_dss__Zone_AddDevice;
			return soap_in_dss__Zone_AddDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Zone-AddDeviceResponse"))
		{	*type = SOAP_TYPE_dss__Zone_AddDeviceResponse;
			return soap_in_dss__Zone_AddDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDeleteZone"))
		{	*type = SOAP_TYPE_dss__ApartmentDeleteZone;
			return soap_in_dss__ApartmentDeleteZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDeleteZoneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentDeleteZoneResponse;
			return soap_in_dss__ApartmentDeleteZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentAllocateZone"))
		{	*type = SOAP_TYPE_dss__ApartmentAllocateZone;
			return soap_in_dss__ApartmentAllocateZone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentAllocateZoneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentAllocateZoneResponse;
			return soap_in_dss__ApartmentAllocateZoneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ModulatorGetName"))
		{	*type = SOAP_TYPE_dss__ModulatorGetName;
			return soap_in_dss__ModulatorGetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ModulatorGetNameResponse"))
		{	*type = SOAP_TYPE_dss__ModulatorGetNameResponse;
			return soap_in_dss__ModulatorGetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetModulatorIDs"))
		{	*type = SOAP_TYPE_dss__ApartmentGetModulatorIDs;
			return soap_in_dss__ApartmentGetModulatorIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetModulatorIDsResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse;
			return soap_in_dss__ApartmentGetModulatorIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ModulatorGetPowerConsumption"))
		{	*type = SOAP_TYPE_dss__ModulatorGetPowerConsumption;
			return soap_in_dss__ModulatorGetPowerConsumption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ModulatorGetPowerConsumptionResponse"))
		{	*type = SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse;
			return soap_in_dss__ModulatorGetPowerConsumptionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetZoneID"))
		{	*type = SOAP_TYPE_dss__DeviceGetZoneID;
			return soap_in_dss__DeviceGetZoneID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetZoneIDResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetZoneIDResponse;
			return soap_in_dss__DeviceGetZoneIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetName"))
		{	*type = SOAP_TYPE_dss__DeviceGetName;
			return soap_in_dss__DeviceGetName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetNameResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetNameResponse;
			return soap_in_dss__DeviceGetNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSaveScene"))
		{	*type = SOAP_TYPE_dss__DeviceSaveScene;
			return soap_in_dss__DeviceSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__DeviceSaveSceneResponse;
			return soap_in_dss__DeviceSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceCallScene"))
		{	*type = SOAP_TYPE_dss__DeviceCallScene;
			return soap_in_dss__DeviceCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__DeviceCallSceneResponse;
			return soap_in_dss__DeviceCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetValue"))
		{	*type = SOAP_TYPE_dss__DeviceGetValue;
			return soap_in_dss__DeviceGetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceGetValueResponse"))
		{	*type = SOAP_TYPE_dss__DeviceGetValueResponse;
			return soap_in_dss__DeviceGetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetValue"))
		{	*type = SOAP_TYPE_dss__DeviceSetValue;
			return soap_in_dss__DeviceSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceSetValueResponse"))
		{	*type = SOAP_TYPE_dss__DeviceSetValueResponse;
			return soap_in_dss__DeviceSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceEndDim"))
		{	*type = SOAP_TYPE_dss__DeviceEndDim;
			return soap_in_dss__DeviceEndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceEndDimResponse"))
		{	*type = SOAP_TYPE_dss__DeviceEndDimResponse;
			return soap_in_dss__DeviceEndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceStartDim"))
		{	*type = SOAP_TYPE_dss__DeviceStartDim;
			return soap_in_dss__DeviceStartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceStartDimResponse"))
		{	*type = SOAP_TYPE_dss__DeviceStartDimResponse;
			return soap_in_dss__DeviceStartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceDisable"))
		{	*type = SOAP_TYPE_dss__DeviceDisable;
			return soap_in_dss__DeviceDisable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceDisableResponse"))
		{	*type = SOAP_TYPE_dss__DeviceDisableResponse;
			return soap_in_dss__DeviceDisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceEnable"))
		{	*type = SOAP_TYPE_dss__DeviceEnable;
			return soap_in_dss__DeviceEnable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceEnableResponse"))
		{	*type = SOAP_TYPE_dss__DeviceEnableResponse;
			return soap_in_dss__DeviceEnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceDecreaseValue"))
		{	*type = SOAP_TYPE_dss__DeviceDecreaseValue;
			return soap_in_dss__DeviceDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__DeviceDecreaseValueResponse;
			return soap_in_dss__DeviceDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceIncreaseValue"))
		{	*type = SOAP_TYPE_dss__DeviceIncreaseValue;
			return soap_in_dss__DeviceIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__DeviceIncreaseValueResponse;
			return soap_in_dss__DeviceIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOff"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOff;
			return soap_in_dss__DeviceTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOffResponse;
			return soap_in_dss__DeviceTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOn"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOn;
			return soap_in_dss__DeviceTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:DeviceTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__DeviceTurnOnResponse;
			return soap_in_dss__DeviceTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSaveScene"))
		{	*type = SOAP_TYPE_dss__ZoneSaveScene;
			return soap_in_dss__ZoneSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__ZoneSaveSceneResponse;
			return soap_in_dss__ZoneSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneCallScene"))
		{	*type = SOAP_TYPE_dss__ZoneCallScene;
			return soap_in_dss__ZoneCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__ZoneCallSceneResponse;
			return soap_in_dss__ZoneCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSetValue"))
		{	*type = SOAP_TYPE_dss__ZoneSetValue;
			return soap_in_dss__ZoneSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneSetValueResponse"))
		{	*type = SOAP_TYPE_dss__ZoneSetValueResponse;
			return soap_in_dss__ZoneSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneEndDim"))
		{	*type = SOAP_TYPE_dss__ZoneEndDim;
			return soap_in_dss__ZoneEndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneEndDimResponse"))
		{	*type = SOAP_TYPE_dss__ZoneEndDimResponse;
			return soap_in_dss__ZoneEndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneStartDim"))
		{	*type = SOAP_TYPE_dss__ZoneStartDim;
			return soap_in_dss__ZoneStartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneStartDimResponse"))
		{	*type = SOAP_TYPE_dss__ZoneStartDimResponse;
			return soap_in_dss__ZoneStartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneDisable"))
		{	*type = SOAP_TYPE_dss__ZoneDisable;
			return soap_in_dss__ZoneDisable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneDisableResponse"))
		{	*type = SOAP_TYPE_dss__ZoneDisableResponse;
			return soap_in_dss__ZoneDisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneEnable"))
		{	*type = SOAP_TYPE_dss__ZoneEnable;
			return soap_in_dss__ZoneEnable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneEnableResponse"))
		{	*type = SOAP_TYPE_dss__ZoneEnableResponse;
			return soap_in_dss__ZoneEnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneDecreaseValue"))
		{	*type = SOAP_TYPE_dss__ZoneDecreaseValue;
			return soap_in_dss__ZoneDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ZoneDecreaseValueResponse;
			return soap_in_dss__ZoneDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneIncreaseValue"))
		{	*type = SOAP_TYPE_dss__ZoneIncreaseValue;
			return soap_in_dss__ZoneIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ZoneIncreaseValueResponse;
			return soap_in_dss__ZoneIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOff"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOff;
			return soap_in_dss__ZoneTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOffResponse;
			return soap_in_dss__ZoneTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOn"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOn;
			return soap_in_dss__ZoneTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ZoneTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__ZoneTurnOnResponse;
			return soap_in_dss__ZoneTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:CircuitRescan"))
		{	*type = SOAP_TYPE_dss__CircuitRescan;
			return soap_in_dss__CircuitRescan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:CircuitRescanResponse"))
		{	*type = SOAP_TYPE_dss__CircuitRescanResponse;
			return soap_in_dss__CircuitRescanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentRescan"))
		{	*type = SOAP_TYPE_dss__ApartmentRescan;
			return soap_in_dss__ApartmentRescan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentRescanResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentRescanResponse;
			return soap_in_dss__ApartmentRescanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSaveScene"))
		{	*type = SOAP_TYPE_dss__ApartmentSaveScene;
			return soap_in_dss__ApartmentSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentSaveSceneResponse;
			return soap_in_dss__ApartmentSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCallScene"))
		{	*type = SOAP_TYPE_dss__ApartmentCallScene;
			return soap_in_dss__ApartmentCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCallSceneResponse;
			return soap_in_dss__ApartmentCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSetValue"))
		{	*type = SOAP_TYPE_dss__ApartmentSetValue;
			return soap_in_dss__ApartmentSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentSetValueResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentSetValueResponse;
			return soap_in_dss__ApartmentSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentEndDim"))
		{	*type = SOAP_TYPE_dss__ApartmentEndDim;
			return soap_in_dss__ApartmentEndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentEndDimResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentEndDimResponse;
			return soap_in_dss__ApartmentEndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentStartDim"))
		{	*type = SOAP_TYPE_dss__ApartmentStartDim;
			return soap_in_dss__ApartmentStartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentStartDimResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentStartDimResponse;
			return soap_in_dss__ApartmentStartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDisable"))
		{	*type = SOAP_TYPE_dss__ApartmentDisable;
			return soap_in_dss__ApartmentDisable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDisableResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentDisableResponse;
			return soap_in_dss__ApartmentDisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentEnable"))
		{	*type = SOAP_TYPE_dss__ApartmentEnable;
			return soap_in_dss__ApartmentEnable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentEnableResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentEnableResponse;
			return soap_in_dss__ApartmentEnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDecreaseValue"))
		{	*type = SOAP_TYPE_dss__ApartmentDecreaseValue;
			return soap_in_dss__ApartmentDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentDecreaseValueResponse;
			return soap_in_dss__ApartmentDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentIncreaseValue"))
		{	*type = SOAP_TYPE_dss__ApartmentIncreaseValue;
			return soap_in_dss__ApartmentIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentIncreaseValueResponse;
			return soap_in_dss__ApartmentIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOff"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOff;
			return soap_in_dss__ApartmentTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOffResponse;
			return soap_in_dss__ApartmentTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOn"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOn;
			return soap_in_dss__ApartmentTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentTurnOnResponse;
			return soap_in_dss__ApartmentTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSaveScene"))
		{	*type = SOAP_TYPE_dss__SetSaveScene;
			return soap_in_dss__SetSaveScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSaveSceneResponse"))
		{	*type = SOAP_TYPE_dss__SetSaveSceneResponse;
			return soap_in_dss__SetSaveSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCallScene"))
		{	*type = SOAP_TYPE_dss__SetCallScene;
			return soap_in_dss__SetCallScene(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCallSceneResponse"))
		{	*type = SOAP_TYPE_dss__SetCallSceneResponse;
			return soap_in_dss__SetCallSceneResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSetValue"))
		{	*type = SOAP_TYPE_dss__SetSetValue;
			return soap_in_dss__SetSetValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetSetValueResponse"))
		{	*type = SOAP_TYPE_dss__SetSetValueResponse;
			return soap_in_dss__SetSetValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetEndDim"))
		{	*type = SOAP_TYPE_dss__SetEndDim;
			return soap_in_dss__SetEndDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetEndDimResponse"))
		{	*type = SOAP_TYPE_dss__SetEndDimResponse;
			return soap_in_dss__SetEndDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetStartDim"))
		{	*type = SOAP_TYPE_dss__SetStartDim;
			return soap_in_dss__SetStartDim(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetStartDimResponse"))
		{	*type = SOAP_TYPE_dss__SetStartDimResponse;
			return soap_in_dss__SetStartDimResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetDisable"))
		{	*type = SOAP_TYPE_dss__SetDisable;
			return soap_in_dss__SetDisable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetDisableResponse"))
		{	*type = SOAP_TYPE_dss__SetDisableResponse;
			return soap_in_dss__SetDisableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetEnable"))
		{	*type = SOAP_TYPE_dss__SetEnable;
			return soap_in_dss__SetEnable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetEnableResponse"))
		{	*type = SOAP_TYPE_dss__SetEnableResponse;
			return soap_in_dss__SetEnableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetDecreaseValue"))
		{	*type = SOAP_TYPE_dss__SetDecreaseValue;
			return soap_in_dss__SetDecreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetDecreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__SetDecreaseValueResponse;
			return soap_in_dss__SetDecreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetIncreaseValue"))
		{	*type = SOAP_TYPE_dss__SetIncreaseValue;
			return soap_in_dss__SetIncreaseValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetIncreaseValueResponse"))
		{	*type = SOAP_TYPE_dss__SetIncreaseValueResponse;
			return soap_in_dss__SetIncreaseValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOff"))
		{	*type = SOAP_TYPE_dss__SetTurnOff;
			return soap_in_dss__SetTurnOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOffResponse"))
		{	*type = SOAP_TYPE_dss__SetTurnOffResponse;
			return soap_in_dss__SetTurnOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOn"))
		{	*type = SOAP_TYPE_dss__SetTurnOn;
			return soap_in_dss__SetTurnOn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetTurnOnResponse"))
		{	*type = SOAP_TYPE_dss__SetTurnOnResponse;
			return soap_in_dss__SetTurnOnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneIDs"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneIDs;
			return soap_in_dss__ApartmentGetZoneIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneIDsResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneIDsResponse;
			return soap_in_dss__ApartmentGetZoneIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneByName"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneByName;
			return soap_in_dss__ApartmentGetZoneByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetZoneByNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetZoneByNameResponse;
			return soap_in_dss__ApartmentGetZoneByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetGroupByName"))
		{	*type = SOAP_TYPE_dss__ApartmentGetGroupByName;
			return soap_in_dss__ApartmentGetGroupByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetGroupByNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetGroupByNameResponse;
			return soap_in_dss__ApartmentGetGroupByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetGetContainedDevices"))
		{	*type = SOAP_TYPE_dss__SetGetContainedDevices;
			return soap_in_dss__SetGetContainedDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetGetContainedDevicesResponse"))
		{	*type = SOAP_TYPE_dss__SetGetContainedDevicesResponse;
			return soap_in_dss__SetGetContainedDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetByGroup"))
		{	*type = SOAP_TYPE_dss__SetByGroup;
			return soap_in_dss__SetByGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetByGroupResponse"))
		{	*type = SOAP_TYPE_dss__SetByGroupResponse;
			return soap_in_dss__SetByGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemove"))
		{	*type = SOAP_TYPE_dss__SetRemove;
			return soap_in_dss__SetRemove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemoveResponse"))
		{	*type = SOAP_TYPE_dss__SetRemoveResponse;
			return soap_in_dss__SetRemoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCombine"))
		{	*type = SOAP_TYPE_dss__SetCombine;
			return soap_in_dss__SetCombine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetCombineResponse"))
		{	*type = SOAP_TYPE_dss__SetCombineResponse;
			return soap_in_dss__SetCombineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemoveDevice"))
		{	*type = SOAP_TYPE_dss__SetRemoveDevice;
			return soap_in_dss__SetRemoveDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetRemoveDeviceResponse"))
		{	*type = SOAP_TYPE_dss__SetRemoveDeviceResponse;
			return soap_in_dss__SetRemoveDeviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByID"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByID;
			return soap_in_dss__SetAddDeviceByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByIDResponse"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByIDResponse;
			return soap_in_dss__SetAddDeviceByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByName"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByName;
			return soap_in_dss__SetAddDeviceByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SetAddDeviceByNameResponse"))
		{	*type = SOAP_TYPE_dss__SetAddDeviceByNameResponse;
			return soap_in_dss__SetAddDeviceByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDeviceIDByName"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDeviceIDByName;
			return soap_in_dss__ApartmentGetDeviceIDByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDeviceIDByNameResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse;
			return soap_in_dss__ApartmentGetDeviceIDByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDevices"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDevices;
			return soap_in_dss__ApartmentGetDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentGetDevicesResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentGetDevicesResponse;
			return soap_in_dss__ApartmentGetDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceNames"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames;
			return soap_in_dss__ApartmentCreateSetFromDeviceNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceNamesResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse;
			return soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceIDs"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs;
			return soap_in_dss__ApartmentCreateSetFromDeviceIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromDeviceIDsResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse;
			return soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromGroup"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromGroup;
			return soap_in_dss__ApartmentCreateSetFromGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:ApartmentCreateSetFromGroupResponse"))
		{	*type = SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse;
			return soap_in_dss__ApartmentCreateSetFromGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOff"))
		{	*type = SOAP_TYPE_dss__SignOff;
			return soap_in_dss__SignOff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:SignOffResponse"))
		{	*type = SOAP_TYPE_dss__SignOffResponse;
			return soap_in_dss__SignOffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:Authenticate"))
		{	*type = SOAP_TYPE_dss__Authenticate;
			return soap_in_dss__Authenticate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "dss:AuthenticateResponse"))
		{	*type = SOAP_TYPE_dss__AuthenticateResponse;
			return soap_in_dss__AuthenticateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_out_xsd__unsignedInt(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLong:
		return soap_out_unsignedLong(soap, tag, id, (const unsigned long *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_out_xsd__unsignedLong(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_dss__Event:
		return ((dss__Event *)ptr)->soap_out(soap, tag, id, "dss:Event");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_dss__PropertyGetChildren:
		return soap_out_dss__PropertyGetChildren(soap, tag, id, (const struct dss__PropertyGetChildren *)ptr, "dss:PropertyGetChildren");
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		return soap_out_dss__PropertyGetChildrenResponse(soap, tag, id, (const struct dss__PropertyGetChildrenResponse *)ptr, "dss:PropertyGetChildrenResponse");
	case SOAP_TYPE_dss__PropertyGetBool:
		return soap_out_dss__PropertyGetBool(soap, tag, id, (const struct dss__PropertyGetBool *)ptr, "dss:PropertyGetBool");
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		return soap_out_dss__PropertyGetBoolResponse(soap, tag, id, (const struct dss__PropertyGetBoolResponse *)ptr, "dss:PropertyGetBoolResponse");
	case SOAP_TYPE_dss__PropertyGetString:
		return soap_out_dss__PropertyGetString(soap, tag, id, (const struct dss__PropertyGetString *)ptr, "dss:PropertyGetString");
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		return soap_out_dss__PropertyGetStringResponse(soap, tag, id, (const struct dss__PropertyGetStringResponse *)ptr, "dss:PropertyGetStringResponse");
	case SOAP_TYPE_dss__PropertyGetInt:
		return soap_out_dss__PropertyGetInt(soap, tag, id, (const struct dss__PropertyGetInt *)ptr, "dss:PropertyGetInt");
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		return soap_out_dss__PropertyGetIntResponse(soap, tag, id, (const struct dss__PropertyGetIntResponse *)ptr, "dss:PropertyGetIntResponse");
	case SOAP_TYPE_dss__PropertySetBool:
		return soap_out_dss__PropertySetBool(soap, tag, id, (const struct dss__PropertySetBool *)ptr, "dss:PropertySetBool");
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		return soap_out_dss__PropertySetBoolResponse(soap, tag, id, (const struct dss__PropertySetBoolResponse *)ptr, "dss:PropertySetBoolResponse");
	case SOAP_TYPE_dss__PropertySetString:
		return soap_out_dss__PropertySetString(soap, tag, id, (const struct dss__PropertySetString *)ptr, "dss:PropertySetString");
	case SOAP_TYPE_dss__PropertySetStringResponse:
		return soap_out_dss__PropertySetStringResponse(soap, tag, id, (const struct dss__PropertySetStringResponse *)ptr, "dss:PropertySetStringResponse");
	case SOAP_TYPE_dss__PropertySetInt:
		return soap_out_dss__PropertySetInt(soap, tag, id, (const struct dss__PropertySetInt *)ptr, "dss:PropertySetInt");
	case SOAP_TYPE_dss__PropertySetIntResponse:
		return soap_out_dss__PropertySetIntResponse(soap, tag, id, (const struct dss__PropertySetIntResponse *)ptr, "dss:PropertySetIntResponse");
	case SOAP_TYPE_dss__PropertyGetType:
		return soap_out_dss__PropertyGetType(soap, tag, id, (const struct dss__PropertyGetType *)ptr, "dss:PropertyGetType");
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		return soap_out_dss__PropertyGetTypeResponse(soap, tag, id, (const struct dss__PropertyGetTypeResponse *)ptr, "dss:PropertyGetTypeResponse");
	case SOAP_TYPE_dss__EventSubscribeTo:
		return soap_out_dss__EventSubscribeTo(soap, tag, id, (const struct dss__EventSubscribeTo *)ptr, "dss:EventSubscribeTo");
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		return soap_out_dss__EventSubscribeToResponse(soap, tag, id, (const struct dss__EventSubscribeToResponse *)ptr, "dss:EventSubscribeToResponse");
	case SOAP_TYPE_dss__EventWaitFor:
		return soap_out_dss__EventWaitFor(soap, tag, id, (const struct dss__EventWaitFor *)ptr, "dss:EventWaitFor");
	case SOAP_TYPE_dss__EventWaitForResponse:
		return soap_out_dss__EventWaitForResponse(soap, tag, id, (const struct dss__EventWaitForResponse *)ptr, "dss:EventWaitForResponse");
	case SOAP_TYPE_dss__EventRaise:
		return soap_out_dss__EventRaise(soap, tag, id, (const struct dss__EventRaise *)ptr, "dss:EventRaise");
	case SOAP_TYPE_dss__EventRaiseResponse:
		return soap_out_dss__EventRaiseResponse(soap, tag, id, (const struct dss__EventRaiseResponse *)ptr, "dss:EventRaiseResponse");
	case SOAP_TYPE_dss__SwitchGetGroupID:
		return soap_out_dss__SwitchGetGroupID(soap, tag, id, (const struct dss__SwitchGetGroupID *)ptr, "dss:SwitchGetGroupID");
	case SOAP_TYPE_dss__SwitchGetGroupIDResponse:
		return soap_out_dss__SwitchGetGroupIDResponse(soap, tag, id, (const struct dss__SwitchGetGroupIDResponse *)ptr, "dss:SwitchGetGroupIDResponse");
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		return soap_out_dss__DeviceGetFunctionID(soap, tag, id, (const struct dss__DeviceGetFunctionID *)ptr, "dss:DeviceGetFunctionID");
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		return soap_out_dss__DeviceGetFunctionIDResponse(soap, tag, id, (const struct dss__DeviceGetFunctionIDResponse *)ptr, "dss:DeviceGetFunctionIDResponse");
	case SOAP_TYPE_dss__GroupRemoveDevice:
		return soap_out_dss__GroupRemoveDevice(soap, tag, id, (const struct dss__GroupRemoveDevice *)ptr, "dss:GroupRemoveDevice");
	case SOAP_TYPE_dss__GroupRemoveDeviceResponse:
		return soap_out_dss__GroupRemoveDeviceResponse(soap, tag, id, (const struct dss__GroupRemoveDeviceResponse *)ptr, "dss:GroupRemoveDeviceResponse");
	case SOAP_TYPE_dss__GroupAddDevice:
		return soap_out_dss__GroupAddDevice(soap, tag, id, (const struct dss__GroupAddDevice *)ptr, "dss:GroupAddDevice");
	case SOAP_TYPE_dss__GroupAddDeviceResponse:
		return soap_out_dss__GroupAddDeviceResponse(soap, tag, id, (const struct dss__GroupAddDeviceResponse *)ptr, "dss:GroupAddDeviceResponse");
	case SOAP_TYPE_dss__GroupRemoveUserGroup:
		return soap_out_dss__GroupRemoveUserGroup(soap, tag, id, (const struct dss__GroupRemoveUserGroup *)ptr, "dss:GroupRemoveUserGroup");
	case SOAP_TYPE_dss__GroupRemoveUserGroupResponse:
		return soap_out_dss__GroupRemoveUserGroupResponse(soap, tag, id, (const struct dss__GroupRemoveUserGroupResponse *)ptr, "dss:GroupRemoveUserGroupResponse");
	case SOAP_TYPE_dss__ApartmentAllocateUserGroup:
		return soap_out_dss__ApartmentAllocateUserGroup(soap, tag, id, (const struct dss__ApartmentAllocateUserGroup *)ptr, "dss:ApartmentAllocateUserGroup");
	case SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse:
		return soap_out_dss__ApartmentAllocateUserGroupResponse(soap, tag, id, (const struct dss__ApartmentAllocateUserGroupResponse *)ptr, "dss:ApartmentAllocateUserGroupResponse");
	case SOAP_TYPE_dss__Zone_SetName:
		return soap_out_dss__Zone_SetName(soap, tag, id, (const struct dss__Zone_SetName *)ptr, "dss:Zone-SetName");
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		return soap_out_dss__Zone_SetNameResponse(soap, tag, id, (const struct dss__Zone_SetNameResponse *)ptr, "dss:Zone-SetNameResponse");
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		return soap_out_dss__Zone_RemoveDevice(soap, tag, id, (const struct dss__Zone_RemoveDevice *)ptr, "dss:Zone-RemoveDevice");
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		return soap_out_dss__Zone_RemoveDeviceResponse(soap, tag, id, (const struct dss__Zone_RemoveDeviceResponse *)ptr, "dss:Zone-RemoveDeviceResponse");
	case SOAP_TYPE_dss__Zone_AddDevice:
		return soap_out_dss__Zone_AddDevice(soap, tag, id, (const struct dss__Zone_AddDevice *)ptr, "dss:Zone-AddDevice");
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		return soap_out_dss__Zone_AddDeviceResponse(soap, tag, id, (const struct dss__Zone_AddDeviceResponse *)ptr, "dss:Zone-AddDeviceResponse");
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		return soap_out_dss__ApartmentDeleteZone(soap, tag, id, (const struct dss__ApartmentDeleteZone *)ptr, "dss:ApartmentDeleteZone");
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		return soap_out_dss__ApartmentDeleteZoneResponse(soap, tag, id, (const struct dss__ApartmentDeleteZoneResponse *)ptr, "dss:ApartmentDeleteZoneResponse");
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		return soap_out_dss__ApartmentAllocateZone(soap, tag, id, (const struct dss__ApartmentAllocateZone *)ptr, "dss:ApartmentAllocateZone");
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		return soap_out_dss__ApartmentAllocateZoneResponse(soap, tag, id, (const struct dss__ApartmentAllocateZoneResponse *)ptr, "dss:ApartmentAllocateZoneResponse");
	case SOAP_TYPE_dss__ModulatorGetName:
		return soap_out_dss__ModulatorGetName(soap, tag, id, (const struct dss__ModulatorGetName *)ptr, "dss:ModulatorGetName");
	case SOAP_TYPE_dss__ModulatorGetNameResponse:
		return soap_out_dss__ModulatorGetNameResponse(soap, tag, id, (const struct dss__ModulatorGetNameResponse *)ptr, "dss:ModulatorGetNameResponse");
	case SOAP_TYPE_dss__ApartmentGetModulatorIDs:
		return soap_out_dss__ApartmentGetModulatorIDs(soap, tag, id, (const struct dss__ApartmentGetModulatorIDs *)ptr, "dss:ApartmentGetModulatorIDs");
	case SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse:
		return soap_out_dss__ApartmentGetModulatorIDsResponse(soap, tag, id, (const struct dss__ApartmentGetModulatorIDsResponse *)ptr, "dss:ApartmentGetModulatorIDsResponse");
	case SOAP_TYPE_dss__ModulatorGetPowerConsumption:
		return soap_out_dss__ModulatorGetPowerConsumption(soap, tag, id, (const struct dss__ModulatorGetPowerConsumption *)ptr, "dss:ModulatorGetPowerConsumption");
	case SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse:
		return soap_out_dss__ModulatorGetPowerConsumptionResponse(soap, tag, id, (const struct dss__ModulatorGetPowerConsumptionResponse *)ptr, "dss:ModulatorGetPowerConsumptionResponse");
	case SOAP_TYPE_dss__DeviceGetZoneID:
		return soap_out_dss__DeviceGetZoneID(soap, tag, id, (const struct dss__DeviceGetZoneID *)ptr, "dss:DeviceGetZoneID");
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		return soap_out_dss__DeviceGetZoneIDResponse(soap, tag, id, (const struct dss__DeviceGetZoneIDResponse *)ptr, "dss:DeviceGetZoneIDResponse");
	case SOAP_TYPE_dss__DeviceGetName:
		return soap_out_dss__DeviceGetName(soap, tag, id, (const struct dss__DeviceGetName *)ptr, "dss:DeviceGetName");
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		return soap_out_dss__DeviceGetNameResponse(soap, tag, id, (const struct dss__DeviceGetNameResponse *)ptr, "dss:DeviceGetNameResponse");
	case SOAP_TYPE_dss__DeviceSaveScene:
		return soap_out_dss__DeviceSaveScene(soap, tag, id, (const struct dss__DeviceSaveScene *)ptr, "dss:DeviceSaveScene");
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		return soap_out_dss__DeviceSaveSceneResponse(soap, tag, id, (const struct dss__DeviceSaveSceneResponse *)ptr, "dss:DeviceSaveSceneResponse");
	case SOAP_TYPE_dss__DeviceCallScene:
		return soap_out_dss__DeviceCallScene(soap, tag, id, (const struct dss__DeviceCallScene *)ptr, "dss:DeviceCallScene");
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		return soap_out_dss__DeviceCallSceneResponse(soap, tag, id, (const struct dss__DeviceCallSceneResponse *)ptr, "dss:DeviceCallSceneResponse");
	case SOAP_TYPE_dss__DeviceGetValue:
		return soap_out_dss__DeviceGetValue(soap, tag, id, (const struct dss__DeviceGetValue *)ptr, "dss:DeviceGetValue");
	case SOAP_TYPE_dss__DeviceGetValueResponse:
		return soap_out_dss__DeviceGetValueResponse(soap, tag, id, (const struct dss__DeviceGetValueResponse *)ptr, "dss:DeviceGetValueResponse");
	case SOAP_TYPE_dss__DeviceSetValue:
		return soap_out_dss__DeviceSetValue(soap, tag, id, (const struct dss__DeviceSetValue *)ptr, "dss:DeviceSetValue");
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		return soap_out_dss__DeviceSetValueResponse(soap, tag, id, (const struct dss__DeviceSetValueResponse *)ptr, "dss:DeviceSetValueResponse");
	case SOAP_TYPE_dss__DeviceEndDim:
		return soap_out_dss__DeviceEndDim(soap, tag, id, (const struct dss__DeviceEndDim *)ptr, "dss:DeviceEndDim");
	case SOAP_TYPE_dss__DeviceEndDimResponse:
		return soap_out_dss__DeviceEndDimResponse(soap, tag, id, (const struct dss__DeviceEndDimResponse *)ptr, "dss:DeviceEndDimResponse");
	case SOAP_TYPE_dss__DeviceStartDim:
		return soap_out_dss__DeviceStartDim(soap, tag, id, (const struct dss__DeviceStartDim *)ptr, "dss:DeviceStartDim");
	case SOAP_TYPE_dss__DeviceStartDimResponse:
		return soap_out_dss__DeviceStartDimResponse(soap, tag, id, (const struct dss__DeviceStartDimResponse *)ptr, "dss:DeviceStartDimResponse");
	case SOAP_TYPE_dss__DeviceDisable:
		return soap_out_dss__DeviceDisable(soap, tag, id, (const struct dss__DeviceDisable *)ptr, "dss:DeviceDisable");
	case SOAP_TYPE_dss__DeviceDisableResponse:
		return soap_out_dss__DeviceDisableResponse(soap, tag, id, (const struct dss__DeviceDisableResponse *)ptr, "dss:DeviceDisableResponse");
	case SOAP_TYPE_dss__DeviceEnable:
		return soap_out_dss__DeviceEnable(soap, tag, id, (const struct dss__DeviceEnable *)ptr, "dss:DeviceEnable");
	case SOAP_TYPE_dss__DeviceEnableResponse:
		return soap_out_dss__DeviceEnableResponse(soap, tag, id, (const struct dss__DeviceEnableResponse *)ptr, "dss:DeviceEnableResponse");
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		return soap_out_dss__DeviceDecreaseValue(soap, tag, id, (const struct dss__DeviceDecreaseValue *)ptr, "dss:DeviceDecreaseValue");
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		return soap_out_dss__DeviceDecreaseValueResponse(soap, tag, id, (const struct dss__DeviceDecreaseValueResponse *)ptr, "dss:DeviceDecreaseValueResponse");
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		return soap_out_dss__DeviceIncreaseValue(soap, tag, id, (const struct dss__DeviceIncreaseValue *)ptr, "dss:DeviceIncreaseValue");
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		return soap_out_dss__DeviceIncreaseValueResponse(soap, tag, id, (const struct dss__DeviceIncreaseValueResponse *)ptr, "dss:DeviceIncreaseValueResponse");
	case SOAP_TYPE_dss__DeviceTurnOff:
		return soap_out_dss__DeviceTurnOff(soap, tag, id, (const struct dss__DeviceTurnOff *)ptr, "dss:DeviceTurnOff");
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		return soap_out_dss__DeviceTurnOffResponse(soap, tag, id, (const struct dss__DeviceTurnOffResponse *)ptr, "dss:DeviceTurnOffResponse");
	case SOAP_TYPE_dss__DeviceTurnOn:
		return soap_out_dss__DeviceTurnOn(soap, tag, id, (const struct dss__DeviceTurnOn *)ptr, "dss:DeviceTurnOn");
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		return soap_out_dss__DeviceTurnOnResponse(soap, tag, id, (const struct dss__DeviceTurnOnResponse *)ptr, "dss:DeviceTurnOnResponse");
	case SOAP_TYPE_dss__ZoneSaveScene:
		return soap_out_dss__ZoneSaveScene(soap, tag, id, (const struct dss__ZoneSaveScene *)ptr, "dss:ZoneSaveScene");
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		return soap_out_dss__ZoneSaveSceneResponse(soap, tag, id, (const struct dss__ZoneSaveSceneResponse *)ptr, "dss:ZoneSaveSceneResponse");
	case SOAP_TYPE_dss__ZoneCallScene:
		return soap_out_dss__ZoneCallScene(soap, tag, id, (const struct dss__ZoneCallScene *)ptr, "dss:ZoneCallScene");
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		return soap_out_dss__ZoneCallSceneResponse(soap, tag, id, (const struct dss__ZoneCallSceneResponse *)ptr, "dss:ZoneCallSceneResponse");
	case SOAP_TYPE_dss__ZoneSetValue:
		return soap_out_dss__ZoneSetValue(soap, tag, id, (const struct dss__ZoneSetValue *)ptr, "dss:ZoneSetValue");
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		return soap_out_dss__ZoneSetValueResponse(soap, tag, id, (const struct dss__ZoneSetValueResponse *)ptr, "dss:ZoneSetValueResponse");
	case SOAP_TYPE_dss__ZoneEndDim:
		return soap_out_dss__ZoneEndDim(soap, tag, id, (const struct dss__ZoneEndDim *)ptr, "dss:ZoneEndDim");
	case SOAP_TYPE_dss__ZoneEndDimResponse:
		return soap_out_dss__ZoneEndDimResponse(soap, tag, id, (const struct dss__ZoneEndDimResponse *)ptr, "dss:ZoneEndDimResponse");
	case SOAP_TYPE_dss__ZoneStartDim:
		return soap_out_dss__ZoneStartDim(soap, tag, id, (const struct dss__ZoneStartDim *)ptr, "dss:ZoneStartDim");
	case SOAP_TYPE_dss__ZoneStartDimResponse:
		return soap_out_dss__ZoneStartDimResponse(soap, tag, id, (const struct dss__ZoneStartDimResponse *)ptr, "dss:ZoneStartDimResponse");
	case SOAP_TYPE_dss__ZoneDisable:
		return soap_out_dss__ZoneDisable(soap, tag, id, (const struct dss__ZoneDisable *)ptr, "dss:ZoneDisable");
	case SOAP_TYPE_dss__ZoneDisableResponse:
		return soap_out_dss__ZoneDisableResponse(soap, tag, id, (const struct dss__ZoneDisableResponse *)ptr, "dss:ZoneDisableResponse");
	case SOAP_TYPE_dss__ZoneEnable:
		return soap_out_dss__ZoneEnable(soap, tag, id, (const struct dss__ZoneEnable *)ptr, "dss:ZoneEnable");
	case SOAP_TYPE_dss__ZoneEnableResponse:
		return soap_out_dss__ZoneEnableResponse(soap, tag, id, (const struct dss__ZoneEnableResponse *)ptr, "dss:ZoneEnableResponse");
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		return soap_out_dss__ZoneDecreaseValue(soap, tag, id, (const struct dss__ZoneDecreaseValue *)ptr, "dss:ZoneDecreaseValue");
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		return soap_out_dss__ZoneDecreaseValueResponse(soap, tag, id, (const struct dss__ZoneDecreaseValueResponse *)ptr, "dss:ZoneDecreaseValueResponse");
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		return soap_out_dss__ZoneIncreaseValue(soap, tag, id, (const struct dss__ZoneIncreaseValue *)ptr, "dss:ZoneIncreaseValue");
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		return soap_out_dss__ZoneIncreaseValueResponse(soap, tag, id, (const struct dss__ZoneIncreaseValueResponse *)ptr, "dss:ZoneIncreaseValueResponse");
	case SOAP_TYPE_dss__ZoneTurnOff:
		return soap_out_dss__ZoneTurnOff(soap, tag, id, (const struct dss__ZoneTurnOff *)ptr, "dss:ZoneTurnOff");
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		return soap_out_dss__ZoneTurnOffResponse(soap, tag, id, (const struct dss__ZoneTurnOffResponse *)ptr, "dss:ZoneTurnOffResponse");
	case SOAP_TYPE_dss__ZoneTurnOn:
		return soap_out_dss__ZoneTurnOn(soap, tag, id, (const struct dss__ZoneTurnOn *)ptr, "dss:ZoneTurnOn");
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		return soap_out_dss__ZoneTurnOnResponse(soap, tag, id, (const struct dss__ZoneTurnOnResponse *)ptr, "dss:ZoneTurnOnResponse");
	case SOAP_TYPE_dss__CircuitRescan:
		return soap_out_dss__CircuitRescan(soap, tag, id, (const struct dss__CircuitRescan *)ptr, "dss:CircuitRescan");
	case SOAP_TYPE_dss__CircuitRescanResponse:
		return soap_out_dss__CircuitRescanResponse(soap, tag, id, (const struct dss__CircuitRescanResponse *)ptr, "dss:CircuitRescanResponse");
	case SOAP_TYPE_dss__ApartmentRescan:
		return soap_out_dss__ApartmentRescan(soap, tag, id, (const struct dss__ApartmentRescan *)ptr, "dss:ApartmentRescan");
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		return soap_out_dss__ApartmentRescanResponse(soap, tag, id, (const struct dss__ApartmentRescanResponse *)ptr, "dss:ApartmentRescanResponse");
	case SOAP_TYPE_dss__ApartmentSaveScene:
		return soap_out_dss__ApartmentSaveScene(soap, tag, id, (const struct dss__ApartmentSaveScene *)ptr, "dss:ApartmentSaveScene");
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		return soap_out_dss__ApartmentSaveSceneResponse(soap, tag, id, (const struct dss__ApartmentSaveSceneResponse *)ptr, "dss:ApartmentSaveSceneResponse");
	case SOAP_TYPE_dss__ApartmentCallScene:
		return soap_out_dss__ApartmentCallScene(soap, tag, id, (const struct dss__ApartmentCallScene *)ptr, "dss:ApartmentCallScene");
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		return soap_out_dss__ApartmentCallSceneResponse(soap, tag, id, (const struct dss__ApartmentCallSceneResponse *)ptr, "dss:ApartmentCallSceneResponse");
	case SOAP_TYPE_dss__ApartmentSetValue:
		return soap_out_dss__ApartmentSetValue(soap, tag, id, (const struct dss__ApartmentSetValue *)ptr, "dss:ApartmentSetValue");
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		return soap_out_dss__ApartmentSetValueResponse(soap, tag, id, (const struct dss__ApartmentSetValueResponse *)ptr, "dss:ApartmentSetValueResponse");
	case SOAP_TYPE_dss__ApartmentEndDim:
		return soap_out_dss__ApartmentEndDim(soap, tag, id, (const struct dss__ApartmentEndDim *)ptr, "dss:ApartmentEndDim");
	case SOAP_TYPE_dss__ApartmentEndDimResponse:
		return soap_out_dss__ApartmentEndDimResponse(soap, tag, id, (const struct dss__ApartmentEndDimResponse *)ptr, "dss:ApartmentEndDimResponse");
	case SOAP_TYPE_dss__ApartmentStartDim:
		return soap_out_dss__ApartmentStartDim(soap, tag, id, (const struct dss__ApartmentStartDim *)ptr, "dss:ApartmentStartDim");
	case SOAP_TYPE_dss__ApartmentStartDimResponse:
		return soap_out_dss__ApartmentStartDimResponse(soap, tag, id, (const struct dss__ApartmentStartDimResponse *)ptr, "dss:ApartmentStartDimResponse");
	case SOAP_TYPE_dss__ApartmentDisable:
		return soap_out_dss__ApartmentDisable(soap, tag, id, (const struct dss__ApartmentDisable *)ptr, "dss:ApartmentDisable");
	case SOAP_TYPE_dss__ApartmentDisableResponse:
		return soap_out_dss__ApartmentDisableResponse(soap, tag, id, (const struct dss__ApartmentDisableResponse *)ptr, "dss:ApartmentDisableResponse");
	case SOAP_TYPE_dss__ApartmentEnable:
		return soap_out_dss__ApartmentEnable(soap, tag, id, (const struct dss__ApartmentEnable *)ptr, "dss:ApartmentEnable");
	case SOAP_TYPE_dss__ApartmentEnableResponse:
		return soap_out_dss__ApartmentEnableResponse(soap, tag, id, (const struct dss__ApartmentEnableResponse *)ptr, "dss:ApartmentEnableResponse");
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		return soap_out_dss__ApartmentDecreaseValue(soap, tag, id, (const struct dss__ApartmentDecreaseValue *)ptr, "dss:ApartmentDecreaseValue");
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		return soap_out_dss__ApartmentDecreaseValueResponse(soap, tag, id, (const struct dss__ApartmentDecreaseValueResponse *)ptr, "dss:ApartmentDecreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		return soap_out_dss__ApartmentIncreaseValue(soap, tag, id, (const struct dss__ApartmentIncreaseValue *)ptr, "dss:ApartmentIncreaseValue");
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		return soap_out_dss__ApartmentIncreaseValueResponse(soap, tag, id, (const struct dss__ApartmentIncreaseValueResponse *)ptr, "dss:ApartmentIncreaseValueResponse");
	case SOAP_TYPE_dss__ApartmentTurnOff:
		return soap_out_dss__ApartmentTurnOff(soap, tag, id, (const struct dss__ApartmentTurnOff *)ptr, "dss:ApartmentTurnOff");
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		return soap_out_dss__ApartmentTurnOffResponse(soap, tag, id, (const struct dss__ApartmentTurnOffResponse *)ptr, "dss:ApartmentTurnOffResponse");
	case SOAP_TYPE_dss__ApartmentTurnOn:
		return soap_out_dss__ApartmentTurnOn(soap, tag, id, (const struct dss__ApartmentTurnOn *)ptr, "dss:ApartmentTurnOn");
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		return soap_out_dss__ApartmentTurnOnResponse(soap, tag, id, (const struct dss__ApartmentTurnOnResponse *)ptr, "dss:ApartmentTurnOnResponse");
	case SOAP_TYPE_dss__SetSaveScene:
		return soap_out_dss__SetSaveScene(soap, tag, id, (const struct dss__SetSaveScene *)ptr, "dss:SetSaveScene");
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		return soap_out_dss__SetSaveSceneResponse(soap, tag, id, (const struct dss__SetSaveSceneResponse *)ptr, "dss:SetSaveSceneResponse");
	case SOAP_TYPE_dss__SetCallScene:
		return soap_out_dss__SetCallScene(soap, tag, id, (const struct dss__SetCallScene *)ptr, "dss:SetCallScene");
	case SOAP_TYPE_dss__SetCallSceneResponse:
		return soap_out_dss__SetCallSceneResponse(soap, tag, id, (const struct dss__SetCallSceneResponse *)ptr, "dss:SetCallSceneResponse");
	case SOAP_TYPE_dss__SetSetValue:
		return soap_out_dss__SetSetValue(soap, tag, id, (const struct dss__SetSetValue *)ptr, "dss:SetSetValue");
	case SOAP_TYPE_dss__SetSetValueResponse:
		return soap_out_dss__SetSetValueResponse(soap, tag, id, (const struct dss__SetSetValueResponse *)ptr, "dss:SetSetValueResponse");
	case SOAP_TYPE_dss__SetEndDim:
		return soap_out_dss__SetEndDim(soap, tag, id, (const struct dss__SetEndDim *)ptr, "dss:SetEndDim");
	case SOAP_TYPE_dss__SetEndDimResponse:
		return soap_out_dss__SetEndDimResponse(soap, tag, id, (const struct dss__SetEndDimResponse *)ptr, "dss:SetEndDimResponse");
	case SOAP_TYPE_dss__SetStartDim:
		return soap_out_dss__SetStartDim(soap, tag, id, (const struct dss__SetStartDim *)ptr, "dss:SetStartDim");
	case SOAP_TYPE_dss__SetStartDimResponse:
		return soap_out_dss__SetStartDimResponse(soap, tag, id, (const struct dss__SetStartDimResponse *)ptr, "dss:SetStartDimResponse");
	case SOAP_TYPE_dss__SetDisable:
		return soap_out_dss__SetDisable(soap, tag, id, (const struct dss__SetDisable *)ptr, "dss:SetDisable");
	case SOAP_TYPE_dss__SetDisableResponse:
		return soap_out_dss__SetDisableResponse(soap, tag, id, (const struct dss__SetDisableResponse *)ptr, "dss:SetDisableResponse");
	case SOAP_TYPE_dss__SetEnable:
		return soap_out_dss__SetEnable(soap, tag, id, (const struct dss__SetEnable *)ptr, "dss:SetEnable");
	case SOAP_TYPE_dss__SetEnableResponse:
		return soap_out_dss__SetEnableResponse(soap, tag, id, (const struct dss__SetEnableResponse *)ptr, "dss:SetEnableResponse");
	case SOAP_TYPE_dss__SetDecreaseValue:
		return soap_out_dss__SetDecreaseValue(soap, tag, id, (const struct dss__SetDecreaseValue *)ptr, "dss:SetDecreaseValue");
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		return soap_out_dss__SetDecreaseValueResponse(soap, tag, id, (const struct dss__SetDecreaseValueResponse *)ptr, "dss:SetDecreaseValueResponse");
	case SOAP_TYPE_dss__SetIncreaseValue:
		return soap_out_dss__SetIncreaseValue(soap, tag, id, (const struct dss__SetIncreaseValue *)ptr, "dss:SetIncreaseValue");
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		return soap_out_dss__SetIncreaseValueResponse(soap, tag, id, (const struct dss__SetIncreaseValueResponse *)ptr, "dss:SetIncreaseValueResponse");
	case SOAP_TYPE_dss__SetTurnOff:
		return soap_out_dss__SetTurnOff(soap, tag, id, (const struct dss__SetTurnOff *)ptr, "dss:SetTurnOff");
	case SOAP_TYPE_dss__SetTurnOffResponse:
		return soap_out_dss__SetTurnOffResponse(soap, tag, id, (const struct dss__SetTurnOffResponse *)ptr, "dss:SetTurnOffResponse");
	case SOAP_TYPE_dss__SetTurnOn:
		return soap_out_dss__SetTurnOn(soap, tag, id, (const struct dss__SetTurnOn *)ptr, "dss:SetTurnOn");
	case SOAP_TYPE_dss__SetTurnOnResponse:
		return soap_out_dss__SetTurnOnResponse(soap, tag, id, (const struct dss__SetTurnOnResponse *)ptr, "dss:SetTurnOnResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		return soap_out_dss__ApartmentGetZoneIDs(soap, tag, id, (const struct dss__ApartmentGetZoneIDs *)ptr, "dss:ApartmentGetZoneIDs");
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		return soap_out_dss__ApartmentGetZoneIDsResponse(soap, tag, id, (const struct dss__ApartmentGetZoneIDsResponse *)ptr, "dss:ApartmentGetZoneIDsResponse");
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		return soap_out_dss__ApartmentGetZoneByName(soap, tag, id, (const struct dss__ApartmentGetZoneByName *)ptr, "dss:ApartmentGetZoneByName");
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		return soap_out_dss__ApartmentGetZoneByNameResponse(soap, tag, id, (const struct dss__ApartmentGetZoneByNameResponse *)ptr, "dss:ApartmentGetZoneByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		return soap_out_dss__ApartmentGetGroupByName(soap, tag, id, (const struct dss__ApartmentGetGroupByName *)ptr, "dss:ApartmentGetGroupByName");
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		return soap_out_dss__ApartmentGetGroupByNameResponse(soap, tag, id, (const struct dss__ApartmentGetGroupByNameResponse *)ptr, "dss:ApartmentGetGroupByNameResponse");
	case SOAP_TYPE_dss__SetGetContainedDevices:
		return soap_out_dss__SetGetContainedDevices(soap, tag, id, (const struct dss__SetGetContainedDevices *)ptr, "dss:SetGetContainedDevices");
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		return soap_out_dss__SetGetContainedDevicesResponse(soap, tag, id, (const struct dss__SetGetContainedDevicesResponse *)ptr, "dss:SetGetContainedDevicesResponse");
	case SOAP_TYPE_dss__SetByGroup:
		return soap_out_dss__SetByGroup(soap, tag, id, (const struct dss__SetByGroup *)ptr, "dss:SetByGroup");
	case SOAP_TYPE_dss__SetByGroupResponse:
		return soap_out_dss__SetByGroupResponse(soap, tag, id, (const struct dss__SetByGroupResponse *)ptr, "dss:SetByGroupResponse");
	case SOAP_TYPE_dss__SetRemove:
		return soap_out_dss__SetRemove(soap, tag, id, (const struct dss__SetRemove *)ptr, "dss:SetRemove");
	case SOAP_TYPE_dss__SetRemoveResponse:
		return soap_out_dss__SetRemoveResponse(soap, tag, id, (const struct dss__SetRemoveResponse *)ptr, "dss:SetRemoveResponse");
	case SOAP_TYPE_dss__SetCombine:
		return soap_out_dss__SetCombine(soap, tag, id, (const struct dss__SetCombine *)ptr, "dss:SetCombine");
	case SOAP_TYPE_dss__SetCombineResponse:
		return soap_out_dss__SetCombineResponse(soap, tag, id, (const struct dss__SetCombineResponse *)ptr, "dss:SetCombineResponse");
	case SOAP_TYPE_dss__SetRemoveDevice:
		return soap_out_dss__SetRemoveDevice(soap, tag, id, (const struct dss__SetRemoveDevice *)ptr, "dss:SetRemoveDevice");
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		return soap_out_dss__SetRemoveDeviceResponse(soap, tag, id, (const struct dss__SetRemoveDeviceResponse *)ptr, "dss:SetRemoveDeviceResponse");
	case SOAP_TYPE_dss__SetAddDeviceByID:
		return soap_out_dss__SetAddDeviceByID(soap, tag, id, (const struct dss__SetAddDeviceByID *)ptr, "dss:SetAddDeviceByID");
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		return soap_out_dss__SetAddDeviceByIDResponse(soap, tag, id, (const struct dss__SetAddDeviceByIDResponse *)ptr, "dss:SetAddDeviceByIDResponse");
	case SOAP_TYPE_dss__SetAddDeviceByName:
		return soap_out_dss__SetAddDeviceByName(soap, tag, id, (const struct dss__SetAddDeviceByName *)ptr, "dss:SetAddDeviceByName");
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		return soap_out_dss__SetAddDeviceByNameResponse(soap, tag, id, (const struct dss__SetAddDeviceByNameResponse *)ptr, "dss:SetAddDeviceByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		return soap_out_dss__ApartmentGetDeviceIDByName(soap, tag, id, (const struct dss__ApartmentGetDeviceIDByName *)ptr, "dss:ApartmentGetDeviceIDByName");
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		return soap_out_dss__ApartmentGetDeviceIDByNameResponse(soap, tag, id, (const struct dss__ApartmentGetDeviceIDByNameResponse *)ptr, "dss:ApartmentGetDeviceIDByNameResponse");
	case SOAP_TYPE_dss__ApartmentGetDevices:
		return soap_out_dss__ApartmentGetDevices(soap, tag, id, (const struct dss__ApartmentGetDevices *)ptr, "dss:ApartmentGetDevices");
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		return soap_out_dss__ApartmentGetDevicesResponse(soap, tag, id, (const struct dss__ApartmentGetDevicesResponse *)ptr, "dss:ApartmentGetDevicesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		return soap_out_dss__ApartmentCreateSetFromDeviceNames(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceNames *)ptr, "dss:ApartmentCreateSetFromDeviceNames");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		return soap_out_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceNamesResponse *)ptr, "dss:ApartmentCreateSetFromDeviceNamesResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		return soap_out_dss__ApartmentCreateSetFromDeviceIDs(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceIDs *)ptr, "dss:ApartmentCreateSetFromDeviceIDs");
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		return soap_out_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, tag, id, (const struct dss__ApartmentCreateSetFromDeviceIDsResponse *)ptr, "dss:ApartmentCreateSetFromDeviceIDsResponse");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		return soap_out_dss__ApartmentCreateSetFromGroup(soap, tag, id, (const struct dss__ApartmentCreateSetFromGroup *)ptr, "dss:ApartmentCreateSetFromGroup");
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		return soap_out_dss__ApartmentCreateSetFromGroupResponse(soap, tag, id, (const struct dss__ApartmentCreateSetFromGroupResponse *)ptr, "dss:ApartmentCreateSetFromGroupResponse");
	case SOAP_TYPE_dss__SignOff:
		return soap_out_dss__SignOff(soap, tag, id, (const struct dss__SignOff *)ptr, "dss:SignOff");
	case SOAP_TYPE_dss__SignOffResponse:
		return soap_out_dss__SignOffResponse(soap, tag, id, (const struct dss__SignOffResponse *)ptr, "dss:SignOffResponse");
	case SOAP_TYPE_dss__Authenticate:
		return soap_out_dss__Authenticate(soap, tag, id, (const struct dss__Authenticate *)ptr, "dss:Authenticate");
	case SOAP_TYPE_dss__AuthenticateResponse:
		return soap_out_dss__AuthenticateResponse(soap, tag, id, (const struct dss__AuthenticateResponse *)ptr, "dss:AuthenticateResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_dss__Event:
		((dss__Event *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetChildren:
		soap_serialize_dss__PropertyGetChildren(soap, (const struct dss__PropertyGetChildren *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		soap_serialize_dss__PropertyGetChildrenResponse(soap, (const struct dss__PropertyGetChildrenResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetBool:
		soap_serialize_dss__PropertyGetBool(soap, (const struct dss__PropertyGetBool *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		soap_serialize_dss__PropertyGetBoolResponse(soap, (const struct dss__PropertyGetBoolResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetString:
		soap_serialize_dss__PropertyGetString(soap, (const struct dss__PropertyGetString *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		soap_serialize_dss__PropertyGetStringResponse(soap, (const struct dss__PropertyGetStringResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetInt:
		soap_serialize_dss__PropertyGetInt(soap, (const struct dss__PropertyGetInt *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		soap_serialize_dss__PropertyGetIntResponse(soap, (const struct dss__PropertyGetIntResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetBool:
		soap_serialize_dss__PropertySetBool(soap, (const struct dss__PropertySetBool *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		soap_serialize_dss__PropertySetBoolResponse(soap, (const struct dss__PropertySetBoolResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetString:
		soap_serialize_dss__PropertySetString(soap, (const struct dss__PropertySetString *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetStringResponse:
		soap_serialize_dss__PropertySetStringResponse(soap, (const struct dss__PropertySetStringResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetInt:
		soap_serialize_dss__PropertySetInt(soap, (const struct dss__PropertySetInt *)ptr);
		break;
	case SOAP_TYPE_dss__PropertySetIntResponse:
		soap_serialize_dss__PropertySetIntResponse(soap, (const struct dss__PropertySetIntResponse *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetType:
		soap_serialize_dss__PropertyGetType(soap, (const struct dss__PropertyGetType *)ptr);
		break;
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		soap_serialize_dss__PropertyGetTypeResponse(soap, (const struct dss__PropertyGetTypeResponse *)ptr);
		break;
	case SOAP_TYPE_dss__EventSubscribeTo:
		soap_serialize_dss__EventSubscribeTo(soap, (const struct dss__EventSubscribeTo *)ptr);
		break;
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		soap_serialize_dss__EventSubscribeToResponse(soap, (const struct dss__EventSubscribeToResponse *)ptr);
		break;
	case SOAP_TYPE_dss__EventWaitFor:
		soap_serialize_dss__EventWaitFor(soap, (const struct dss__EventWaitFor *)ptr);
		break;
	case SOAP_TYPE_dss__EventWaitForResponse:
		soap_serialize_dss__EventWaitForResponse(soap, (const struct dss__EventWaitForResponse *)ptr);
		break;
	case SOAP_TYPE_dss__EventRaise:
		soap_serialize_dss__EventRaise(soap, (const struct dss__EventRaise *)ptr);
		break;
	case SOAP_TYPE_dss__EventRaiseResponse:
		soap_serialize_dss__EventRaiseResponse(soap, (const struct dss__EventRaiseResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SwitchGetGroupID:
		soap_serialize_dss__SwitchGetGroupID(soap, (const struct dss__SwitchGetGroupID *)ptr);
		break;
	case SOAP_TYPE_dss__SwitchGetGroupIDResponse:
		soap_serialize_dss__SwitchGetGroupIDResponse(soap, (const struct dss__SwitchGetGroupIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		soap_serialize_dss__DeviceGetFunctionID(soap, (const struct dss__DeviceGetFunctionID *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		soap_serialize_dss__DeviceGetFunctionIDResponse(soap, (const struct dss__DeviceGetFunctionIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__GroupRemoveDevice:
		soap_serialize_dss__GroupRemoveDevice(soap, (const struct dss__GroupRemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__GroupRemoveDeviceResponse:
		soap_serialize_dss__GroupRemoveDeviceResponse(soap, (const struct dss__GroupRemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__GroupAddDevice:
		soap_serialize_dss__GroupAddDevice(soap, (const struct dss__GroupAddDevice *)ptr);
		break;
	case SOAP_TYPE_dss__GroupAddDeviceResponse:
		soap_serialize_dss__GroupAddDeviceResponse(soap, (const struct dss__GroupAddDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__GroupRemoveUserGroup:
		soap_serialize_dss__GroupRemoveUserGroup(soap, (const struct dss__GroupRemoveUserGroup *)ptr);
		break;
	case SOAP_TYPE_dss__GroupRemoveUserGroupResponse:
		soap_serialize_dss__GroupRemoveUserGroupResponse(soap, (const struct dss__GroupRemoveUserGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentAllocateUserGroup:
		soap_serialize_dss__ApartmentAllocateUserGroup(soap, (const struct dss__ApartmentAllocateUserGroup *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse:
		soap_serialize_dss__ApartmentAllocateUserGroupResponse(soap, (const struct dss__ApartmentAllocateUserGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_SetName:
		soap_serialize_dss__Zone_SetName(soap, (const struct dss__Zone_SetName *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		soap_serialize_dss__Zone_SetNameResponse(soap, (const struct dss__Zone_SetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		soap_serialize_dss__Zone_RemoveDevice(soap, (const struct dss__Zone_RemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		soap_serialize_dss__Zone_RemoveDeviceResponse(soap, (const struct dss__Zone_RemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_AddDevice:
		soap_serialize_dss__Zone_AddDevice(soap, (const struct dss__Zone_AddDevice *)ptr);
		break;
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		soap_serialize_dss__Zone_AddDeviceResponse(soap, (const struct dss__Zone_AddDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		soap_serialize_dss__ApartmentDeleteZone(soap, (const struct dss__ApartmentDeleteZone *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		soap_serialize_dss__ApartmentDeleteZoneResponse(soap, (const struct dss__ApartmentDeleteZoneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		soap_serialize_dss__ApartmentAllocateZone(soap, (const struct dss__ApartmentAllocateZone *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		soap_serialize_dss__ApartmentAllocateZoneResponse(soap, (const struct dss__ApartmentAllocateZoneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ModulatorGetName:
		soap_serialize_dss__ModulatorGetName(soap, (const struct dss__ModulatorGetName *)ptr);
		break;
	case SOAP_TYPE_dss__ModulatorGetNameResponse:
		soap_serialize_dss__ModulatorGetNameResponse(soap, (const struct dss__ModulatorGetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetModulatorIDs:
		soap_serialize_dss__ApartmentGetModulatorIDs(soap, (const struct dss__ApartmentGetModulatorIDs *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse:
		soap_serialize_dss__ApartmentGetModulatorIDsResponse(soap, (const struct dss__ApartmentGetModulatorIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ModulatorGetPowerConsumption:
		soap_serialize_dss__ModulatorGetPowerConsumption(soap, (const struct dss__ModulatorGetPowerConsumption *)ptr);
		break;
	case SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse:
		soap_serialize_dss__ModulatorGetPowerConsumptionResponse(soap, (const struct dss__ModulatorGetPowerConsumptionResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetZoneID:
		soap_serialize_dss__DeviceGetZoneID(soap, (const struct dss__DeviceGetZoneID *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		soap_serialize_dss__DeviceGetZoneIDResponse(soap, (const struct dss__DeviceGetZoneIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetName:
		soap_serialize_dss__DeviceGetName(soap, (const struct dss__DeviceGetName *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		soap_serialize_dss__DeviceGetNameResponse(soap, (const struct dss__DeviceGetNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSaveScene:
		soap_serialize_dss__DeviceSaveScene(soap, (const struct dss__DeviceSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		soap_serialize_dss__DeviceSaveSceneResponse(soap, (const struct dss__DeviceSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceCallScene:
		soap_serialize_dss__DeviceCallScene(soap, (const struct dss__DeviceCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		soap_serialize_dss__DeviceCallSceneResponse(soap, (const struct dss__DeviceCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetValue:
		soap_serialize_dss__DeviceGetValue(soap, (const struct dss__DeviceGetValue *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceGetValueResponse:
		soap_serialize_dss__DeviceGetValueResponse(soap, (const struct dss__DeviceGetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetValue:
		soap_serialize_dss__DeviceSetValue(soap, (const struct dss__DeviceSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		soap_serialize_dss__DeviceSetValueResponse(soap, (const struct dss__DeviceSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceEndDim:
		soap_serialize_dss__DeviceEndDim(soap, (const struct dss__DeviceEndDim *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceEndDimResponse:
		soap_serialize_dss__DeviceEndDimResponse(soap, (const struct dss__DeviceEndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceStartDim:
		soap_serialize_dss__DeviceStartDim(soap, (const struct dss__DeviceStartDim *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceStartDimResponse:
		soap_serialize_dss__DeviceStartDimResponse(soap, (const struct dss__DeviceStartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceDisable:
		soap_serialize_dss__DeviceDisable(soap, (const struct dss__DeviceDisable *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceDisableResponse:
		soap_serialize_dss__DeviceDisableResponse(soap, (const struct dss__DeviceDisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceEnable:
		soap_serialize_dss__DeviceEnable(soap, (const struct dss__DeviceEnable *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceEnableResponse:
		soap_serialize_dss__DeviceEnableResponse(soap, (const struct dss__DeviceEnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		soap_serialize_dss__DeviceDecreaseValue(soap, (const struct dss__DeviceDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		soap_serialize_dss__DeviceDecreaseValueResponse(soap, (const struct dss__DeviceDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		soap_serialize_dss__DeviceIncreaseValue(soap, (const struct dss__DeviceIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		soap_serialize_dss__DeviceIncreaseValueResponse(soap, (const struct dss__DeviceIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOff:
		soap_serialize_dss__DeviceTurnOff(soap, (const struct dss__DeviceTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		soap_serialize_dss__DeviceTurnOffResponse(soap, (const struct dss__DeviceTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOn:
		soap_serialize_dss__DeviceTurnOn(soap, (const struct dss__DeviceTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		soap_serialize_dss__DeviceTurnOnResponse(soap, (const struct dss__DeviceTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSaveScene:
		soap_serialize_dss__ZoneSaveScene(soap, (const struct dss__ZoneSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		soap_serialize_dss__ZoneSaveSceneResponse(soap, (const struct dss__ZoneSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneCallScene:
		soap_serialize_dss__ZoneCallScene(soap, (const struct dss__ZoneCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		soap_serialize_dss__ZoneCallSceneResponse(soap, (const struct dss__ZoneCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSetValue:
		soap_serialize_dss__ZoneSetValue(soap, (const struct dss__ZoneSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		soap_serialize_dss__ZoneSetValueResponse(soap, (const struct dss__ZoneSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneEndDim:
		soap_serialize_dss__ZoneEndDim(soap, (const struct dss__ZoneEndDim *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneEndDimResponse:
		soap_serialize_dss__ZoneEndDimResponse(soap, (const struct dss__ZoneEndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneStartDim:
		soap_serialize_dss__ZoneStartDim(soap, (const struct dss__ZoneStartDim *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneStartDimResponse:
		soap_serialize_dss__ZoneStartDimResponse(soap, (const struct dss__ZoneStartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneDisable:
		soap_serialize_dss__ZoneDisable(soap, (const struct dss__ZoneDisable *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneDisableResponse:
		soap_serialize_dss__ZoneDisableResponse(soap, (const struct dss__ZoneDisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneEnable:
		soap_serialize_dss__ZoneEnable(soap, (const struct dss__ZoneEnable *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneEnableResponse:
		soap_serialize_dss__ZoneEnableResponse(soap, (const struct dss__ZoneEnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		soap_serialize_dss__ZoneDecreaseValue(soap, (const struct dss__ZoneDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		soap_serialize_dss__ZoneDecreaseValueResponse(soap, (const struct dss__ZoneDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		soap_serialize_dss__ZoneIncreaseValue(soap, (const struct dss__ZoneIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		soap_serialize_dss__ZoneIncreaseValueResponse(soap, (const struct dss__ZoneIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOff:
		soap_serialize_dss__ZoneTurnOff(soap, (const struct dss__ZoneTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		soap_serialize_dss__ZoneTurnOffResponse(soap, (const struct dss__ZoneTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOn:
		soap_serialize_dss__ZoneTurnOn(soap, (const struct dss__ZoneTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		soap_serialize_dss__ZoneTurnOnResponse(soap, (const struct dss__ZoneTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__CircuitRescan:
		soap_serialize_dss__CircuitRescan(soap, (const struct dss__CircuitRescan *)ptr);
		break;
	case SOAP_TYPE_dss__CircuitRescanResponse:
		soap_serialize_dss__CircuitRescanResponse(soap, (const struct dss__CircuitRescanResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentRescan:
		soap_serialize_dss__ApartmentRescan(soap, (const struct dss__ApartmentRescan *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		soap_serialize_dss__ApartmentRescanResponse(soap, (const struct dss__ApartmentRescanResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSaveScene:
		soap_serialize_dss__ApartmentSaveScene(soap, (const struct dss__ApartmentSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		soap_serialize_dss__ApartmentSaveSceneResponse(soap, (const struct dss__ApartmentSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCallScene:
		soap_serialize_dss__ApartmentCallScene(soap, (const struct dss__ApartmentCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		soap_serialize_dss__ApartmentCallSceneResponse(soap, (const struct dss__ApartmentCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSetValue:
		soap_serialize_dss__ApartmentSetValue(soap, (const struct dss__ApartmentSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		soap_serialize_dss__ApartmentSetValueResponse(soap, (const struct dss__ApartmentSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentEndDim:
		soap_serialize_dss__ApartmentEndDim(soap, (const struct dss__ApartmentEndDim *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentEndDimResponse:
		soap_serialize_dss__ApartmentEndDimResponse(soap, (const struct dss__ApartmentEndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentStartDim:
		soap_serialize_dss__ApartmentStartDim(soap, (const struct dss__ApartmentStartDim *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentStartDimResponse:
		soap_serialize_dss__ApartmentStartDimResponse(soap, (const struct dss__ApartmentStartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDisable:
		soap_serialize_dss__ApartmentDisable(soap, (const struct dss__ApartmentDisable *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDisableResponse:
		soap_serialize_dss__ApartmentDisableResponse(soap, (const struct dss__ApartmentDisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentEnable:
		soap_serialize_dss__ApartmentEnable(soap, (const struct dss__ApartmentEnable *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentEnableResponse:
		soap_serialize_dss__ApartmentEnableResponse(soap, (const struct dss__ApartmentEnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		soap_serialize_dss__ApartmentDecreaseValue(soap, (const struct dss__ApartmentDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		soap_serialize_dss__ApartmentDecreaseValueResponse(soap, (const struct dss__ApartmentDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		soap_serialize_dss__ApartmentIncreaseValue(soap, (const struct dss__ApartmentIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		soap_serialize_dss__ApartmentIncreaseValueResponse(soap, (const struct dss__ApartmentIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOff:
		soap_serialize_dss__ApartmentTurnOff(soap, (const struct dss__ApartmentTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		soap_serialize_dss__ApartmentTurnOffResponse(soap, (const struct dss__ApartmentTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOn:
		soap_serialize_dss__ApartmentTurnOn(soap, (const struct dss__ApartmentTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		soap_serialize_dss__ApartmentTurnOnResponse(soap, (const struct dss__ApartmentTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetSaveScene:
		soap_serialize_dss__SetSaveScene(soap, (const struct dss__SetSaveScene *)ptr);
		break;
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		soap_serialize_dss__SetSaveSceneResponse(soap, (const struct dss__SetSaveSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetCallScene:
		soap_serialize_dss__SetCallScene(soap, (const struct dss__SetCallScene *)ptr);
		break;
	case SOAP_TYPE_dss__SetCallSceneResponse:
		soap_serialize_dss__SetCallSceneResponse(soap, (const struct dss__SetCallSceneResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetSetValue:
		soap_serialize_dss__SetSetValue(soap, (const struct dss__SetSetValue *)ptr);
		break;
	case SOAP_TYPE_dss__SetSetValueResponse:
		soap_serialize_dss__SetSetValueResponse(soap, (const struct dss__SetSetValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetEndDim:
		soap_serialize_dss__SetEndDim(soap, (const struct dss__SetEndDim *)ptr);
		break;
	case SOAP_TYPE_dss__SetEndDimResponse:
		soap_serialize_dss__SetEndDimResponse(soap, (const struct dss__SetEndDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetStartDim:
		soap_serialize_dss__SetStartDim(soap, (const struct dss__SetStartDim *)ptr);
		break;
	case SOAP_TYPE_dss__SetStartDimResponse:
		soap_serialize_dss__SetStartDimResponse(soap, (const struct dss__SetStartDimResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetDisable:
		soap_serialize_dss__SetDisable(soap, (const struct dss__SetDisable *)ptr);
		break;
	case SOAP_TYPE_dss__SetDisableResponse:
		soap_serialize_dss__SetDisableResponse(soap, (const struct dss__SetDisableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetEnable:
		soap_serialize_dss__SetEnable(soap, (const struct dss__SetEnable *)ptr);
		break;
	case SOAP_TYPE_dss__SetEnableResponse:
		soap_serialize_dss__SetEnableResponse(soap, (const struct dss__SetEnableResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetDecreaseValue:
		soap_serialize_dss__SetDecreaseValue(soap, (const struct dss__SetDecreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		soap_serialize_dss__SetDecreaseValueResponse(soap, (const struct dss__SetDecreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetIncreaseValue:
		soap_serialize_dss__SetIncreaseValue(soap, (const struct dss__SetIncreaseValue *)ptr);
		break;
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		soap_serialize_dss__SetIncreaseValueResponse(soap, (const struct dss__SetIncreaseValueResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOff:
		soap_serialize_dss__SetTurnOff(soap, (const struct dss__SetTurnOff *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOffResponse:
		soap_serialize_dss__SetTurnOffResponse(soap, (const struct dss__SetTurnOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOn:
		soap_serialize_dss__SetTurnOn(soap, (const struct dss__SetTurnOn *)ptr);
		break;
	case SOAP_TYPE_dss__SetTurnOnResponse:
		soap_serialize_dss__SetTurnOnResponse(soap, (const struct dss__SetTurnOnResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		soap_serialize_dss__ApartmentGetZoneIDs(soap, (const struct dss__ApartmentGetZoneIDs *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		soap_serialize_dss__ApartmentGetZoneIDsResponse(soap, (const struct dss__ApartmentGetZoneIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		soap_serialize_dss__ApartmentGetZoneByName(soap, (const struct dss__ApartmentGetZoneByName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		soap_serialize_dss__ApartmentGetZoneByNameResponse(soap, (const struct dss__ApartmentGetZoneByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		soap_serialize_dss__ApartmentGetGroupByName(soap, (const struct dss__ApartmentGetGroupByName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		soap_serialize_dss__ApartmentGetGroupByNameResponse(soap, (const struct dss__ApartmentGetGroupByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetGetContainedDevices:
		soap_serialize_dss__SetGetContainedDevices(soap, (const struct dss__SetGetContainedDevices *)ptr);
		break;
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		soap_serialize_dss__SetGetContainedDevicesResponse(soap, (const struct dss__SetGetContainedDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetByGroup:
		soap_serialize_dss__SetByGroup(soap, (const struct dss__SetByGroup *)ptr);
		break;
	case SOAP_TYPE_dss__SetByGroupResponse:
		soap_serialize_dss__SetByGroupResponse(soap, (const struct dss__SetByGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemove:
		soap_serialize_dss__SetRemove(soap, (const struct dss__SetRemove *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemoveResponse:
		soap_serialize_dss__SetRemoveResponse(soap, (const struct dss__SetRemoveResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetCombine:
		soap_serialize_dss__SetCombine(soap, (const struct dss__SetCombine *)ptr);
		break;
	case SOAP_TYPE_dss__SetCombineResponse:
		soap_serialize_dss__SetCombineResponse(soap, (const struct dss__SetCombineResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemoveDevice:
		soap_serialize_dss__SetRemoveDevice(soap, (const struct dss__SetRemoveDevice *)ptr);
		break;
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		soap_serialize_dss__SetRemoveDeviceResponse(soap, (const struct dss__SetRemoveDeviceResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByID:
		soap_serialize_dss__SetAddDeviceByID(soap, (const struct dss__SetAddDeviceByID *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		soap_serialize_dss__SetAddDeviceByIDResponse(soap, (const struct dss__SetAddDeviceByIDResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByName:
		soap_serialize_dss__SetAddDeviceByName(soap, (const struct dss__SetAddDeviceByName *)ptr);
		break;
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		soap_serialize_dss__SetAddDeviceByNameResponse(soap, (const struct dss__SetAddDeviceByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		soap_serialize_dss__ApartmentGetDeviceIDByName(soap, (const struct dss__ApartmentGetDeviceIDByName *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		soap_serialize_dss__ApartmentGetDeviceIDByNameResponse(soap, (const struct dss__ApartmentGetDeviceIDByNameResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDevices:
		soap_serialize_dss__ApartmentGetDevices(soap, (const struct dss__ApartmentGetDevices *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		soap_serialize_dss__ApartmentGetDevicesResponse(soap, (const struct dss__ApartmentGetDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		soap_serialize_dss__ApartmentCreateSetFromDeviceNames(soap, (const struct dss__ApartmentCreateSetFromDeviceNames *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		soap_serialize_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, (const struct dss__ApartmentCreateSetFromDeviceNamesResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		soap_serialize_dss__ApartmentCreateSetFromDeviceIDs(soap, (const struct dss__ApartmentCreateSetFromDeviceIDs *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		soap_serialize_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, (const struct dss__ApartmentCreateSetFromDeviceIDsResponse *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		soap_serialize_dss__ApartmentCreateSetFromGroup(soap, (const struct dss__ApartmentCreateSetFromGroup *)ptr);
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		soap_serialize_dss__ApartmentCreateSetFromGroupResponse(soap, (const struct dss__ApartmentCreateSetFromGroupResponse *)ptr);
		break;
	case SOAP_TYPE_dss__SignOff:
		soap_serialize_dss__SignOff(soap, (const struct dss__SignOff *)ptr);
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		soap_serialize_dss__SignOffResponse(soap, (const struct dss__SignOffResponse *)ptr);
		break;
	case SOAP_TYPE_dss__Authenticate:
		soap_serialize_dss__Authenticate(soap, (const struct dss__Authenticate *)ptr);
		break;
	case SOAP_TYPE_dss__AuthenticateResponse:
		soap_serialize_dss__AuthenticateResponse(soap, (const struct dss__AuthenticateResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_dss__AuthenticateResponse:
		return (void*)soap_instantiate_dss__AuthenticateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Authenticate:
		return (void*)soap_instantiate_dss__Authenticate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOffResponse:
		return (void*)soap_instantiate_dss__SignOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SignOff:
		return (void*)soap_instantiate_dss__SignOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		return (void*)soap_instantiate_dss__ApartmentCreateSetFromDeviceNames(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		return (void*)soap_instantiate_dss__ApartmentGetDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDevices:
		return (void*)soap_instantiate_dss__ApartmentGetDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		return (void*)soap_instantiate_dss__ApartmentGetDeviceIDByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		return (void*)soap_instantiate_dss__ApartmentGetDeviceIDByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		return (void*)soap_instantiate_dss__SetAddDeviceByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByName:
		return (void*)soap_instantiate_dss__SetAddDeviceByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		return (void*)soap_instantiate_dss__SetAddDeviceByIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetAddDeviceByID:
		return (void*)soap_instantiate_dss__SetAddDeviceByID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		return (void*)soap_instantiate_dss__SetRemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemoveDevice:
		return (void*)soap_instantiate_dss__SetRemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCombineResponse:
		return (void*)soap_instantiate_dss__SetCombineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCombine:
		return (void*)soap_instantiate_dss__SetCombine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemoveResponse:
		return (void*)soap_instantiate_dss__SetRemoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetRemove:
		return (void*)soap_instantiate_dss__SetRemove(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetByGroupResponse:
		return (void*)soap_instantiate_dss__SetByGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetByGroup:
		return (void*)soap_instantiate_dss__SetByGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		return (void*)soap_instantiate_dss__SetGetContainedDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetGetContainedDevices:
		return (void*)soap_instantiate_dss__SetGetContainedDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		return (void*)soap_instantiate_dss__ApartmentGetGroupByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		return (void*)soap_instantiate_dss__ApartmentGetGroupByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		return (void*)soap_instantiate_dss__ApartmentGetZoneByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		return (void*)soap_instantiate_dss__ApartmentGetZoneByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		return (void*)soap_instantiate_dss__ApartmentGetZoneIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		return (void*)soap_instantiate_dss__ApartmentGetZoneIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOnResponse:
		return (void*)soap_instantiate_dss__SetTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOn:
		return (void*)soap_instantiate_dss__SetTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOffResponse:
		return (void*)soap_instantiate_dss__SetTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetTurnOff:
		return (void*)soap_instantiate_dss__SetTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		return (void*)soap_instantiate_dss__SetIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetIncreaseValue:
		return (void*)soap_instantiate_dss__SetIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		return (void*)soap_instantiate_dss__SetDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetDecreaseValue:
		return (void*)soap_instantiate_dss__SetDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetEnableResponse:
		return (void*)soap_instantiate_dss__SetEnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetEnable:
		return (void*)soap_instantiate_dss__SetEnable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetDisableResponse:
		return (void*)soap_instantiate_dss__SetDisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetDisable:
		return (void*)soap_instantiate_dss__SetDisable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetStartDimResponse:
		return (void*)soap_instantiate_dss__SetStartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetStartDim:
		return (void*)soap_instantiate_dss__SetStartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetEndDimResponse:
		return (void*)soap_instantiate_dss__SetEndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetEndDim:
		return (void*)soap_instantiate_dss__SetEndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSetValueResponse:
		return (void*)soap_instantiate_dss__SetSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSetValue:
		return (void*)soap_instantiate_dss__SetSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCallSceneResponse:
		return (void*)soap_instantiate_dss__SetCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetCallScene:
		return (void*)soap_instantiate_dss__SetCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		return (void*)soap_instantiate_dss__SetSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SetSaveScene:
		return (void*)soap_instantiate_dss__SetSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		return (void*)soap_instantiate_dss__ApartmentTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOn:
		return (void*)soap_instantiate_dss__ApartmentTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		return (void*)soap_instantiate_dss__ApartmentTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentTurnOff:
		return (void*)soap_instantiate_dss__ApartmentTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		return (void*)soap_instantiate_dss__ApartmentIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		return (void*)soap_instantiate_dss__ApartmentIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		return (void*)soap_instantiate_dss__ApartmentDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		return (void*)soap_instantiate_dss__ApartmentDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentEnableResponse:
		return (void*)soap_instantiate_dss__ApartmentEnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentEnable:
		return (void*)soap_instantiate_dss__ApartmentEnable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDisableResponse:
		return (void*)soap_instantiate_dss__ApartmentDisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDisable:
		return (void*)soap_instantiate_dss__ApartmentDisable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentStartDimResponse:
		return (void*)soap_instantiate_dss__ApartmentStartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentStartDim:
		return (void*)soap_instantiate_dss__ApartmentStartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentEndDimResponse:
		return (void*)soap_instantiate_dss__ApartmentEndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentEndDim:
		return (void*)soap_instantiate_dss__ApartmentEndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		return (void*)soap_instantiate_dss__ApartmentSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSetValue:
		return (void*)soap_instantiate_dss__ApartmentSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		return (void*)soap_instantiate_dss__ApartmentCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentCallScene:
		return (void*)soap_instantiate_dss__ApartmentCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		return (void*)soap_instantiate_dss__ApartmentSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentSaveScene:
		return (void*)soap_instantiate_dss__ApartmentSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		return (void*)soap_instantiate_dss__ApartmentRescanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentRescan:
		return (void*)soap_instantiate_dss__ApartmentRescan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__CircuitRescanResponse:
		return (void*)soap_instantiate_dss__CircuitRescanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__CircuitRescan:
		return (void*)soap_instantiate_dss__CircuitRescan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		return (void*)soap_instantiate_dss__ZoneTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOn:
		return (void*)soap_instantiate_dss__ZoneTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		return (void*)soap_instantiate_dss__ZoneTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneTurnOff:
		return (void*)soap_instantiate_dss__ZoneTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		return (void*)soap_instantiate_dss__ZoneIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		return (void*)soap_instantiate_dss__ZoneIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		return (void*)soap_instantiate_dss__ZoneDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		return (void*)soap_instantiate_dss__ZoneDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneEnableResponse:
		return (void*)soap_instantiate_dss__ZoneEnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneEnable:
		return (void*)soap_instantiate_dss__ZoneEnable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneDisableResponse:
		return (void*)soap_instantiate_dss__ZoneDisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneDisable:
		return (void*)soap_instantiate_dss__ZoneDisable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneStartDimResponse:
		return (void*)soap_instantiate_dss__ZoneStartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneStartDim:
		return (void*)soap_instantiate_dss__ZoneStartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneEndDimResponse:
		return (void*)soap_instantiate_dss__ZoneEndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneEndDim:
		return (void*)soap_instantiate_dss__ZoneEndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		return (void*)soap_instantiate_dss__ZoneSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSetValue:
		return (void*)soap_instantiate_dss__ZoneSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		return (void*)soap_instantiate_dss__ZoneCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneCallScene:
		return (void*)soap_instantiate_dss__ZoneCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		return (void*)soap_instantiate_dss__ZoneSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ZoneSaveScene:
		return (void*)soap_instantiate_dss__ZoneSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		return (void*)soap_instantiate_dss__DeviceTurnOnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOn:
		return (void*)soap_instantiate_dss__DeviceTurnOn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		return (void*)soap_instantiate_dss__DeviceTurnOffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceTurnOff:
		return (void*)soap_instantiate_dss__DeviceTurnOff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		return (void*)soap_instantiate_dss__DeviceIncreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		return (void*)soap_instantiate_dss__DeviceIncreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		return (void*)soap_instantiate_dss__DeviceDecreaseValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		return (void*)soap_instantiate_dss__DeviceDecreaseValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceEnableResponse:
		return (void*)soap_instantiate_dss__DeviceEnableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceEnable:
		return (void*)soap_instantiate_dss__DeviceEnable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceDisableResponse:
		return (void*)soap_instantiate_dss__DeviceDisableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceDisable:
		return (void*)soap_instantiate_dss__DeviceDisable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceStartDimResponse:
		return (void*)soap_instantiate_dss__DeviceStartDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceStartDim:
		return (void*)soap_instantiate_dss__DeviceStartDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceEndDimResponse:
		return (void*)soap_instantiate_dss__DeviceEndDimResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceEndDim:
		return (void*)soap_instantiate_dss__DeviceEndDim(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		return (void*)soap_instantiate_dss__DeviceSetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSetValue:
		return (void*)soap_instantiate_dss__DeviceSetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetValueResponse:
		return (void*)soap_instantiate_dss__DeviceGetValueResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetValue:
		return (void*)soap_instantiate_dss__DeviceGetValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		return (void*)soap_instantiate_dss__DeviceCallSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceCallScene:
		return (void*)soap_instantiate_dss__DeviceCallScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		return (void*)soap_instantiate_dss__DeviceSaveSceneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceSaveScene:
		return (void*)soap_instantiate_dss__DeviceSaveScene(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		return (void*)soap_instantiate_dss__DeviceGetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetName:
		return (void*)soap_instantiate_dss__DeviceGetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		return (void*)soap_instantiate_dss__DeviceGetZoneIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetZoneID:
		return (void*)soap_instantiate_dss__DeviceGetZoneID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse:
		return (void*)soap_instantiate_dss__ModulatorGetPowerConsumptionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ModulatorGetPowerConsumption:
		return (void*)soap_instantiate_dss__ModulatorGetPowerConsumption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse:
		return (void*)soap_instantiate_dss__ApartmentGetModulatorIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentGetModulatorIDs:
		return (void*)soap_instantiate_dss__ApartmentGetModulatorIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ModulatorGetNameResponse:
		return (void*)soap_instantiate_dss__ModulatorGetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ModulatorGetName:
		return (void*)soap_instantiate_dss__ModulatorGetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		return (void*)soap_instantiate_dss__ApartmentAllocateZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		return (void*)soap_instantiate_dss__ApartmentAllocateZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		return (void*)soap_instantiate_dss__ApartmentDeleteZoneResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		return (void*)soap_instantiate_dss__ApartmentDeleteZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		return (void*)soap_instantiate_dss__Zone_AddDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_AddDevice:
		return (void*)soap_instantiate_dss__Zone_AddDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		return (void*)soap_instantiate_dss__Zone_RemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		return (void*)soap_instantiate_dss__Zone_RemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		return (void*)soap_instantiate_dss__Zone_SetNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Zone_SetName:
		return (void*)soap_instantiate_dss__Zone_SetName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse:
		return (void*)soap_instantiate_dss__ApartmentAllocateUserGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__ApartmentAllocateUserGroup:
		return (void*)soap_instantiate_dss__ApartmentAllocateUserGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupRemoveUserGroupResponse:
		return (void*)soap_instantiate_dss__GroupRemoveUserGroupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupRemoveUserGroup:
		return (void*)soap_instantiate_dss__GroupRemoveUserGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupAddDeviceResponse:
		return (void*)soap_instantiate_dss__GroupAddDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupAddDevice:
		return (void*)soap_instantiate_dss__GroupAddDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupRemoveDeviceResponse:
		return (void*)soap_instantiate_dss__GroupRemoveDeviceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__GroupRemoveDevice:
		return (void*)soap_instantiate_dss__GroupRemoveDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		return (void*)soap_instantiate_dss__DeviceGetFunctionIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		return (void*)soap_instantiate_dss__DeviceGetFunctionID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SwitchGetGroupIDResponse:
		return (void*)soap_instantiate_dss__SwitchGetGroupIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__SwitchGetGroupID:
		return (void*)soap_instantiate_dss__SwitchGetGroupID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__Event:
		return (void*)soap_instantiate_dss__Event(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventRaiseResponse:
		return (void*)soap_instantiate_dss__EventRaiseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventRaise:
		return (void*)soap_instantiate_dss__EventRaise(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventWaitForResponse:
		return (void*)soap_instantiate_dss__EventWaitForResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventWaitFor:
		return (void*)soap_instantiate_dss__EventWaitFor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		return (void*)soap_instantiate_dss__EventSubscribeToResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__EventSubscribeTo:
		return (void*)soap_instantiate_dss__EventSubscribeTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		return (void*)soap_instantiate_dss__PropertyGetTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetType:
		return (void*)soap_instantiate_dss__PropertyGetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetIntResponse:
		return (void*)soap_instantiate_dss__PropertySetIntResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetInt:
		return (void*)soap_instantiate_dss__PropertySetInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetStringResponse:
		return (void*)soap_instantiate_dss__PropertySetStringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetString:
		return (void*)soap_instantiate_dss__PropertySetString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		return (void*)soap_instantiate_dss__PropertySetBoolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertySetBool:
		return (void*)soap_instantiate_dss__PropertySetBool(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		return (void*)soap_instantiate_dss__PropertyGetIntResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetInt:
		return (void*)soap_instantiate_dss__PropertyGetInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		return (void*)soap_instantiate_dss__PropertyGetStringResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetString:
		return (void*)soap_instantiate_dss__PropertyGetString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		return (void*)soap_instantiate_dss__PropertyGetBoolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetBool:
		return (void*)soap_instantiate_dss__PropertyGetBool(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		return (void*)soap_instantiate_dss__PropertyGetChildrenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_dss__PropertyGetChildren:
		return (void*)soap_instantiate_dss__PropertyGetChildren(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfdss__Event:
		return (void*)soap_instantiate_std__vectorTemplateOfdss__Event(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_dss__AuthenticateResponse:
		if (p->size < 0)
			delete (struct dss__AuthenticateResponse*)p->ptr;
		else
			delete[] (struct dss__AuthenticateResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Authenticate:
		if (p->size < 0)
			delete (struct dss__Authenticate*)p->ptr;
		else
			delete[] (struct dss__Authenticate*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOffResponse:
		if (p->size < 0)
			delete (struct dss__SignOffResponse*)p->ptr;
		else
			delete[] (struct dss__SignOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SignOff:
		if (p->size < 0)
			delete (struct dss__SignOff*)p->ptr;
		else
			delete[] (struct dss__SignOff*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromGroupResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromGroup:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromGroup*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceIDsResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceIDs*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceNamesResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceNamesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames:
		if (p->size < 0)
			delete (struct dss__ApartmentCreateSetFromDeviceNames*)p->ptr;
		else
			delete[] (struct dss__ApartmentCreateSetFromDeviceNames*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDevicesResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDevicesResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDevicesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDevices:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDevices*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDevices*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDeviceIDByNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDeviceIDByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetDeviceIDByName:
		if (p->size < 0)
			delete (struct dss__ApartmentGetDeviceIDByName*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetDeviceIDByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByNameResponse:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByNameResponse*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByName:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByName*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByIDResponse:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByIDResponse*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetAddDeviceByID:
		if (p->size < 0)
			delete (struct dss__SetAddDeviceByID*)p->ptr;
		else
			delete[] (struct dss__SetAddDeviceByID*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__SetRemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__SetRemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemoveDevice:
		if (p->size < 0)
			delete (struct dss__SetRemoveDevice*)p->ptr;
		else
			delete[] (struct dss__SetRemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCombineResponse:
		if (p->size < 0)
			delete (struct dss__SetCombineResponse*)p->ptr;
		else
			delete[] (struct dss__SetCombineResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCombine:
		if (p->size < 0)
			delete (struct dss__SetCombine*)p->ptr;
		else
			delete[] (struct dss__SetCombine*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemoveResponse:
		if (p->size < 0)
			delete (struct dss__SetRemoveResponse*)p->ptr;
		else
			delete[] (struct dss__SetRemoveResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetRemove:
		if (p->size < 0)
			delete (struct dss__SetRemove*)p->ptr;
		else
			delete[] (struct dss__SetRemove*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetByGroupResponse:
		if (p->size < 0)
			delete (struct dss__SetByGroupResponse*)p->ptr;
		else
			delete[] (struct dss__SetByGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetByGroup:
		if (p->size < 0)
			delete (struct dss__SetByGroup*)p->ptr;
		else
			delete[] (struct dss__SetByGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetGetContainedDevicesResponse:
		if (p->size < 0)
			delete (struct dss__SetGetContainedDevicesResponse*)p->ptr;
		else
			delete[] (struct dss__SetGetContainedDevicesResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetGetContainedDevices:
		if (p->size < 0)
			delete (struct dss__SetGetContainedDevices*)p->ptr;
		else
			delete[] (struct dss__SetGetContainedDevices*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetGroupByNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetGroupByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetGroupByName:
		if (p->size < 0)
			delete (struct dss__ApartmentGetGroupByName*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetGroupByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByNameResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneByNameResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneByName:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneByName*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneByName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDsResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneIDsResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetZoneIDs:
		if (p->size < 0)
			delete (struct dss__ApartmentGetZoneIDs*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetZoneIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__SetTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__SetTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOn:
		if (p->size < 0)
			delete (struct dss__SetTurnOn*)p->ptr;
		else
			delete[] (struct dss__SetTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__SetTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__SetTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetTurnOff:
		if (p->size < 0)
			delete (struct dss__SetTurnOff*)p->ptr;
		else
			delete[] (struct dss__SetTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__SetIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__SetIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetIncreaseValue:
		if (p->size < 0)
			delete (struct dss__SetIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__SetIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__SetDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__SetDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetDecreaseValue:
		if (p->size < 0)
			delete (struct dss__SetDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__SetDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetEnableResponse:
		if (p->size < 0)
			delete (struct dss__SetEnableResponse*)p->ptr;
		else
			delete[] (struct dss__SetEnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetEnable:
		if (p->size < 0)
			delete (struct dss__SetEnable*)p->ptr;
		else
			delete[] (struct dss__SetEnable*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetDisableResponse:
		if (p->size < 0)
			delete (struct dss__SetDisableResponse*)p->ptr;
		else
			delete[] (struct dss__SetDisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetDisable:
		if (p->size < 0)
			delete (struct dss__SetDisable*)p->ptr;
		else
			delete[] (struct dss__SetDisable*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetStartDimResponse:
		if (p->size < 0)
			delete (struct dss__SetStartDimResponse*)p->ptr;
		else
			delete[] (struct dss__SetStartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetStartDim:
		if (p->size < 0)
			delete (struct dss__SetStartDim*)p->ptr;
		else
			delete[] (struct dss__SetStartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetEndDimResponse:
		if (p->size < 0)
			delete (struct dss__SetEndDimResponse*)p->ptr;
		else
			delete[] (struct dss__SetEndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetEndDim:
		if (p->size < 0)
			delete (struct dss__SetEndDim*)p->ptr;
		else
			delete[] (struct dss__SetEndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSetValueResponse:
		if (p->size < 0)
			delete (struct dss__SetSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__SetSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSetValue:
		if (p->size < 0)
			delete (struct dss__SetSetValue*)p->ptr;
		else
			delete[] (struct dss__SetSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__SetCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__SetCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetCallScene:
		if (p->size < 0)
			delete (struct dss__SetCallScene*)p->ptr;
		else
			delete[] (struct dss__SetCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__SetSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__SetSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SetSaveScene:
		if (p->size < 0)
			delete (struct dss__SetSaveScene*)p->ptr;
		else
			delete[] (struct dss__SetSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOn:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOn*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentTurnOff:
		if (p->size < 0)
			delete (struct dss__ApartmentTurnOff*)p->ptr;
		else
			delete[] (struct dss__ApartmentTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentIncreaseValue:
		if (p->size < 0)
			delete (struct dss__ApartmentIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__ApartmentIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDecreaseValue:
		if (p->size < 0)
			delete (struct dss__ApartmentDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__ApartmentDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentEnableResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentEnableResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentEnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentEnable:
		if (p->size < 0)
			delete (struct dss__ApartmentEnable*)p->ptr;
		else
			delete[] (struct dss__ApartmentEnable*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDisableResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentDisableResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentDisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDisable:
		if (p->size < 0)
			delete (struct dss__ApartmentDisable*)p->ptr;
		else
			delete[] (struct dss__ApartmentDisable*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentStartDimResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentStartDimResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentStartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentStartDim:
		if (p->size < 0)
			delete (struct dss__ApartmentStartDim*)p->ptr;
		else
			delete[] (struct dss__ApartmentStartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentEndDimResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentEndDimResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentEndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentEndDim:
		if (p->size < 0)
			delete (struct dss__ApartmentEndDim*)p->ptr;
		else
			delete[] (struct dss__ApartmentEndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSetValueResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSetValue:
		if (p->size < 0)
			delete (struct dss__ApartmentSetValue*)p->ptr;
		else
			delete[] (struct dss__ApartmentSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentCallScene:
		if (p->size < 0)
			delete (struct dss__ApartmentCallScene*)p->ptr;
		else
			delete[] (struct dss__ApartmentCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentSaveScene:
		if (p->size < 0)
			delete (struct dss__ApartmentSaveScene*)p->ptr;
		else
			delete[] (struct dss__ApartmentSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentRescanResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentRescanResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentRescanResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentRescan:
		if (p->size < 0)
			delete (struct dss__ApartmentRescan*)p->ptr;
		else
			delete[] (struct dss__ApartmentRescan*)p->ptr;
		break;
	case SOAP_TYPE_dss__CircuitRescanResponse:
		if (p->size < 0)
			delete (struct dss__CircuitRescanResponse*)p->ptr;
		else
			delete[] (struct dss__CircuitRescanResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__CircuitRescan:
		if (p->size < 0)
			delete (struct dss__CircuitRescan*)p->ptr;
		else
			delete[] (struct dss__CircuitRescan*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOn:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOn*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneTurnOff:
		if (p->size < 0)
			delete (struct dss__ZoneTurnOff*)p->ptr;
		else
			delete[] (struct dss__ZoneTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ZoneIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneIncreaseValue:
		if (p->size < 0)
			delete (struct dss__ZoneIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__ZoneIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__ZoneDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneDecreaseValue:
		if (p->size < 0)
			delete (struct dss__ZoneDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__ZoneDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneEnableResponse:
		if (p->size < 0)
			delete (struct dss__ZoneEnableResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneEnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneEnable:
		if (p->size < 0)
			delete (struct dss__ZoneEnable*)p->ptr;
		else
			delete[] (struct dss__ZoneEnable*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneDisableResponse:
		if (p->size < 0)
			delete (struct dss__ZoneDisableResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneDisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneDisable:
		if (p->size < 0)
			delete (struct dss__ZoneDisable*)p->ptr;
		else
			delete[] (struct dss__ZoneDisable*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneStartDimResponse:
		if (p->size < 0)
			delete (struct dss__ZoneStartDimResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneStartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneStartDim:
		if (p->size < 0)
			delete (struct dss__ZoneStartDim*)p->ptr;
		else
			delete[] (struct dss__ZoneStartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneEndDimResponse:
		if (p->size < 0)
			delete (struct dss__ZoneEndDimResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneEndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneEndDim:
		if (p->size < 0)
			delete (struct dss__ZoneEndDim*)p->ptr;
		else
			delete[] (struct dss__ZoneEndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSetValueResponse:
		if (p->size < 0)
			delete (struct dss__ZoneSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSetValue:
		if (p->size < 0)
			delete (struct dss__ZoneSetValue*)p->ptr;
		else
			delete[] (struct dss__ZoneSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__ZoneCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneCallScene:
		if (p->size < 0)
			delete (struct dss__ZoneCallScene*)p->ptr;
		else
			delete[] (struct dss__ZoneCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__ZoneSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__ZoneSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ZoneSaveScene:
		if (p->size < 0)
			delete (struct dss__ZoneSaveScene*)p->ptr;
		else
			delete[] (struct dss__ZoneSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOnResponse:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOnResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOnResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOn:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOn*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOn*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOffResponse:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOffResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOffResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceTurnOff:
		if (p->size < 0)
			delete (struct dss__DeviceTurnOff*)p->ptr;
		else
			delete[] (struct dss__DeviceTurnOff*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__DeviceIncreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceIncreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceIncreaseValue:
		if (p->size < 0)
			delete (struct dss__DeviceIncreaseValue*)p->ptr;
		else
			delete[] (struct dss__DeviceIncreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValueResponse:
		if (p->size < 0)
			delete (struct dss__DeviceDecreaseValueResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceDecreaseValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceDecreaseValue:
		if (p->size < 0)
			delete (struct dss__DeviceDecreaseValue*)p->ptr;
		else
			delete[] (struct dss__DeviceDecreaseValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceEnableResponse:
		if (p->size < 0)
			delete (struct dss__DeviceEnableResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceEnableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceEnable:
		if (p->size < 0)
			delete (struct dss__DeviceEnable*)p->ptr;
		else
			delete[] (struct dss__DeviceEnable*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceDisableResponse:
		if (p->size < 0)
			delete (struct dss__DeviceDisableResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceDisableResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceDisable:
		if (p->size < 0)
			delete (struct dss__DeviceDisable*)p->ptr;
		else
			delete[] (struct dss__DeviceDisable*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceStartDimResponse:
		if (p->size < 0)
			delete (struct dss__DeviceStartDimResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceStartDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceStartDim:
		if (p->size < 0)
			delete (struct dss__DeviceStartDim*)p->ptr;
		else
			delete[] (struct dss__DeviceStartDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceEndDimResponse:
		if (p->size < 0)
			delete (struct dss__DeviceEndDimResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceEndDimResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceEndDim:
		if (p->size < 0)
			delete (struct dss__DeviceEndDim*)p->ptr;
		else
			delete[] (struct dss__DeviceEndDim*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetValueResponse:
		if (p->size < 0)
			delete (struct dss__DeviceSetValueResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceSetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSetValue:
		if (p->size < 0)
			delete (struct dss__DeviceSetValue*)p->ptr;
		else
			delete[] (struct dss__DeviceSetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetValueResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetValueResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetValueResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetValue:
		if (p->size < 0)
			delete (struct dss__DeviceGetValue*)p->ptr;
		else
			delete[] (struct dss__DeviceGetValue*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceCallSceneResponse:
		if (p->size < 0)
			delete (struct dss__DeviceCallSceneResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceCallSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceCallScene:
		if (p->size < 0)
			delete (struct dss__DeviceCallScene*)p->ptr;
		else
			delete[] (struct dss__DeviceCallScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSaveSceneResponse:
		if (p->size < 0)
			delete (struct dss__DeviceSaveSceneResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceSaveSceneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceSaveScene:
		if (p->size < 0)
			delete (struct dss__DeviceSaveScene*)p->ptr;
		else
			delete[] (struct dss__DeviceSaveScene*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetNameResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetNameResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetName:
		if (p->size < 0)
			delete (struct dss__DeviceGetName*)p->ptr;
		else
			delete[] (struct dss__DeviceGetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetZoneIDResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetZoneIDResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetZoneIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetZoneID:
		if (p->size < 0)
			delete (struct dss__DeviceGetZoneID*)p->ptr;
		else
			delete[] (struct dss__DeviceGetZoneID*)p->ptr;
		break;
	case SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse:
		if (p->size < 0)
			delete (struct dss__ModulatorGetPowerConsumptionResponse*)p->ptr;
		else
			delete[] (struct dss__ModulatorGetPowerConsumptionResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ModulatorGetPowerConsumption:
		if (p->size < 0)
			delete (struct dss__ModulatorGetPowerConsumption*)p->ptr;
		else
			delete[] (struct dss__ModulatorGetPowerConsumption*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentGetModulatorIDsResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetModulatorIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentGetModulatorIDs:
		if (p->size < 0)
			delete (struct dss__ApartmentGetModulatorIDs*)p->ptr;
		else
			delete[] (struct dss__ApartmentGetModulatorIDs*)p->ptr;
		break;
	case SOAP_TYPE_dss__ModulatorGetNameResponse:
		if (p->size < 0)
			delete (struct dss__ModulatorGetNameResponse*)p->ptr;
		else
			delete[] (struct dss__ModulatorGetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ModulatorGetName:
		if (p->size < 0)
			delete (struct dss__ModulatorGetName*)p->ptr;
		else
			delete[] (struct dss__ModulatorGetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZoneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentAllocateZoneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentAllocateZoneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentAllocateZone:
		if (p->size < 0)
			delete (struct dss__ApartmentAllocateZone*)p->ptr;
		else
			delete[] (struct dss__ApartmentAllocateZone*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZoneResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentDeleteZoneResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentDeleteZoneResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentDeleteZone:
		if (p->size < 0)
			delete (struct dss__ApartmentDeleteZone*)p->ptr;
		else
			delete[] (struct dss__ApartmentDeleteZone*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_AddDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Zone_AddDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Zone_AddDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_AddDevice:
		if (p->size < 0)
			delete (struct dss__Zone_AddDevice*)p->ptr;
		else
			delete[] (struct dss__Zone_AddDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_RemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__Zone_RemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__Zone_RemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_RemoveDevice:
		if (p->size < 0)
			delete (struct dss__Zone_RemoveDevice*)p->ptr;
		else
			delete[] (struct dss__Zone_RemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_SetNameResponse:
		if (p->size < 0)
			delete (struct dss__Zone_SetNameResponse*)p->ptr;
		else
			delete[] (struct dss__Zone_SetNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__Zone_SetName:
		if (p->size < 0)
			delete (struct dss__Zone_SetName*)p->ptr;
		else
			delete[] (struct dss__Zone_SetName*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse:
		if (p->size < 0)
			delete (struct dss__ApartmentAllocateUserGroupResponse*)p->ptr;
		else
			delete[] (struct dss__ApartmentAllocateUserGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__ApartmentAllocateUserGroup:
		if (p->size < 0)
			delete (struct dss__ApartmentAllocateUserGroup*)p->ptr;
		else
			delete[] (struct dss__ApartmentAllocateUserGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupRemoveUserGroupResponse:
		if (p->size < 0)
			delete (struct dss__GroupRemoveUserGroupResponse*)p->ptr;
		else
			delete[] (struct dss__GroupRemoveUserGroupResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupRemoveUserGroup:
		if (p->size < 0)
			delete (struct dss__GroupRemoveUserGroup*)p->ptr;
		else
			delete[] (struct dss__GroupRemoveUserGroup*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupAddDeviceResponse:
		if (p->size < 0)
			delete (struct dss__GroupAddDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__GroupAddDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupAddDevice:
		if (p->size < 0)
			delete (struct dss__GroupAddDevice*)p->ptr;
		else
			delete[] (struct dss__GroupAddDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupRemoveDeviceResponse:
		if (p->size < 0)
			delete (struct dss__GroupRemoveDeviceResponse*)p->ptr;
		else
			delete[] (struct dss__GroupRemoveDeviceResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__GroupRemoveDevice:
		if (p->size < 0)
			delete (struct dss__GroupRemoveDevice*)p->ptr;
		else
			delete[] (struct dss__GroupRemoveDevice*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionIDResponse:
		if (p->size < 0)
			delete (struct dss__DeviceGetFunctionIDResponse*)p->ptr;
		else
			delete[] (struct dss__DeviceGetFunctionIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__DeviceGetFunctionID:
		if (p->size < 0)
			delete (struct dss__DeviceGetFunctionID*)p->ptr;
		else
			delete[] (struct dss__DeviceGetFunctionID*)p->ptr;
		break;
	case SOAP_TYPE_dss__SwitchGetGroupIDResponse:
		if (p->size < 0)
			delete (struct dss__SwitchGetGroupIDResponse*)p->ptr;
		else
			delete[] (struct dss__SwitchGetGroupIDResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__SwitchGetGroupID:
		if (p->size < 0)
			delete (struct dss__SwitchGetGroupID*)p->ptr;
		else
			delete[] (struct dss__SwitchGetGroupID*)p->ptr;
		break;
	case SOAP_TYPE_dss__Event:
		if (p->size < 0)
			delete (dss__Event*)p->ptr;
		else
			delete[] (dss__Event*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventRaiseResponse:
		if (p->size < 0)
			delete (struct dss__EventRaiseResponse*)p->ptr;
		else
			delete[] (struct dss__EventRaiseResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventRaise:
		if (p->size < 0)
			delete (struct dss__EventRaise*)p->ptr;
		else
			delete[] (struct dss__EventRaise*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventWaitForResponse:
		if (p->size < 0)
			delete (struct dss__EventWaitForResponse*)p->ptr;
		else
			delete[] (struct dss__EventWaitForResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventWaitFor:
		if (p->size < 0)
			delete (struct dss__EventWaitFor*)p->ptr;
		else
			delete[] (struct dss__EventWaitFor*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventSubscribeToResponse:
		if (p->size < 0)
			delete (struct dss__EventSubscribeToResponse*)p->ptr;
		else
			delete[] (struct dss__EventSubscribeToResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__EventSubscribeTo:
		if (p->size < 0)
			delete (struct dss__EventSubscribeTo*)p->ptr;
		else
			delete[] (struct dss__EventSubscribeTo*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetTypeResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetTypeResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetTypeResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetType:
		if (p->size < 0)
			delete (struct dss__PropertyGetType*)p->ptr;
		else
			delete[] (struct dss__PropertyGetType*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetIntResponse:
		if (p->size < 0)
			delete (struct dss__PropertySetIntResponse*)p->ptr;
		else
			delete[] (struct dss__PropertySetIntResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetInt:
		if (p->size < 0)
			delete (struct dss__PropertySetInt*)p->ptr;
		else
			delete[] (struct dss__PropertySetInt*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetStringResponse:
		if (p->size < 0)
			delete (struct dss__PropertySetStringResponse*)p->ptr;
		else
			delete[] (struct dss__PropertySetStringResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetString:
		if (p->size < 0)
			delete (struct dss__PropertySetString*)p->ptr;
		else
			delete[] (struct dss__PropertySetString*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetBoolResponse:
		if (p->size < 0)
			delete (struct dss__PropertySetBoolResponse*)p->ptr;
		else
			delete[] (struct dss__PropertySetBoolResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertySetBool:
		if (p->size < 0)
			delete (struct dss__PropertySetBool*)p->ptr;
		else
			delete[] (struct dss__PropertySetBool*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetIntResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetIntResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetIntResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetInt:
		if (p->size < 0)
			delete (struct dss__PropertyGetInt*)p->ptr;
		else
			delete[] (struct dss__PropertyGetInt*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetStringResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetStringResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetStringResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetString:
		if (p->size < 0)
			delete (struct dss__PropertyGetString*)p->ptr;
		else
			delete[] (struct dss__PropertyGetString*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetBoolResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetBoolResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetBoolResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetBool:
		if (p->size < 0)
			delete (struct dss__PropertyGetBool*)p->ptr;
		else
			delete[] (struct dss__PropertyGetBool*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetChildrenResponse:
		if (p->size < 0)
			delete (struct dss__PropertyGetChildrenResponse*)p->ptr;
		else
			delete[] (struct dss__PropertyGetChildrenResponse*)p->ptr;
		break;
	case SOAP_TYPE_dss__PropertyGetChildren:
		if (p->size < 0)
			delete (struct dss__PropertyGetChildren*)p->ptr;
		else
			delete[] (struct dss__PropertyGetChildren*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdss__Event:
		if (p->size < 0)
			delete (std::vector<dss__Event >*)p->ptr;
		else
			delete[] (std::vector<dss__Event >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfdss__Event:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<dss__Event >*)p)[len] = *(dss__Event *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedInt(struct soap *soap, unsigned long *a)
{	soap_default_unsignedLong(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedInt(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (soap_out_xsd__unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_xsd__unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap *soap, unsigned long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLong
	*a = SOAP_DEFAULT_unsignedLong;
#else
	*a = (unsigned long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap *soap, const unsigned long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLong);
	if (soap_out_unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap *soap, const char *tag, int id, const unsigned long *a, const char *type)
{
	return soap_outunsignedLong(soap, tag, id, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap *soap, unsigned long *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap *soap, const char *tag, unsigned long *a, const char *type)
{
	return soap_inunsignedLong(soap, tag, a, type, SOAP_TYPE_unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__unsignedLong(struct soap *soap, ULONG64 *a)
{	soap_default_unsignedLONG64(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedLong(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
	if (soap_out_xsd__unsignedLong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_xsd__unsignedLong);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void dss__Event::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__string(soap, &this->dss__Event::name);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->dss__Event::parameter);
}

void dss__Event::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->dss__Event::name);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->dss__Event::parameter);
}

int dss__Event::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_dss__Event);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int dss__Event::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_dss__Event(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Event(struct soap *soap, const char *tag, int id, const dss__Event *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Event), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->dss__Event::name), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "parameter", -1, &(a->dss__Event::parameter), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *dss__Event::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_dss__Event(soap, this, tag, type);
}

SOAP_FMAC3 dss__Event * SOAP_FMAC4 soap_get_dss__Event(struct soap *soap, dss__Event *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Event(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *dss__Event::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_dss__Event(soap, tag, this, type);
}

SOAP_FMAC3 dss__Event * SOAP_FMAC4 soap_in_dss__Event(struct soap *soap, const char *tag, dss__Event *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (dss__Event *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Event, sizeof(dss__Event), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_dss__Event)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (dss__Event *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->dss__Event::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "parameter", &(a->dss__Event::parameter), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (dss__Event *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Event, 0, sizeof(dss__Event), 0, soap_copy_dss__Event);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 dss__Event * SOAP_FMAC6 soap_new_dss__Event(struct soap *soap, int n)
{	return soap_instantiate_dss__Event(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Event(struct soap *soap, dss__Event *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 dss__Event * SOAP_FMAC4 soap_instantiate_dss__Event(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Event(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Event, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new dss__Event;
		if (size)
			*size = sizeof(dss__Event);
	}
	else
	{	cp->ptr = (void*)new dss__Event[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(dss__Event);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (dss__Event*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Event(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying dss__Event %p -> %p\n", q, p));
	*(dss__Event*)p = *(dss__Event*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetChildren(struct soap *soap, struct dss__PropertyGetChildren *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetChildren(struct soap *soap, const struct dss__PropertyGetChildren *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetChildren(struct soap *soap, const struct dss__PropertyGetChildren *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetChildren);
	if (soap_out_dss__PropertyGetChildren(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetChildren(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetChildren *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetChildren), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetChildren * SOAP_FMAC4 soap_get_dss__PropertyGetChildren(struct soap *soap, struct dss__PropertyGetChildren *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetChildren(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetChildren * SOAP_FMAC4 soap_in_dss__PropertyGetChildren(struct soap *soap, const char *tag, struct dss__PropertyGetChildren *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetChildren *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetChildren, sizeof(struct dss__PropertyGetChildren), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetChildren(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetChildren *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetChildren, 0, sizeof(struct dss__PropertyGetChildren), 0, soap_copy_dss__PropertyGetChildren);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetChildren * SOAP_FMAC6 soap_new_dss__PropertyGetChildren(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetChildren(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetChildren(struct soap *soap, struct dss__PropertyGetChildren *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetChildren * SOAP_FMAC4 soap_instantiate_dss__PropertyGetChildren(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetChildren(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetChildren, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetChildren;
		if (size)
			*size = sizeof(struct dss__PropertyGetChildren);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetChildren[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetChildren);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetChildren*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetChildren(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetChildren %p -> %p\n", q, p));
	*(struct dss__PropertyGetChildren*)p = *(struct dss__PropertyGetChildren*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetChildrenResponse(struct soap *soap, struct dss__PropertyGetChildrenResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetChildrenResponse(struct soap *soap, const struct dss__PropertyGetChildrenResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetChildrenResponse(struct soap *soap, const struct dss__PropertyGetChildrenResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetChildrenResponse);
	if (soap_out_dss__PropertyGetChildrenResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetChildrenResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetChildrenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetChildrenResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetChildrenResponse * SOAP_FMAC4 soap_get_dss__PropertyGetChildrenResponse(struct soap *soap, struct dss__PropertyGetChildrenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetChildrenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetChildrenResponse * SOAP_FMAC4 soap_in_dss__PropertyGetChildrenResponse(struct soap *soap, const char *tag, struct dss__PropertyGetChildrenResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetChildrenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetChildrenResponse, sizeof(struct dss__PropertyGetChildrenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetChildrenResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "result", &a->result, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetChildrenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetChildrenResponse, 0, sizeof(struct dss__PropertyGetChildrenResponse), 0, soap_copy_dss__PropertyGetChildrenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetChildrenResponse * SOAP_FMAC6 soap_new_dss__PropertyGetChildrenResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetChildrenResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetChildrenResponse(struct soap *soap, struct dss__PropertyGetChildrenResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetChildrenResponse * SOAP_FMAC4 soap_instantiate_dss__PropertyGetChildrenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetChildrenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetChildrenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetChildrenResponse;
		if (size)
			*size = sizeof(struct dss__PropertyGetChildrenResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetChildrenResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetChildrenResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetChildrenResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetChildrenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetChildrenResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetChildrenResponse*)p = *(struct dss__PropertyGetChildrenResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetBool(struct soap *soap, struct dss__PropertyGetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetBool(struct soap *soap, const struct dss__PropertyGetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetBool(struct soap *soap, const struct dss__PropertyGetBool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetBool);
	if (soap_out_dss__PropertyGetBool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetBool(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetBool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetBool), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetBool * SOAP_FMAC4 soap_get_dss__PropertyGetBool(struct soap *soap, struct dss__PropertyGetBool *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetBool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetBool * SOAP_FMAC4 soap_in_dss__PropertyGetBool(struct soap *soap, const char *tag, struct dss__PropertyGetBool *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetBool *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetBool, sizeof(struct dss__PropertyGetBool), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetBool(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetBool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetBool, 0, sizeof(struct dss__PropertyGetBool), 0, soap_copy_dss__PropertyGetBool);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetBool * SOAP_FMAC6 soap_new_dss__PropertyGetBool(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetBool(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetBool(struct soap *soap, struct dss__PropertyGetBool *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetBool * SOAP_FMAC4 soap_instantiate_dss__PropertyGetBool(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetBool(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetBool, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetBool;
		if (size)
			*size = sizeof(struct dss__PropertyGetBool);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetBool[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetBool);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetBool*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetBool(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetBool %p -> %p\n", q, p));
	*(struct dss__PropertyGetBool*)p = *(struct dss__PropertyGetBool*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetBoolResponse(struct soap *soap, struct dss__PropertyGetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetBoolResponse(struct soap *soap, const struct dss__PropertyGetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetBoolResponse(struct soap *soap, const struct dss__PropertyGetBoolResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetBoolResponse);
	if (soap_out_dss__PropertyGetBoolResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetBoolResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetBoolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetBoolResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetBoolResponse * SOAP_FMAC4 soap_get_dss__PropertyGetBoolResponse(struct soap *soap, struct dss__PropertyGetBoolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetBoolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetBoolResponse * SOAP_FMAC4 soap_in_dss__PropertyGetBoolResponse(struct soap *soap, const char *tag, struct dss__PropertyGetBoolResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetBoolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetBoolResponse, sizeof(struct dss__PropertyGetBoolResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetBoolResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetBoolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetBoolResponse, 0, sizeof(struct dss__PropertyGetBoolResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetBoolResponse * SOAP_FMAC6 soap_new_dss__PropertyGetBoolResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetBoolResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetBoolResponse(struct soap *soap, struct dss__PropertyGetBoolResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetBoolResponse * SOAP_FMAC4 soap_instantiate_dss__PropertyGetBoolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetBoolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetBoolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetBoolResponse;
		if (size)
			*size = sizeof(struct dss__PropertyGetBoolResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetBoolResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetBoolResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetBoolResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetBoolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetBoolResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetBoolResponse*)p = *(struct dss__PropertyGetBoolResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetString(struct soap *soap, struct dss__PropertyGetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetString(struct soap *soap, const struct dss__PropertyGetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetString(struct soap *soap, const struct dss__PropertyGetString *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetString);
	if (soap_out_dss__PropertyGetString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetString(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetString), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetString * SOAP_FMAC4 soap_get_dss__PropertyGetString(struct soap *soap, struct dss__PropertyGetString *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetString * SOAP_FMAC4 soap_in_dss__PropertyGetString(struct soap *soap, const char *tag, struct dss__PropertyGetString *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetString, sizeof(struct dss__PropertyGetString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetString(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetString, 0, sizeof(struct dss__PropertyGetString), 0, soap_copy_dss__PropertyGetString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetString * SOAP_FMAC6 soap_new_dss__PropertyGetString(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetString(struct soap *soap, struct dss__PropertyGetString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetString * SOAP_FMAC4 soap_instantiate_dss__PropertyGetString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetString;
		if (size)
			*size = sizeof(struct dss__PropertyGetString);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetString);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetString*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetString %p -> %p\n", q, p));
	*(struct dss__PropertyGetString*)p = *(struct dss__PropertyGetString*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetStringResponse(struct soap *soap, struct dss__PropertyGetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetStringResponse(struct soap *soap, const struct dss__PropertyGetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetStringResponse(struct soap *soap, const struct dss__PropertyGetStringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetStringResponse);
	if (soap_out_dss__PropertyGetStringResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetStringResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetStringResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetStringResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetStringResponse * SOAP_FMAC4 soap_get_dss__PropertyGetStringResponse(struct soap *soap, struct dss__PropertyGetStringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetStringResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetStringResponse * SOAP_FMAC4 soap_in_dss__PropertyGetStringResponse(struct soap *soap, const char *tag, struct dss__PropertyGetStringResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetStringResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetStringResponse, sizeof(struct dss__PropertyGetStringResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetStringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetStringResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetStringResponse, 0, sizeof(struct dss__PropertyGetStringResponse), 0, soap_copy_dss__PropertyGetStringResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetStringResponse * SOAP_FMAC6 soap_new_dss__PropertyGetStringResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetStringResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetStringResponse(struct soap *soap, struct dss__PropertyGetStringResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetStringResponse * SOAP_FMAC4 soap_instantiate_dss__PropertyGetStringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetStringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetStringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetStringResponse;
		if (size)
			*size = sizeof(struct dss__PropertyGetStringResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetStringResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetStringResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetStringResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetStringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetStringResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetStringResponse*)p = *(struct dss__PropertyGetStringResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetInt(struct soap *soap, struct dss__PropertyGetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetInt(struct soap *soap, const struct dss__PropertyGetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetInt(struct soap *soap, const struct dss__PropertyGetInt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetInt);
	if (soap_out_dss__PropertyGetInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetInt(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetInt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetInt), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetInt * SOAP_FMAC4 soap_get_dss__PropertyGetInt(struct soap *soap, struct dss__PropertyGetInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetInt * SOAP_FMAC4 soap_in_dss__PropertyGetInt(struct soap *soap, const char *tag, struct dss__PropertyGetInt *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetInt, sizeof(struct dss__PropertyGetInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetInt(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetInt, 0, sizeof(struct dss__PropertyGetInt), 0, soap_copy_dss__PropertyGetInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetInt * SOAP_FMAC6 soap_new_dss__PropertyGetInt(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetInt(struct soap *soap, struct dss__PropertyGetInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetInt * SOAP_FMAC4 soap_instantiate_dss__PropertyGetInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetInt;
		if (size)
			*size = sizeof(struct dss__PropertyGetInt);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetInt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetInt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetInt %p -> %p\n", q, p));
	*(struct dss__PropertyGetInt*)p = *(struct dss__PropertyGetInt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetIntResponse(struct soap *soap, struct dss__PropertyGetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetIntResponse(struct soap *soap, const struct dss__PropertyGetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetIntResponse(struct soap *soap, const struct dss__PropertyGetIntResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetIntResponse);
	if (soap_out_dss__PropertyGetIntResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetIntResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetIntResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetIntResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetIntResponse * SOAP_FMAC4 soap_get_dss__PropertyGetIntResponse(struct soap *soap, struct dss__PropertyGetIntResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetIntResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetIntResponse * SOAP_FMAC4 soap_in_dss__PropertyGetIntResponse(struct soap *soap, const char *tag, struct dss__PropertyGetIntResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetIntResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetIntResponse, sizeof(struct dss__PropertyGetIntResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetIntResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetIntResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetIntResponse, 0, sizeof(struct dss__PropertyGetIntResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetIntResponse * SOAP_FMAC6 soap_new_dss__PropertyGetIntResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetIntResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetIntResponse(struct soap *soap, struct dss__PropertyGetIntResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetIntResponse * SOAP_FMAC4 soap_instantiate_dss__PropertyGetIntResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetIntResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetIntResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetIntResponse;
		if (size)
			*size = sizeof(struct dss__PropertyGetIntResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetIntResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetIntResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetIntResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetIntResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetIntResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetIntResponse*)p = *(struct dss__PropertyGetIntResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetBool(struct soap *soap, struct dss__PropertySetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
	soap_default_bool(soap, &a->_value);
	a->_mayCreate = (bool)1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetBool(struct soap *soap, const struct dss__PropertySetBool *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetBool(struct soap *soap, const struct dss__PropertySetBool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetBool);
	if (soap_out_dss__PropertySetBool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetBool(struct soap *soap, const char *tag, int id, const struct dss__PropertySetBool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetBool), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	if (soap_out_bool(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_bool(soap, "mayCreate", -1, &a->_mayCreate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetBool * SOAP_FMAC4 soap_get_dss__PropertySetBool(struct soap *soap, struct dss__PropertySetBool *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetBool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertySetBool * SOAP_FMAC4 soap_in_dss__PropertySetBool(struct soap *soap, const char *tag, struct dss__PropertySetBool *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1, soap_flag__value = 1, soap_flag__mayCreate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetBool *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetBool, sizeof(struct dss__PropertySetBool), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetBool(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_value, "xsd:boolean"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__mayCreate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_mayCreate, "xsd:boolean"))
				{	soap_flag__mayCreate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetBool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetBool, 0, sizeof(struct dss__PropertySetBool), 0, soap_copy_dss__PropertySetBool);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0 || soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertySetBool * SOAP_FMAC6 soap_new_dss__PropertySetBool(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertySetBool(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertySetBool(struct soap *soap, struct dss__PropertySetBool *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertySetBool * SOAP_FMAC4 soap_instantiate_dss__PropertySetBool(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetBool(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetBool, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertySetBool;
		if (size)
			*size = sizeof(struct dss__PropertySetBool);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertySetBool[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetBool);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetBool*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetBool(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetBool %p -> %p\n", q, p));
	*(struct dss__PropertySetBool*)p = *(struct dss__PropertySetBool*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetBoolResponse(struct soap *soap, struct dss__PropertySetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetBoolResponse(struct soap *soap, const struct dss__PropertySetBoolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetBoolResponse(struct soap *soap, const struct dss__PropertySetBoolResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetBoolResponse);
	if (soap_out_dss__PropertySetBoolResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetBoolResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertySetBoolResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetBoolResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetBoolResponse * SOAP_FMAC4 soap_get_dss__PropertySetBoolResponse(struct soap *soap, struct dss__PropertySetBoolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetBoolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertySetBoolResponse * SOAP_FMAC4 soap_in_dss__PropertySetBoolResponse(struct soap *soap, const char *tag, struct dss__PropertySetBoolResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetBoolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetBoolResponse, sizeof(struct dss__PropertySetBoolResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetBoolResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetBoolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetBoolResponse, 0, sizeof(struct dss__PropertySetBoolResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertySetBoolResponse * SOAP_FMAC6 soap_new_dss__PropertySetBoolResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertySetBoolResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertySetBoolResponse(struct soap *soap, struct dss__PropertySetBoolResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertySetBoolResponse * SOAP_FMAC4 soap_instantiate_dss__PropertySetBoolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetBoolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetBoolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertySetBoolResponse;
		if (size)
			*size = sizeof(struct dss__PropertySetBoolResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertySetBoolResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetBoolResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetBoolResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetBoolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetBoolResponse %p -> %p\n", q, p));
	*(struct dss__PropertySetBoolResponse*)p = *(struct dss__PropertySetBoolResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetString(struct soap *soap, struct dss__PropertySetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
	soap_default_string(soap, &a->_value);
	a->_mayCreate = (bool)1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetString(struct soap *soap, const struct dss__PropertySetString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
	soap_serialize_string(soap, &a->_value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetString(struct soap *soap, const struct dss__PropertySetString *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetString);
	if (soap_out_dss__PropertySetString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetString(struct soap *soap, const char *tag, int id, const struct dss__PropertySetString *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetString), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_bool(soap, "mayCreate", -1, &a->_mayCreate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetString * SOAP_FMAC4 soap_get_dss__PropertySetString(struct soap *soap, struct dss__PropertySetString *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertySetString * SOAP_FMAC4 soap_in_dss__PropertySetString(struct soap *soap, const char *tag, struct dss__PropertySetString *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1, soap_flag__value = 1, soap_flag__mayCreate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetString, sizeof(struct dss__PropertySetString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetString(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap_flag__value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_value, "xsd:string"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__mayCreate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_mayCreate, "xsd:boolean"))
				{	soap_flag__mayCreate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetString, 0, sizeof(struct dss__PropertySetString), 0, soap_copy_dss__PropertySetString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertySetString * SOAP_FMAC6 soap_new_dss__PropertySetString(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertySetString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertySetString(struct soap *soap, struct dss__PropertySetString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertySetString * SOAP_FMAC4 soap_instantiate_dss__PropertySetString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertySetString;
		if (size)
			*size = sizeof(struct dss__PropertySetString);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertySetString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetString);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetString*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetString %p -> %p\n", q, p));
	*(struct dss__PropertySetString*)p = *(struct dss__PropertySetString*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetStringResponse(struct soap *soap, struct dss__PropertySetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetStringResponse(struct soap *soap, const struct dss__PropertySetStringResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetStringResponse(struct soap *soap, const struct dss__PropertySetStringResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetStringResponse);
	if (soap_out_dss__PropertySetStringResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetStringResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertySetStringResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetStringResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetStringResponse * SOAP_FMAC4 soap_get_dss__PropertySetStringResponse(struct soap *soap, struct dss__PropertySetStringResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetStringResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertySetStringResponse * SOAP_FMAC4 soap_in_dss__PropertySetStringResponse(struct soap *soap, const char *tag, struct dss__PropertySetStringResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetStringResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetStringResponse, sizeof(struct dss__PropertySetStringResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetStringResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetStringResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetStringResponse, 0, sizeof(struct dss__PropertySetStringResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertySetStringResponse * SOAP_FMAC6 soap_new_dss__PropertySetStringResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertySetStringResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertySetStringResponse(struct soap *soap, struct dss__PropertySetStringResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertySetStringResponse * SOAP_FMAC4 soap_instantiate_dss__PropertySetStringResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetStringResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetStringResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertySetStringResponse;
		if (size)
			*size = sizeof(struct dss__PropertySetStringResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertySetStringResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetStringResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetStringResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetStringResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetStringResponse %p -> %p\n", q, p));
	*(struct dss__PropertySetStringResponse*)p = *(struct dss__PropertySetStringResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetInt(struct soap *soap, struct dss__PropertySetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
	soap_default_int(soap, &a->_value);
	a->_mayCreate = (bool)1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetInt(struct soap *soap, const struct dss__PropertySetInt *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetInt(struct soap *soap, const struct dss__PropertySetInt *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetInt);
	if (soap_out_dss__PropertySetInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetInt(struct soap *soap, const char *tag, int id, const struct dss__PropertySetInt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetInt), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	if (soap_out_int(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_bool(soap, "mayCreate", -1, &a->_mayCreate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetInt * SOAP_FMAC4 soap_get_dss__PropertySetInt(struct soap *soap, struct dss__PropertySetInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertySetInt * SOAP_FMAC4 soap_in_dss__PropertySetInt(struct soap *soap, const char *tag, struct dss__PropertySetInt *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1, soap_flag__value = 1, soap_flag__mayCreate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetInt, sizeof(struct dss__PropertySetInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetInt(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_value, "xsd:int"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__mayCreate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_mayCreate, "xsd:boolean"))
				{	soap_flag__mayCreate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetInt, 0, sizeof(struct dss__PropertySetInt), 0, soap_copy_dss__PropertySetInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0 || soap_flag__value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertySetInt * SOAP_FMAC6 soap_new_dss__PropertySetInt(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertySetInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertySetInt(struct soap *soap, struct dss__PropertySetInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertySetInt * SOAP_FMAC4 soap_instantiate_dss__PropertySetInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertySetInt;
		if (size)
			*size = sizeof(struct dss__PropertySetInt);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertySetInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetInt);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetInt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetInt %p -> %p\n", q, p));
	*(struct dss__PropertySetInt*)p = *(struct dss__PropertySetInt*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertySetIntResponse(struct soap *soap, struct dss__PropertySetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertySetIntResponse(struct soap *soap, const struct dss__PropertySetIntResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertySetIntResponse(struct soap *soap, const struct dss__PropertySetIntResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertySetIntResponse);
	if (soap_out_dss__PropertySetIntResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertySetIntResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertySetIntResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertySetIntResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertySetIntResponse * SOAP_FMAC4 soap_get_dss__PropertySetIntResponse(struct soap *soap, struct dss__PropertySetIntResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertySetIntResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertySetIntResponse * SOAP_FMAC4 soap_in_dss__PropertySetIntResponse(struct soap *soap, const char *tag, struct dss__PropertySetIntResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertySetIntResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertySetIntResponse, sizeof(struct dss__PropertySetIntResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__PropertySetIntResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertySetIntResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertySetIntResponse, 0, sizeof(struct dss__PropertySetIntResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertySetIntResponse * SOAP_FMAC6 soap_new_dss__PropertySetIntResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertySetIntResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertySetIntResponse(struct soap *soap, struct dss__PropertySetIntResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertySetIntResponse * SOAP_FMAC4 soap_instantiate_dss__PropertySetIntResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertySetIntResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertySetIntResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertySetIntResponse;
		if (size)
			*size = sizeof(struct dss__PropertySetIntResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertySetIntResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertySetIntResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertySetIntResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertySetIntResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertySetIntResponse %p -> %p\n", q, p));
	*(struct dss__PropertySetIntResponse*)p = *(struct dss__PropertySetIntResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetType(struct soap *soap, struct dss__PropertyGetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetType(struct soap *soap, const struct dss__PropertyGetType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_propertyName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetType(struct soap *soap, const struct dss__PropertyGetType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetType);
	if (soap_out_dss__PropertyGetType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetType(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetType), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propertyName", -1, &a->_propertyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetType * SOAP_FMAC4 soap_get_dss__PropertyGetType(struct soap *soap, struct dss__PropertyGetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetType * SOAP_FMAC4 soap_in_dss__PropertyGetType(struct soap *soap, const char *tag, struct dss__PropertyGetType *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__propertyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetType, sizeof(struct dss__PropertyGetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__propertyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_propertyName, "xsd:string"))
				{	soap_flag__propertyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetType, 0, sizeof(struct dss__PropertyGetType), 0, soap_copy_dss__PropertyGetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__propertyName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetType * SOAP_FMAC6 soap_new_dss__PropertyGetType(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetType(struct soap *soap, struct dss__PropertyGetType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetType * SOAP_FMAC4 soap_instantiate_dss__PropertyGetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetType;
		if (size)
			*size = sizeof(struct dss__PropertyGetType);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetType %p -> %p\n", q, p));
	*(struct dss__PropertyGetType*)p = *(struct dss__PropertyGetType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__PropertyGetTypeResponse(struct soap *soap, struct dss__PropertyGetTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__PropertyGetTypeResponse(struct soap *soap, const struct dss__PropertyGetTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__PropertyGetTypeResponse(struct soap *soap, const struct dss__PropertyGetTypeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__PropertyGetTypeResponse);
	if (soap_out_dss__PropertyGetTypeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__PropertyGetTypeResponse(struct soap *soap, const char *tag, int id, const struct dss__PropertyGetTypeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__PropertyGetTypeResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__PropertyGetTypeResponse * SOAP_FMAC4 soap_get_dss__PropertyGetTypeResponse(struct soap *soap, struct dss__PropertyGetTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__PropertyGetTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__PropertyGetTypeResponse * SOAP_FMAC4 soap_in_dss__PropertyGetTypeResponse(struct soap *soap, const char *tag, struct dss__PropertyGetTypeResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__PropertyGetTypeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__PropertyGetTypeResponse, sizeof(struct dss__PropertyGetTypeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__PropertyGetTypeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__PropertyGetTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__PropertyGetTypeResponse, 0, sizeof(struct dss__PropertyGetTypeResponse), 0, soap_copy_dss__PropertyGetTypeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__PropertyGetTypeResponse * SOAP_FMAC6 soap_new_dss__PropertyGetTypeResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__PropertyGetTypeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__PropertyGetTypeResponse(struct soap *soap, struct dss__PropertyGetTypeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__PropertyGetTypeResponse * SOAP_FMAC4 soap_instantiate_dss__PropertyGetTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__PropertyGetTypeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__PropertyGetTypeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__PropertyGetTypeResponse;
		if (size)
			*size = sizeof(struct dss__PropertyGetTypeResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__PropertyGetTypeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__PropertyGetTypeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__PropertyGetTypeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__PropertyGetTypeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__PropertyGetTypeResponse %p -> %p\n", q, p));
	*(struct dss__PropertyGetTypeResponse*)p = *(struct dss__PropertyGetTypeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventSubscribeTo(struct soap *soap, struct dss__EventSubscribeTo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventSubscribeTo(struct soap *soap, const struct dss__EventSubscribeTo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventSubscribeTo(struct soap *soap, const struct dss__EventSubscribeTo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventSubscribeTo);
	if (soap_out_dss__EventSubscribeTo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventSubscribeTo(struct soap *soap, const char *tag, int id, const struct dss__EventSubscribeTo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventSubscribeTo), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventSubscribeTo * SOAP_FMAC4 soap_get_dss__EventSubscribeTo(struct soap *soap, struct dss__EventSubscribeTo *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventSubscribeTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__EventSubscribeTo * SOAP_FMAC4 soap_in_dss__EventSubscribeTo(struct soap *soap, const char *tag, struct dss__EventSubscribeTo *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventSubscribeTo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventSubscribeTo, sizeof(struct dss__EventSubscribeTo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__EventSubscribeTo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventSubscribeTo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventSubscribeTo, 0, sizeof(struct dss__EventSubscribeTo), 0, soap_copy_dss__EventSubscribeTo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__EventSubscribeTo * SOAP_FMAC6 soap_new_dss__EventSubscribeTo(struct soap *soap, int n)
{	return soap_instantiate_dss__EventSubscribeTo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__EventSubscribeTo(struct soap *soap, struct dss__EventSubscribeTo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__EventSubscribeTo * SOAP_FMAC4 soap_instantiate_dss__EventSubscribeTo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventSubscribeTo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventSubscribeTo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__EventSubscribeTo;
		if (size)
			*size = sizeof(struct dss__EventSubscribeTo);
	}
	else
	{	cp->ptr = (void*)new struct dss__EventSubscribeTo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventSubscribeTo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventSubscribeTo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventSubscribeTo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventSubscribeTo %p -> %p\n", q, p));
	*(struct dss__EventSubscribeTo*)p = *(struct dss__EventSubscribeTo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventSubscribeToResponse(struct soap *soap, struct dss__EventSubscribeToResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventSubscribeToResponse(struct soap *soap, const struct dss__EventSubscribeToResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventSubscribeToResponse(struct soap *soap, const struct dss__EventSubscribeToResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventSubscribeToResponse);
	if (soap_out_dss__EventSubscribeToResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventSubscribeToResponse(struct soap *soap, const char *tag, int id, const struct dss__EventSubscribeToResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventSubscribeToResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventSubscribeToResponse * SOAP_FMAC4 soap_get_dss__EventSubscribeToResponse(struct soap *soap, struct dss__EventSubscribeToResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventSubscribeToResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__EventSubscribeToResponse * SOAP_FMAC4 soap_in_dss__EventSubscribeToResponse(struct soap *soap, const char *tag, struct dss__EventSubscribeToResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventSubscribeToResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventSubscribeToResponse, sizeof(struct dss__EventSubscribeToResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__EventSubscribeToResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventSubscribeToResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventSubscribeToResponse, 0, sizeof(struct dss__EventSubscribeToResponse), 0, soap_copy_dss__EventSubscribeToResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__EventSubscribeToResponse * SOAP_FMAC6 soap_new_dss__EventSubscribeToResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__EventSubscribeToResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__EventSubscribeToResponse(struct soap *soap, struct dss__EventSubscribeToResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__EventSubscribeToResponse * SOAP_FMAC4 soap_instantiate_dss__EventSubscribeToResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventSubscribeToResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventSubscribeToResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__EventSubscribeToResponse;
		if (size)
			*size = sizeof(struct dss__EventSubscribeToResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__EventSubscribeToResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventSubscribeToResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventSubscribeToResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventSubscribeToResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventSubscribeToResponse %p -> %p\n", q, p));
	*(struct dss__EventSubscribeToResponse*)p = *(struct dss__EventSubscribeToResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventWaitFor(struct soap *soap, struct dss__EventWaitFor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_timeout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventWaitFor(struct soap *soap, const struct dss__EventWaitFor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventWaitFor(struct soap *soap, const struct dss__EventWaitFor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventWaitFor);
	if (soap_out_dss__EventWaitFor(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventWaitFor(struct soap *soap, const char *tag, int id, const struct dss__EventWaitFor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventWaitFor), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "timeout", -1, &a->_timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventWaitFor * SOAP_FMAC4 soap_get_dss__EventWaitFor(struct soap *soap, struct dss__EventWaitFor *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventWaitFor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__EventWaitFor * SOAP_FMAC4 soap_in_dss__EventWaitFor(struct soap *soap, const char *tag, struct dss__EventWaitFor *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__timeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventWaitFor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventWaitFor, sizeof(struct dss__EventWaitFor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__EventWaitFor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_timeout, "xsd:int"))
				{	soap_flag__timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventWaitFor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventWaitFor, 0, sizeof(struct dss__EventWaitFor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__timeout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__EventWaitFor * SOAP_FMAC6 soap_new_dss__EventWaitFor(struct soap *soap, int n)
{	return soap_instantiate_dss__EventWaitFor(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__EventWaitFor(struct soap *soap, struct dss__EventWaitFor *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__EventWaitFor * SOAP_FMAC4 soap_instantiate_dss__EventWaitFor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventWaitFor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventWaitFor, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__EventWaitFor;
		if (size)
			*size = sizeof(struct dss__EventWaitFor);
	}
	else
	{	cp->ptr = (void*)new struct dss__EventWaitFor[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventWaitFor);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventWaitFor*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventWaitFor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventWaitFor %p -> %p\n", q, p));
	*(struct dss__EventWaitFor*)p = *(struct dss__EventWaitFor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventWaitForResponse(struct soap *soap, struct dss__EventWaitForResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfdss__Event(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventWaitForResponse(struct soap *soap, const struct dss__EventWaitForResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdss__Event(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventWaitForResponse(struct soap *soap, const struct dss__EventWaitForResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventWaitForResponse);
	if (soap_out_dss__EventWaitForResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventWaitForResponse(struct soap *soap, const char *tag, int id, const struct dss__EventWaitForResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventWaitForResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfdss__Event(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventWaitForResponse * SOAP_FMAC4 soap_get_dss__EventWaitForResponse(struct soap *soap, struct dss__EventWaitForResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventWaitForResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__EventWaitForResponse * SOAP_FMAC4 soap_in_dss__EventWaitForResponse(struct soap *soap, const char *tag, struct dss__EventWaitForResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventWaitForResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventWaitForResponse, sizeof(struct dss__EventWaitForResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__EventWaitForResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdss__Event(soap, "result", &a->result, "dss:Event"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventWaitForResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventWaitForResponse, 0, sizeof(struct dss__EventWaitForResponse), 0, soap_copy_dss__EventWaitForResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__EventWaitForResponse * SOAP_FMAC6 soap_new_dss__EventWaitForResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__EventWaitForResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__EventWaitForResponse(struct soap *soap, struct dss__EventWaitForResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__EventWaitForResponse * SOAP_FMAC4 soap_instantiate_dss__EventWaitForResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventWaitForResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventWaitForResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__EventWaitForResponse;
		if (size)
			*size = sizeof(struct dss__EventWaitForResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__EventWaitForResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventWaitForResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventWaitForResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventWaitForResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventWaitForResponse %p -> %p\n", q, p));
	*(struct dss__EventWaitForResponse*)p = *(struct dss__EventWaitForResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventRaise(struct soap *soap, struct dss__EventRaise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_eventName);
	soap_default_string(soap, &a->_context);
	soap_default_string(soap, &a->_parameter);
	soap_default_string(soap, &a->_location);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventRaise(struct soap *soap, const struct dss__EventRaise *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_eventName);
	soap_serialize_string(soap, &a->_context);
	soap_serialize_string(soap, &a->_parameter);
	soap_serialize_string(soap, &a->_location);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventRaise(struct soap *soap, const struct dss__EventRaise *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventRaise);
	if (soap_out_dss__EventRaise(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventRaise(struct soap *soap, const char *tag, int id, const struct dss__EventRaise *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventRaise), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "eventName", -1, &a->_eventName, ""))
		return soap->error;
	if (soap_out_string(soap, "context", -1, &a->_context, ""))
		return soap->error;
	if (soap_out_string(soap, "parameter", -1, &a->_parameter, ""))
		return soap->error;
	if (soap_out_string(soap, "location", -1, &a->_location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventRaise * SOAP_FMAC4 soap_get_dss__EventRaise(struct soap *soap, struct dss__EventRaise *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventRaise(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__EventRaise * SOAP_FMAC4 soap_in_dss__EventRaise(struct soap *soap, const char *tag, struct dss__EventRaise *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__eventName = 1, soap_flag__context = 1, soap_flag__parameter = 1, soap_flag__location = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventRaise *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventRaise, sizeof(struct dss__EventRaise), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__EventRaise(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__eventName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_eventName, "xsd:string"))
				{	soap_flag__eventName--;
					continue;
				}
			if (soap_flag__context && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_context, "xsd:string"))
				{	soap_flag__context--;
					continue;
				}
			if (soap_flag__parameter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_parameter, "xsd:string"))
				{	soap_flag__parameter--;
					continue;
				}
			if (soap_flag__location && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_location, "xsd:string"))
				{	soap_flag__location--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventRaise *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventRaise, 0, sizeof(struct dss__EventRaise), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__EventRaise * SOAP_FMAC6 soap_new_dss__EventRaise(struct soap *soap, int n)
{	return soap_instantiate_dss__EventRaise(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__EventRaise(struct soap *soap, struct dss__EventRaise *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__EventRaise * SOAP_FMAC4 soap_instantiate_dss__EventRaise(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventRaise(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventRaise, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__EventRaise;
		if (size)
			*size = sizeof(struct dss__EventRaise);
	}
	else
	{	cp->ptr = (void*)new struct dss__EventRaise[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventRaise);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventRaise*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventRaise(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventRaise %p -> %p\n", q, p));
	*(struct dss__EventRaise*)p = *(struct dss__EventRaise*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__EventRaiseResponse(struct soap *soap, struct dss__EventRaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__EventRaiseResponse(struct soap *soap, const struct dss__EventRaiseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__EventRaiseResponse(struct soap *soap, const struct dss__EventRaiseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__EventRaiseResponse);
	if (soap_out_dss__EventRaiseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__EventRaiseResponse(struct soap *soap, const char *tag, int id, const struct dss__EventRaiseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__EventRaiseResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__EventRaiseResponse * SOAP_FMAC4 soap_get_dss__EventRaiseResponse(struct soap *soap, struct dss__EventRaiseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__EventRaiseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__EventRaiseResponse * SOAP_FMAC4 soap_in_dss__EventRaiseResponse(struct soap *soap, const char *tag, struct dss__EventRaiseResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__EventRaiseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__EventRaiseResponse, sizeof(struct dss__EventRaiseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__EventRaiseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__EventRaiseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__EventRaiseResponse, 0, sizeof(struct dss__EventRaiseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__EventRaiseResponse * SOAP_FMAC6 soap_new_dss__EventRaiseResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__EventRaiseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__EventRaiseResponse(struct soap *soap, struct dss__EventRaiseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__EventRaiseResponse * SOAP_FMAC4 soap_instantiate_dss__EventRaiseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__EventRaiseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__EventRaiseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__EventRaiseResponse;
		if (size)
			*size = sizeof(struct dss__EventRaiseResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__EventRaiseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__EventRaiseResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__EventRaiseResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__EventRaiseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__EventRaiseResponse %p -> %p\n", q, p));
	*(struct dss__EventRaiseResponse*)p = *(struct dss__EventRaiseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SwitchGetGroupID(struct soap *soap, struct dss__SwitchGetGroupID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SwitchGetGroupID(struct soap *soap, const struct dss__SwitchGetGroupID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SwitchGetGroupID(struct soap *soap, const struct dss__SwitchGetGroupID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SwitchGetGroupID);
	if (soap_out_dss__SwitchGetGroupID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SwitchGetGroupID(struct soap *soap, const char *tag, int id, const struct dss__SwitchGetGroupID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SwitchGetGroupID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SwitchGetGroupID * SOAP_FMAC4 soap_get_dss__SwitchGetGroupID(struct soap *soap, struct dss__SwitchGetGroupID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SwitchGetGroupID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SwitchGetGroupID * SOAP_FMAC4 soap_in_dss__SwitchGetGroupID(struct soap *soap, const char *tag, struct dss__SwitchGetGroupID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SwitchGetGroupID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SwitchGetGroupID, sizeof(struct dss__SwitchGetGroupID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SwitchGetGroupID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SwitchGetGroupID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SwitchGetGroupID, 0, sizeof(struct dss__SwitchGetGroupID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SwitchGetGroupID * SOAP_FMAC6 soap_new_dss__SwitchGetGroupID(struct soap *soap, int n)
{	return soap_instantiate_dss__SwitchGetGroupID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SwitchGetGroupID(struct soap *soap, struct dss__SwitchGetGroupID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SwitchGetGroupID * SOAP_FMAC4 soap_instantiate_dss__SwitchGetGroupID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SwitchGetGroupID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SwitchGetGroupID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SwitchGetGroupID;
		if (size)
			*size = sizeof(struct dss__SwitchGetGroupID);
	}
	else
	{	cp->ptr = (void*)new struct dss__SwitchGetGroupID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SwitchGetGroupID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SwitchGetGroupID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SwitchGetGroupID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SwitchGetGroupID %p -> %p\n", q, p));
	*(struct dss__SwitchGetGroupID*)p = *(struct dss__SwitchGetGroupID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SwitchGetGroupIDResponse(struct soap *soap, struct dss__SwitchGetGroupIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SwitchGetGroupIDResponse(struct soap *soap, const struct dss__SwitchGetGroupIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SwitchGetGroupIDResponse(struct soap *soap, const struct dss__SwitchGetGroupIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SwitchGetGroupIDResponse);
	if (soap_out_dss__SwitchGetGroupIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SwitchGetGroupIDResponse(struct soap *soap, const char *tag, int id, const struct dss__SwitchGetGroupIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SwitchGetGroupIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SwitchGetGroupIDResponse * SOAP_FMAC4 soap_get_dss__SwitchGetGroupIDResponse(struct soap *soap, struct dss__SwitchGetGroupIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SwitchGetGroupIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SwitchGetGroupIDResponse * SOAP_FMAC4 soap_in_dss__SwitchGetGroupIDResponse(struct soap *soap, const char *tag, struct dss__SwitchGetGroupIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SwitchGetGroupIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SwitchGetGroupIDResponse, sizeof(struct dss__SwitchGetGroupIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SwitchGetGroupIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SwitchGetGroupIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SwitchGetGroupIDResponse, 0, sizeof(struct dss__SwitchGetGroupIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SwitchGetGroupIDResponse * SOAP_FMAC6 soap_new_dss__SwitchGetGroupIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SwitchGetGroupIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SwitchGetGroupIDResponse(struct soap *soap, struct dss__SwitchGetGroupIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SwitchGetGroupIDResponse * SOAP_FMAC4 soap_instantiate_dss__SwitchGetGroupIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SwitchGetGroupIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SwitchGetGroupIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SwitchGetGroupIDResponse;
		if (size)
			*size = sizeof(struct dss__SwitchGetGroupIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SwitchGetGroupIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SwitchGetGroupIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SwitchGetGroupIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SwitchGetGroupIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SwitchGetGroupIDResponse %p -> %p\n", q, p));
	*(struct dss__SwitchGetGroupIDResponse*)p = *(struct dss__SwitchGetGroupIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetFunctionID(struct soap *soap, struct dss__DeviceGetFunctionID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetFunctionID(struct soap *soap, const struct dss__DeviceGetFunctionID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetFunctionID(struct soap *soap, const struct dss__DeviceGetFunctionID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetFunctionID);
	if (soap_out_dss__DeviceGetFunctionID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetFunctionID(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetFunctionID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetFunctionID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionID * SOAP_FMAC4 soap_get_dss__DeviceGetFunctionID(struct soap *soap, struct dss__DeviceGetFunctionID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetFunctionID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetFunctionID * SOAP_FMAC4 soap_in_dss__DeviceGetFunctionID(struct soap *soap, const char *tag, struct dss__DeviceGetFunctionID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetFunctionID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetFunctionID, sizeof(struct dss__DeviceGetFunctionID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetFunctionID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetFunctionID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetFunctionID, 0, sizeof(struct dss__DeviceGetFunctionID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetFunctionID * SOAP_FMAC6 soap_new_dss__DeviceGetFunctionID(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetFunctionID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetFunctionID(struct soap *soap, struct dss__DeviceGetFunctionID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionID * SOAP_FMAC4 soap_instantiate_dss__DeviceGetFunctionID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetFunctionID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetFunctionID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetFunctionID;
		if (size)
			*size = sizeof(struct dss__DeviceGetFunctionID);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetFunctionID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetFunctionID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetFunctionID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetFunctionID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetFunctionID %p -> %p\n", q, p));
	*(struct dss__DeviceGetFunctionID*)p = *(struct dss__DeviceGetFunctionID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetFunctionIDResponse(struct soap *soap, struct dss__DeviceGetFunctionIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetFunctionIDResponse(struct soap *soap, const struct dss__DeviceGetFunctionIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetFunctionIDResponse(struct soap *soap, const struct dss__DeviceGetFunctionIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetFunctionIDResponse);
	if (soap_out_dss__DeviceGetFunctionIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetFunctionIDResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetFunctionIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetFunctionIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionIDResponse * SOAP_FMAC4 soap_get_dss__DeviceGetFunctionIDResponse(struct soap *soap, struct dss__DeviceGetFunctionIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetFunctionIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetFunctionIDResponse * SOAP_FMAC4 soap_in_dss__DeviceGetFunctionIDResponse(struct soap *soap, const char *tag, struct dss__DeviceGetFunctionIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetFunctionIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetFunctionIDResponse, sizeof(struct dss__DeviceGetFunctionIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetFunctionIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetFunctionIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetFunctionIDResponse, 0, sizeof(struct dss__DeviceGetFunctionIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetFunctionIDResponse * SOAP_FMAC6 soap_new_dss__DeviceGetFunctionIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetFunctionIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetFunctionIDResponse(struct soap *soap, struct dss__DeviceGetFunctionIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetFunctionIDResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceGetFunctionIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetFunctionIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetFunctionIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetFunctionIDResponse;
		if (size)
			*size = sizeof(struct dss__DeviceGetFunctionIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetFunctionIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetFunctionIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetFunctionIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetFunctionIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetFunctionIDResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetFunctionIDResponse*)p = *(struct dss__DeviceGetFunctionIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupRemoveDevice(struct soap *soap, struct dss__GroupRemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupRemoveDevice(struct soap *soap, const struct dss__GroupRemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupRemoveDevice(struct soap *soap, const struct dss__GroupRemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupRemoveDevice);
	if (soap_out_dss__GroupRemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupRemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__GroupRemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupRemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupRemoveDevice * SOAP_FMAC4 soap_get_dss__GroupRemoveDevice(struct soap *soap, struct dss__GroupRemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupRemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__GroupRemoveDevice * SOAP_FMAC4 soap_in_dss__GroupRemoveDevice(struct soap *soap, const char *tag, struct dss__GroupRemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupRemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupRemoveDevice, sizeof(struct dss__GroupRemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupRemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupRemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupRemoveDevice, 0, sizeof(struct dss__GroupRemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__GroupRemoveDevice * SOAP_FMAC6 soap_new_dss__GroupRemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__GroupRemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__GroupRemoveDevice(struct soap *soap, struct dss__GroupRemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__GroupRemoveDevice * SOAP_FMAC4 soap_instantiate_dss__GroupRemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupRemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupRemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__GroupRemoveDevice;
		if (size)
			*size = sizeof(struct dss__GroupRemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__GroupRemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupRemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupRemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupRemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupRemoveDevice %p -> %p\n", q, p));
	*(struct dss__GroupRemoveDevice*)p = *(struct dss__GroupRemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupRemoveDeviceResponse(struct soap *soap, struct dss__GroupRemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupRemoveDeviceResponse(struct soap *soap, const struct dss__GroupRemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupRemoveDeviceResponse(struct soap *soap, const struct dss__GroupRemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupRemoveDeviceResponse);
	if (soap_out_dss__GroupRemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupRemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__GroupRemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupRemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupRemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__GroupRemoveDeviceResponse(struct soap *soap, struct dss__GroupRemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupRemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__GroupRemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__GroupRemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__GroupRemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupRemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupRemoveDeviceResponse, sizeof(struct dss__GroupRemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupRemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupRemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupRemoveDeviceResponse, 0, sizeof(struct dss__GroupRemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__GroupRemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__GroupRemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__GroupRemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__GroupRemoveDeviceResponse(struct soap *soap, struct dss__GroupRemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__GroupRemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__GroupRemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupRemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupRemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__GroupRemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__GroupRemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__GroupRemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupRemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupRemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupRemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupRemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__GroupRemoveDeviceResponse*)p = *(struct dss__GroupRemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupAddDevice(struct soap *soap, struct dss__GroupAddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupAddDevice(struct soap *soap, const struct dss__GroupAddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupAddDevice(struct soap *soap, const struct dss__GroupAddDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupAddDevice);
	if (soap_out_dss__GroupAddDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupAddDevice(struct soap *soap, const char *tag, int id, const struct dss__GroupAddDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupAddDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupAddDevice * SOAP_FMAC4 soap_get_dss__GroupAddDevice(struct soap *soap, struct dss__GroupAddDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupAddDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__GroupAddDevice * SOAP_FMAC4 soap_in_dss__GroupAddDevice(struct soap *soap, const char *tag, struct dss__GroupAddDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupAddDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupAddDevice, sizeof(struct dss__GroupAddDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupAddDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupAddDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupAddDevice, 0, sizeof(struct dss__GroupAddDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__GroupAddDevice * SOAP_FMAC6 soap_new_dss__GroupAddDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__GroupAddDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__GroupAddDevice(struct soap *soap, struct dss__GroupAddDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__GroupAddDevice * SOAP_FMAC4 soap_instantiate_dss__GroupAddDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupAddDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupAddDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__GroupAddDevice;
		if (size)
			*size = sizeof(struct dss__GroupAddDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__GroupAddDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupAddDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupAddDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupAddDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupAddDevice %p -> %p\n", q, p));
	*(struct dss__GroupAddDevice*)p = *(struct dss__GroupAddDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupAddDeviceResponse(struct soap *soap, struct dss__GroupAddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupAddDeviceResponse(struct soap *soap, const struct dss__GroupAddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupAddDeviceResponse(struct soap *soap, const struct dss__GroupAddDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupAddDeviceResponse);
	if (soap_out_dss__GroupAddDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupAddDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__GroupAddDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupAddDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupAddDeviceResponse * SOAP_FMAC4 soap_get_dss__GroupAddDeviceResponse(struct soap *soap, struct dss__GroupAddDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupAddDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__GroupAddDeviceResponse * SOAP_FMAC4 soap_in_dss__GroupAddDeviceResponse(struct soap *soap, const char *tag, struct dss__GroupAddDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupAddDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupAddDeviceResponse, sizeof(struct dss__GroupAddDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupAddDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupAddDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupAddDeviceResponse, 0, sizeof(struct dss__GroupAddDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__GroupAddDeviceResponse * SOAP_FMAC6 soap_new_dss__GroupAddDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__GroupAddDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__GroupAddDeviceResponse(struct soap *soap, struct dss__GroupAddDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__GroupAddDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__GroupAddDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupAddDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupAddDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__GroupAddDeviceResponse;
		if (size)
			*size = sizeof(struct dss__GroupAddDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__GroupAddDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupAddDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupAddDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupAddDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupAddDeviceResponse %p -> %p\n", q, p));
	*(struct dss__GroupAddDeviceResponse*)p = *(struct dss__GroupAddDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupRemoveUserGroup(struct soap *soap, struct dss__GroupRemoveUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupRemoveUserGroup(struct soap *soap, const struct dss__GroupRemoveUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupRemoveUserGroup(struct soap *soap, const struct dss__GroupRemoveUserGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupRemoveUserGroup);
	if (soap_out_dss__GroupRemoveUserGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupRemoveUserGroup(struct soap *soap, const char *tag, int id, const struct dss__GroupRemoveUserGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupRemoveUserGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupRemoveUserGroup * SOAP_FMAC4 soap_get_dss__GroupRemoveUserGroup(struct soap *soap, struct dss__GroupRemoveUserGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupRemoveUserGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__GroupRemoveUserGroup * SOAP_FMAC4 soap_in_dss__GroupRemoveUserGroup(struct soap *soap, const char *tag, struct dss__GroupRemoveUserGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupRemoveUserGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupRemoveUserGroup, sizeof(struct dss__GroupRemoveUserGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupRemoveUserGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupRemoveUserGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupRemoveUserGroup, 0, sizeof(struct dss__GroupRemoveUserGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__GroupRemoveUserGroup * SOAP_FMAC6 soap_new_dss__GroupRemoveUserGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__GroupRemoveUserGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__GroupRemoveUserGroup(struct soap *soap, struct dss__GroupRemoveUserGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__GroupRemoveUserGroup * SOAP_FMAC4 soap_instantiate_dss__GroupRemoveUserGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupRemoveUserGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupRemoveUserGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__GroupRemoveUserGroup;
		if (size)
			*size = sizeof(struct dss__GroupRemoveUserGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__GroupRemoveUserGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupRemoveUserGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupRemoveUserGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupRemoveUserGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupRemoveUserGroup %p -> %p\n", q, p));
	*(struct dss__GroupRemoveUserGroup*)p = *(struct dss__GroupRemoveUserGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__GroupRemoveUserGroupResponse(struct soap *soap, struct dss__GroupRemoveUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__GroupRemoveUserGroupResponse(struct soap *soap, const struct dss__GroupRemoveUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__GroupRemoveUserGroupResponse(struct soap *soap, const struct dss__GroupRemoveUserGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__GroupRemoveUserGroupResponse);
	if (soap_out_dss__GroupRemoveUserGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__GroupRemoveUserGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__GroupRemoveUserGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__GroupRemoveUserGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__GroupRemoveUserGroupResponse * SOAP_FMAC4 soap_get_dss__GroupRemoveUserGroupResponse(struct soap *soap, struct dss__GroupRemoveUserGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__GroupRemoveUserGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__GroupRemoveUserGroupResponse * SOAP_FMAC4 soap_in_dss__GroupRemoveUserGroupResponse(struct soap *soap, const char *tag, struct dss__GroupRemoveUserGroupResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__GroupRemoveUserGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__GroupRemoveUserGroupResponse, sizeof(struct dss__GroupRemoveUserGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__GroupRemoveUserGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__GroupRemoveUserGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__GroupRemoveUserGroupResponse, 0, sizeof(struct dss__GroupRemoveUserGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__GroupRemoveUserGroupResponse * SOAP_FMAC6 soap_new_dss__GroupRemoveUserGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__GroupRemoveUserGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__GroupRemoveUserGroupResponse(struct soap *soap, struct dss__GroupRemoveUserGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__GroupRemoveUserGroupResponse * SOAP_FMAC4 soap_instantiate_dss__GroupRemoveUserGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__GroupRemoveUserGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__GroupRemoveUserGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__GroupRemoveUserGroupResponse;
		if (size)
			*size = sizeof(struct dss__GroupRemoveUserGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__GroupRemoveUserGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__GroupRemoveUserGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__GroupRemoveUserGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__GroupRemoveUserGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__GroupRemoveUserGroupResponse %p -> %p\n", q, p));
	*(struct dss__GroupRemoveUserGroupResponse*)p = *(struct dss__GroupRemoveUserGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentAllocateUserGroup(struct soap *soap, struct dss__ApartmentAllocateUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentAllocateUserGroup(struct soap *soap, const struct dss__ApartmentAllocateUserGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentAllocateUserGroup(struct soap *soap, const struct dss__ApartmentAllocateUserGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentAllocateUserGroup);
	if (soap_out_dss__ApartmentAllocateUserGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentAllocateUserGroup(struct soap *soap, const char *tag, int id, const struct dss__ApartmentAllocateUserGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentAllocateUserGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentAllocateUserGroup * SOAP_FMAC4 soap_get_dss__ApartmentAllocateUserGroup(struct soap *soap, struct dss__ApartmentAllocateUserGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentAllocateUserGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentAllocateUserGroup * SOAP_FMAC4 soap_in_dss__ApartmentAllocateUserGroup(struct soap *soap, const char *tag, struct dss__ApartmentAllocateUserGroup *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentAllocateUserGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentAllocateUserGroup, sizeof(struct dss__ApartmentAllocateUserGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentAllocateUserGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentAllocateUserGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentAllocateUserGroup, 0, sizeof(struct dss__ApartmentAllocateUserGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentAllocateUserGroup * SOAP_FMAC6 soap_new_dss__ApartmentAllocateUserGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentAllocateUserGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentAllocateUserGroup(struct soap *soap, struct dss__ApartmentAllocateUserGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentAllocateUserGroup * SOAP_FMAC4 soap_instantiate_dss__ApartmentAllocateUserGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentAllocateUserGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentAllocateUserGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateUserGroup;
		if (size)
			*size = sizeof(struct dss__ApartmentAllocateUserGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateUserGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentAllocateUserGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentAllocateUserGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentAllocateUserGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentAllocateUserGroup %p -> %p\n", q, p));
	*(struct dss__ApartmentAllocateUserGroup*)p = *(struct dss__ApartmentAllocateUserGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, struct dss__ApartmentAllocateUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, const struct dss__ApartmentAllocateUserGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, const struct dss__ApartmentAllocateUserGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse);
	if (soap_out_dss__ApartmentAllocateUserGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentAllocateUserGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse), type))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentAllocateUserGroupResponse * SOAP_FMAC4 soap_get_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, struct dss__ApartmentAllocateUserGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentAllocateUserGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentAllocateUserGroupResponse * SOAP_FMAC4 soap_in_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, const char *tag, struct dss__ApartmentAllocateUserGroupResponse *a, const char *type)
{
	short soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentAllocateUserGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse, sizeof(struct dss__ApartmentAllocateUserGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentAllocateUserGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupID", &a->groupID, "xsd:int"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentAllocateUserGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse, 0, sizeof(struct dss__ApartmentAllocateUserGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentAllocateUserGroupResponse * SOAP_FMAC6 soap_new_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentAllocateUserGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, struct dss__ApartmentAllocateUserGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentAllocateUserGroupResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentAllocateUserGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentAllocateUserGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateUserGroupResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentAllocateUserGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateUserGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentAllocateUserGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentAllocateUserGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentAllocateUserGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentAllocateUserGroupResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentAllocateUserGroupResponse*)p = *(struct dss__ApartmentAllocateUserGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_SetName(struct soap *soap, struct dss__Zone_SetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_SetName(struct soap *soap, const struct dss__Zone_SetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_SetName(struct soap *soap, const struct dss__Zone_SetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_SetName);
	if (soap_out_dss__Zone_SetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_SetName(struct soap *soap, const char *tag, int id, const struct dss__Zone_SetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_SetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_SetName * SOAP_FMAC4 soap_get_dss__Zone_SetName(struct soap *soap, struct dss__Zone_SetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_SetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_SetName * SOAP_FMAC4 soap_in_dss__Zone_SetName(struct soap *soap, const char *tag, struct dss__Zone_SetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_SetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_SetName, sizeof(struct dss__Zone_SetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_SetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_SetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_SetName, 0, sizeof(struct dss__Zone_SetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_SetName * SOAP_FMAC6 soap_new_dss__Zone_SetName(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_SetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_SetName(struct soap *soap, struct dss__Zone_SetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_SetName * SOAP_FMAC4 soap_instantiate_dss__Zone_SetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_SetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_SetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_SetName;
		if (size)
			*size = sizeof(struct dss__Zone_SetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_SetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_SetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_SetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_SetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_SetName %p -> %p\n", q, p));
	*(struct dss__Zone_SetName*)p = *(struct dss__Zone_SetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_SetNameResponse(struct soap *soap, struct dss__Zone_SetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_SetNameResponse(struct soap *soap, const struct dss__Zone_SetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_SetNameResponse(struct soap *soap, const struct dss__Zone_SetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_SetNameResponse);
	if (soap_out_dss__Zone_SetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_SetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__Zone_SetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_SetNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_SetNameResponse * SOAP_FMAC4 soap_get_dss__Zone_SetNameResponse(struct soap *soap, struct dss__Zone_SetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_SetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_SetNameResponse * SOAP_FMAC4 soap_in_dss__Zone_SetNameResponse(struct soap *soap, const char *tag, struct dss__Zone_SetNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_SetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_SetNameResponse, sizeof(struct dss__Zone_SetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_SetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_SetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_SetNameResponse, 0, sizeof(struct dss__Zone_SetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_SetNameResponse * SOAP_FMAC6 soap_new_dss__Zone_SetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_SetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_SetNameResponse(struct soap *soap, struct dss__Zone_SetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_SetNameResponse * SOAP_FMAC4 soap_instantiate_dss__Zone_SetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_SetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_SetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_SetNameResponse;
		if (size)
			*size = sizeof(struct dss__Zone_SetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_SetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_SetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_SetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_SetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_SetNameResponse %p -> %p\n", q, p));
	*(struct dss__Zone_SetNameResponse*)p = *(struct dss__Zone_SetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_RemoveDevice(struct soap *soap, struct dss__Zone_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_RemoveDevice(struct soap *soap, const struct dss__Zone_RemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_RemoveDevice(struct soap *soap, const struct dss__Zone_RemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_RemoveDevice);
	if (soap_out_dss__Zone_RemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_RemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__Zone_RemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_RemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_RemoveDevice * SOAP_FMAC4 soap_get_dss__Zone_RemoveDevice(struct soap *soap, struct dss__Zone_RemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_RemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_RemoveDevice * SOAP_FMAC4 soap_in_dss__Zone_RemoveDevice(struct soap *soap, const char *tag, struct dss__Zone_RemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_RemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_RemoveDevice, sizeof(struct dss__Zone_RemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_RemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_RemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_RemoveDevice, 0, sizeof(struct dss__Zone_RemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_RemoveDevice * SOAP_FMAC6 soap_new_dss__Zone_RemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_RemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_RemoveDevice(struct soap *soap, struct dss__Zone_RemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_RemoveDevice * SOAP_FMAC4 soap_instantiate_dss__Zone_RemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_RemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_RemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDevice;
		if (size)
			*size = sizeof(struct dss__Zone_RemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_RemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_RemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_RemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_RemoveDevice %p -> %p\n", q, p));
	*(struct dss__Zone_RemoveDevice*)p = *(struct dss__Zone_RemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_RemoveDeviceResponse(struct soap *soap, struct dss__Zone_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_RemoveDeviceResponse(struct soap *soap, const struct dss__Zone_RemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_RemoveDeviceResponse(struct soap *soap, const struct dss__Zone_RemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_RemoveDeviceResponse);
	if (soap_out_dss__Zone_RemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_RemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Zone_RemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_RemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__Zone_RemoveDeviceResponse(struct soap *soap, struct dss__Zone_RemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_RemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__Zone_RemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__Zone_RemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_RemoveDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_RemoveDeviceResponse, sizeof(struct dss__Zone_RemoveDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_RemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_RemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_RemoveDeviceResponse, 0, sizeof(struct dss__Zone_RemoveDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__Zone_RemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_RemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_RemoveDeviceResponse(struct soap *soap, struct dss__Zone_RemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_RemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Zone_RemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_RemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_RemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Zone_RemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_RemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_RemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_RemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_RemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_RemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Zone_RemoveDeviceResponse*)p = *(struct dss__Zone_RemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_AddDevice(struct soap *soap, struct dss__Zone_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_AddDevice(struct soap *soap, const struct dss__Zone_AddDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_AddDevice(struct soap *soap, const struct dss__Zone_AddDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_AddDevice);
	if (soap_out_dss__Zone_AddDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_AddDevice(struct soap *soap, const char *tag, int id, const struct dss__Zone_AddDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_AddDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_AddDevice * SOAP_FMAC4 soap_get_dss__Zone_AddDevice(struct soap *soap, struct dss__Zone_AddDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_AddDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_AddDevice * SOAP_FMAC4 soap_in_dss__Zone_AddDevice(struct soap *soap, const char *tag, struct dss__Zone_AddDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_AddDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_AddDevice, sizeof(struct dss__Zone_AddDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_AddDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_AddDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_AddDevice, 0, sizeof(struct dss__Zone_AddDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_AddDevice * SOAP_FMAC6 soap_new_dss__Zone_AddDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_AddDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_AddDevice(struct soap *soap, struct dss__Zone_AddDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_AddDevice * SOAP_FMAC4 soap_instantiate_dss__Zone_AddDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_AddDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_AddDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_AddDevice;
		if (size)
			*size = sizeof(struct dss__Zone_AddDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_AddDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_AddDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_AddDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_AddDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_AddDevice %p -> %p\n", q, p));
	*(struct dss__Zone_AddDevice*)p = *(struct dss__Zone_AddDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Zone_AddDeviceResponse(struct soap *soap, struct dss__Zone_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Zone_AddDeviceResponse(struct soap *soap, const struct dss__Zone_AddDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Zone_AddDeviceResponse(struct soap *soap, const struct dss__Zone_AddDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Zone_AddDeviceResponse);
	if (soap_out_dss__Zone_AddDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Zone_AddDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__Zone_AddDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Zone_AddDeviceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Zone_AddDeviceResponse * SOAP_FMAC4 soap_get_dss__Zone_AddDeviceResponse(struct soap *soap, struct dss__Zone_AddDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Zone_AddDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Zone_AddDeviceResponse * SOAP_FMAC4 soap_in_dss__Zone_AddDeviceResponse(struct soap *soap, const char *tag, struct dss__Zone_AddDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Zone_AddDeviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Zone_AddDeviceResponse, sizeof(struct dss__Zone_AddDeviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Zone_AddDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Zone_AddDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Zone_AddDeviceResponse, 0, sizeof(struct dss__Zone_AddDeviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Zone_AddDeviceResponse * SOAP_FMAC6 soap_new_dss__Zone_AddDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__Zone_AddDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Zone_AddDeviceResponse(struct soap *soap, struct dss__Zone_AddDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Zone_AddDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__Zone_AddDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Zone_AddDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Zone_AddDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Zone_AddDeviceResponse;
		if (size)
			*size = sizeof(struct dss__Zone_AddDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__Zone_AddDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Zone_AddDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Zone_AddDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Zone_AddDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Zone_AddDeviceResponse %p -> %p\n", q, p));
	*(struct dss__Zone_AddDeviceResponse*)p = *(struct dss__Zone_AddDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDeleteZone(struct soap *soap, struct dss__ApartmentDeleteZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDeleteZone(struct soap *soap, const struct dss__ApartmentDeleteZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDeleteZone(struct soap *soap, const struct dss__ApartmentDeleteZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDeleteZone);
	if (soap_out_dss__ApartmentDeleteZone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDeleteZone(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDeleteZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDeleteZone), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZone * SOAP_FMAC4 soap_get_dss__ApartmentDeleteZone(struct soap *soap, struct dss__ApartmentDeleteZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDeleteZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentDeleteZone * SOAP_FMAC4 soap_in_dss__ApartmentDeleteZone(struct soap *soap, const char *tag, struct dss__ApartmentDeleteZone *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDeleteZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDeleteZone, sizeof(struct dss__ApartmentDeleteZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDeleteZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDeleteZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDeleteZone, 0, sizeof(struct dss__ApartmentDeleteZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentDeleteZone * SOAP_FMAC6 soap_new_dss__ApartmentDeleteZone(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentDeleteZone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentDeleteZone(struct soap *soap, struct dss__ApartmentDeleteZone *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZone * SOAP_FMAC4 soap_instantiate_dss__ApartmentDeleteZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDeleteZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDeleteZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentDeleteZone;
		if (size)
			*size = sizeof(struct dss__ApartmentDeleteZone);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentDeleteZone[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDeleteZone);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDeleteZone*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDeleteZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDeleteZone %p -> %p\n", q, p));
	*(struct dss__ApartmentDeleteZone*)p = *(struct dss__ApartmentDeleteZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDeleteZoneResponse(struct soap *soap, struct dss__ApartmentDeleteZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDeleteZoneResponse(struct soap *soap, const struct dss__ApartmentDeleteZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDeleteZoneResponse(struct soap *soap, const struct dss__ApartmentDeleteZoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDeleteZoneResponse);
	if (soap_out_dss__ApartmentDeleteZoneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDeleteZoneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDeleteZoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDeleteZoneResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZoneResponse * SOAP_FMAC4 soap_get_dss__ApartmentDeleteZoneResponse(struct soap *soap, struct dss__ApartmentDeleteZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDeleteZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentDeleteZoneResponse * SOAP_FMAC4 soap_in_dss__ApartmentDeleteZoneResponse(struct soap *soap, const char *tag, struct dss__ApartmentDeleteZoneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDeleteZoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDeleteZoneResponse, sizeof(struct dss__ApartmentDeleteZoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDeleteZoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDeleteZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDeleteZoneResponse, 0, sizeof(struct dss__ApartmentDeleteZoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentDeleteZoneResponse * SOAP_FMAC6 soap_new_dss__ApartmentDeleteZoneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentDeleteZoneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentDeleteZoneResponse(struct soap *soap, struct dss__ApartmentDeleteZoneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentDeleteZoneResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentDeleteZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDeleteZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDeleteZoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentDeleteZoneResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentDeleteZoneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentDeleteZoneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDeleteZoneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDeleteZoneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDeleteZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDeleteZoneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentDeleteZoneResponse*)p = *(struct dss__ApartmentDeleteZoneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentAllocateZone(struct soap *soap, struct dss__ApartmentAllocateZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentAllocateZone(struct soap *soap, const struct dss__ApartmentAllocateZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentAllocateZone(struct soap *soap, const struct dss__ApartmentAllocateZone *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentAllocateZone);
	if (soap_out_dss__ApartmentAllocateZone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentAllocateZone(struct soap *soap, const char *tag, int id, const struct dss__ApartmentAllocateZone *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentAllocateZone), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZone * SOAP_FMAC4 soap_get_dss__ApartmentAllocateZone(struct soap *soap, struct dss__ApartmentAllocateZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentAllocateZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentAllocateZone * SOAP_FMAC4 soap_in_dss__ApartmentAllocateZone(struct soap *soap, const char *tag, struct dss__ApartmentAllocateZone *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentAllocateZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentAllocateZone, sizeof(struct dss__ApartmentAllocateZone), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentAllocateZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentAllocateZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentAllocateZone, 0, sizeof(struct dss__ApartmentAllocateZone), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentAllocateZone * SOAP_FMAC6 soap_new_dss__ApartmentAllocateZone(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentAllocateZone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentAllocateZone(struct soap *soap, struct dss__ApartmentAllocateZone *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZone * SOAP_FMAC4 soap_instantiate_dss__ApartmentAllocateZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentAllocateZone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentAllocateZone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateZone;
		if (size)
			*size = sizeof(struct dss__ApartmentAllocateZone);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateZone[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentAllocateZone);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentAllocateZone*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentAllocateZone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentAllocateZone %p -> %p\n", q, p));
	*(struct dss__ApartmentAllocateZone*)p = *(struct dss__ApartmentAllocateZone*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentAllocateZoneResponse(struct soap *soap, struct dss__ApartmentAllocateZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentAllocateZoneResponse(struct soap *soap, const struct dss__ApartmentAllocateZoneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentAllocateZoneResponse(struct soap *soap, const struct dss__ApartmentAllocateZoneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentAllocateZoneResponse);
	if (soap_out_dss__ApartmentAllocateZoneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentAllocateZoneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentAllocateZoneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentAllocateZoneResponse), type))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZoneResponse * SOAP_FMAC4 soap_get_dss__ApartmentAllocateZoneResponse(struct soap *soap, struct dss__ApartmentAllocateZoneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentAllocateZoneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentAllocateZoneResponse * SOAP_FMAC4 soap_in_dss__ApartmentAllocateZoneResponse(struct soap *soap, const char *tag, struct dss__ApartmentAllocateZoneResponse *a, const char *type)
{
	short soap_flag_zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentAllocateZoneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentAllocateZoneResponse, sizeof(struct dss__ApartmentAllocateZoneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentAllocateZoneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zoneID", &a->zoneID, "xsd:int"))
				{	soap_flag_zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentAllocateZoneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentAllocateZoneResponse, 0, sizeof(struct dss__ApartmentAllocateZoneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentAllocateZoneResponse * SOAP_FMAC6 soap_new_dss__ApartmentAllocateZoneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentAllocateZoneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentAllocateZoneResponse(struct soap *soap, struct dss__ApartmentAllocateZoneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentAllocateZoneResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentAllocateZoneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentAllocateZoneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentAllocateZoneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateZoneResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentAllocateZoneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentAllocateZoneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentAllocateZoneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentAllocateZoneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentAllocateZoneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentAllocateZoneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentAllocateZoneResponse*)p = *(struct dss__ApartmentAllocateZoneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ModulatorGetName(struct soap *soap, struct dss__ModulatorGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_modulatorID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ModulatorGetName(struct soap *soap, const struct dss__ModulatorGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_modulatorID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ModulatorGetName(struct soap *soap, const struct dss__ModulatorGetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ModulatorGetName);
	if (soap_out_dss__ModulatorGetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ModulatorGetName(struct soap *soap, const char *tag, int id, const struct dss__ModulatorGetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ModulatorGetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "modulatorID", -1, &a->_modulatorID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ModulatorGetName * SOAP_FMAC4 soap_get_dss__ModulatorGetName(struct soap *soap, struct dss__ModulatorGetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ModulatorGetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ModulatorGetName * SOAP_FMAC4 soap_in_dss__ModulatorGetName(struct soap *soap, const char *tag, struct dss__ModulatorGetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__modulatorID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ModulatorGetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ModulatorGetName, sizeof(struct dss__ModulatorGetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ModulatorGetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__modulatorID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_modulatorID, "xsd:string"))
				{	soap_flag__modulatorID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ModulatorGetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ModulatorGetName, 0, sizeof(struct dss__ModulatorGetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ModulatorGetName * SOAP_FMAC6 soap_new_dss__ModulatorGetName(struct soap *soap, int n)
{	return soap_instantiate_dss__ModulatorGetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ModulatorGetName(struct soap *soap, struct dss__ModulatorGetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ModulatorGetName * SOAP_FMAC4 soap_instantiate_dss__ModulatorGetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ModulatorGetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ModulatorGetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ModulatorGetName;
		if (size)
			*size = sizeof(struct dss__ModulatorGetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__ModulatorGetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ModulatorGetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ModulatorGetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ModulatorGetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ModulatorGetName %p -> %p\n", q, p));
	*(struct dss__ModulatorGetName*)p = *(struct dss__ModulatorGetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ModulatorGetNameResponse(struct soap *soap, struct dss__ModulatorGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ModulatorGetNameResponse(struct soap *soap, const struct dss__ModulatorGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ModulatorGetNameResponse(struct soap *soap, const struct dss__ModulatorGetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ModulatorGetNameResponse);
	if (soap_out_dss__ModulatorGetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ModulatorGetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ModulatorGetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ModulatorGetNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ModulatorGetNameResponse * SOAP_FMAC4 soap_get_dss__ModulatorGetNameResponse(struct soap *soap, struct dss__ModulatorGetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ModulatorGetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ModulatorGetNameResponse * SOAP_FMAC4 soap_in_dss__ModulatorGetNameResponse(struct soap *soap, const char *tag, struct dss__ModulatorGetNameResponse *a, const char *type)
{
	short soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ModulatorGetNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ModulatorGetNameResponse, sizeof(struct dss__ModulatorGetNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ModulatorGetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ModulatorGetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ModulatorGetNameResponse, 0, sizeof(struct dss__ModulatorGetNameResponse), 0, soap_copy_dss__ModulatorGetNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ModulatorGetNameResponse * SOAP_FMAC6 soap_new_dss__ModulatorGetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ModulatorGetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ModulatorGetNameResponse(struct soap *soap, struct dss__ModulatorGetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ModulatorGetNameResponse * SOAP_FMAC4 soap_instantiate_dss__ModulatorGetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ModulatorGetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ModulatorGetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ModulatorGetNameResponse;
		if (size)
			*size = sizeof(struct dss__ModulatorGetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ModulatorGetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ModulatorGetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ModulatorGetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ModulatorGetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ModulatorGetNameResponse %p -> %p\n", q, p));
	*(struct dss__ModulatorGetNameResponse*)p = *(struct dss__ModulatorGetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetModulatorIDs(struct soap *soap, struct dss__ApartmentGetModulatorIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetModulatorIDs(struct soap *soap, const struct dss__ApartmentGetModulatorIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetModulatorIDs(struct soap *soap, const struct dss__ApartmentGetModulatorIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetModulatorIDs);
	if (soap_out_dss__ApartmentGetModulatorIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetModulatorIDs(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetModulatorIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetModulatorIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetModulatorIDs * SOAP_FMAC4 soap_get_dss__ApartmentGetModulatorIDs(struct soap *soap, struct dss__ApartmentGetModulatorIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetModulatorIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetModulatorIDs * SOAP_FMAC4 soap_in_dss__ApartmentGetModulatorIDs(struct soap *soap, const char *tag, struct dss__ApartmentGetModulatorIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetModulatorIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetModulatorIDs, sizeof(struct dss__ApartmentGetModulatorIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetModulatorIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetModulatorIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetModulatorIDs, 0, sizeof(struct dss__ApartmentGetModulatorIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetModulatorIDs * SOAP_FMAC6 soap_new_dss__ApartmentGetModulatorIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetModulatorIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetModulatorIDs(struct soap *soap, struct dss__ApartmentGetModulatorIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetModulatorIDs * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetModulatorIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetModulatorIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetModulatorIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetModulatorIDs;
		if (size)
			*size = sizeof(struct dss__ApartmentGetModulatorIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetModulatorIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetModulatorIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetModulatorIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetModulatorIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetModulatorIDs %p -> %p\n", q, p));
	*(struct dss__ApartmentGetModulatorIDs*)p = *(struct dss__ApartmentGetModulatorIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, struct dss__ApartmentGetModulatorIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->ids);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, const struct dss__ApartmentGetModulatorIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, const struct dss__ApartmentGetModulatorIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse);
	if (soap_out_dss__ApartmentGetModulatorIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetModulatorIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetModulatorIDsResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, struct dss__ApartmentGetModulatorIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetModulatorIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetModulatorIDsResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetModulatorIDsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetModulatorIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse, sizeof(struct dss__ApartmentGetModulatorIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetModulatorIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ids", &a->ids, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetModulatorIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse, 0, sizeof(struct dss__ApartmentGetModulatorIDsResponse), 0, soap_copy_dss__ApartmentGetModulatorIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetModulatorIDsResponse * SOAP_FMAC6 soap_new_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetModulatorIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, struct dss__ApartmentGetModulatorIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetModulatorIDsResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetModulatorIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetModulatorIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetModulatorIDsResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentGetModulatorIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetModulatorIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetModulatorIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetModulatorIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetModulatorIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetModulatorIDsResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetModulatorIDsResponse*)p = *(struct dss__ApartmentGetModulatorIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ModulatorGetPowerConsumption(struct soap *soap, struct dss__ModulatorGetPowerConsumption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_modulatorID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ModulatorGetPowerConsumption(struct soap *soap, const struct dss__ModulatorGetPowerConsumption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ModulatorGetPowerConsumption(struct soap *soap, const struct dss__ModulatorGetPowerConsumption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ModulatorGetPowerConsumption);
	if (soap_out_dss__ModulatorGetPowerConsumption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ModulatorGetPowerConsumption(struct soap *soap, const char *tag, int id, const struct dss__ModulatorGetPowerConsumption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ModulatorGetPowerConsumption), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "modulatorID", -1, &a->_modulatorID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ModulatorGetPowerConsumption * SOAP_FMAC4 soap_get_dss__ModulatorGetPowerConsumption(struct soap *soap, struct dss__ModulatorGetPowerConsumption *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ModulatorGetPowerConsumption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ModulatorGetPowerConsumption * SOAP_FMAC4 soap_in_dss__ModulatorGetPowerConsumption(struct soap *soap, const char *tag, struct dss__ModulatorGetPowerConsumption *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__modulatorID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ModulatorGetPowerConsumption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ModulatorGetPowerConsumption, sizeof(struct dss__ModulatorGetPowerConsumption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ModulatorGetPowerConsumption(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__modulatorID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_modulatorID, "xsd:int"))
				{	soap_flag__modulatorID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ModulatorGetPowerConsumption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ModulatorGetPowerConsumption, 0, sizeof(struct dss__ModulatorGetPowerConsumption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__modulatorID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ModulatorGetPowerConsumption * SOAP_FMAC6 soap_new_dss__ModulatorGetPowerConsumption(struct soap *soap, int n)
{	return soap_instantiate_dss__ModulatorGetPowerConsumption(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ModulatorGetPowerConsumption(struct soap *soap, struct dss__ModulatorGetPowerConsumption *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ModulatorGetPowerConsumption * SOAP_FMAC4 soap_instantiate_dss__ModulatorGetPowerConsumption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ModulatorGetPowerConsumption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ModulatorGetPowerConsumption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ModulatorGetPowerConsumption;
		if (size)
			*size = sizeof(struct dss__ModulatorGetPowerConsumption);
	}
	else
	{	cp->ptr = (void*)new struct dss__ModulatorGetPowerConsumption[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ModulatorGetPowerConsumption);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ModulatorGetPowerConsumption*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ModulatorGetPowerConsumption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ModulatorGetPowerConsumption %p -> %p\n", q, p));
	*(struct dss__ModulatorGetPowerConsumption*)p = *(struct dss__ModulatorGetPowerConsumption*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, struct dss__ModulatorGetPowerConsumptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__unsignedInt(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, const struct dss__ModulatorGetPowerConsumptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, const struct dss__ModulatorGetPowerConsumptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse);
	if (soap_out_dss__ModulatorGetPowerConsumptionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, const char *tag, int id, const struct dss__ModulatorGetPowerConsumptionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse), type))
		return soap->error;
	if (soap_out_xsd__unsignedInt(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ModulatorGetPowerConsumptionResponse * SOAP_FMAC4 soap_get_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, struct dss__ModulatorGetPowerConsumptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ModulatorGetPowerConsumptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ModulatorGetPowerConsumptionResponse * SOAP_FMAC4 soap_in_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, const char *tag, struct dss__ModulatorGetPowerConsumptionResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ModulatorGetPowerConsumptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse, sizeof(struct dss__ModulatorGetPowerConsumptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ModulatorGetPowerConsumptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__unsignedInt(soap, "result", &a->result, "xsd:unsignedInt"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ModulatorGetPowerConsumptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse, 0, sizeof(struct dss__ModulatorGetPowerConsumptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ModulatorGetPowerConsumptionResponse * SOAP_FMAC6 soap_new_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ModulatorGetPowerConsumptionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, struct dss__ModulatorGetPowerConsumptionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ModulatorGetPowerConsumptionResponse * SOAP_FMAC4 soap_instantiate_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ModulatorGetPowerConsumptionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ModulatorGetPowerConsumptionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ModulatorGetPowerConsumptionResponse;
		if (size)
			*size = sizeof(struct dss__ModulatorGetPowerConsumptionResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ModulatorGetPowerConsumptionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ModulatorGetPowerConsumptionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ModulatorGetPowerConsumptionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ModulatorGetPowerConsumptionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ModulatorGetPowerConsumptionResponse %p -> %p\n", q, p));
	*(struct dss__ModulatorGetPowerConsumptionResponse*)p = *(struct dss__ModulatorGetPowerConsumptionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetZoneID(struct soap *soap, struct dss__DeviceGetZoneID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetZoneID(struct soap *soap, const struct dss__DeviceGetZoneID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetZoneID(struct soap *soap, const struct dss__DeviceGetZoneID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetZoneID);
	if (soap_out_dss__DeviceGetZoneID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetZoneID(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetZoneID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetZoneID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetZoneID * SOAP_FMAC4 soap_get_dss__DeviceGetZoneID(struct soap *soap, struct dss__DeviceGetZoneID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetZoneID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetZoneID * SOAP_FMAC4 soap_in_dss__DeviceGetZoneID(struct soap *soap, const char *tag, struct dss__DeviceGetZoneID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetZoneID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetZoneID, sizeof(struct dss__DeviceGetZoneID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetZoneID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetZoneID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetZoneID, 0, sizeof(struct dss__DeviceGetZoneID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetZoneID * SOAP_FMAC6 soap_new_dss__DeviceGetZoneID(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetZoneID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetZoneID(struct soap *soap, struct dss__DeviceGetZoneID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetZoneID * SOAP_FMAC4 soap_instantiate_dss__DeviceGetZoneID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetZoneID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetZoneID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetZoneID;
		if (size)
			*size = sizeof(struct dss__DeviceGetZoneID);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetZoneID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetZoneID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetZoneID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetZoneID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetZoneID %p -> %p\n", q, p));
	*(struct dss__DeviceGetZoneID*)p = *(struct dss__DeviceGetZoneID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetZoneIDResponse(struct soap *soap, struct dss__DeviceGetZoneIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetZoneIDResponse(struct soap *soap, const struct dss__DeviceGetZoneIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetZoneIDResponse(struct soap *soap, const struct dss__DeviceGetZoneIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetZoneIDResponse);
	if (soap_out_dss__DeviceGetZoneIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetZoneIDResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetZoneIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetZoneIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetZoneIDResponse * SOAP_FMAC4 soap_get_dss__DeviceGetZoneIDResponse(struct soap *soap, struct dss__DeviceGetZoneIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetZoneIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetZoneIDResponse * SOAP_FMAC4 soap_in_dss__DeviceGetZoneIDResponse(struct soap *soap, const char *tag, struct dss__DeviceGetZoneIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetZoneIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetZoneIDResponse, sizeof(struct dss__DeviceGetZoneIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetZoneIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetZoneIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetZoneIDResponse, 0, sizeof(struct dss__DeviceGetZoneIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetZoneIDResponse * SOAP_FMAC6 soap_new_dss__DeviceGetZoneIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetZoneIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetZoneIDResponse(struct soap *soap, struct dss__DeviceGetZoneIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetZoneIDResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceGetZoneIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetZoneIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetZoneIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetZoneIDResponse;
		if (size)
			*size = sizeof(struct dss__DeviceGetZoneIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetZoneIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetZoneIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetZoneIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetZoneIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetZoneIDResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetZoneIDResponse*)p = *(struct dss__DeviceGetZoneIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetName(struct soap *soap, struct dss__DeviceGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetName(struct soap *soap, const struct dss__DeviceGetName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetName(struct soap *soap, const struct dss__DeviceGetName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetName);
	if (soap_out_dss__DeviceGetName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetName(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetName * SOAP_FMAC4 soap_get_dss__DeviceGetName(struct soap *soap, struct dss__DeviceGetName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetName * SOAP_FMAC4 soap_in_dss__DeviceGetName(struct soap *soap, const char *tag, struct dss__DeviceGetName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetName, sizeof(struct dss__DeviceGetName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetName, 0, sizeof(struct dss__DeviceGetName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetName * SOAP_FMAC6 soap_new_dss__DeviceGetName(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetName(struct soap *soap, struct dss__DeviceGetName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetName * SOAP_FMAC4 soap_instantiate_dss__DeviceGetName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetName;
		if (size)
			*size = sizeof(struct dss__DeviceGetName);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetName %p -> %p\n", q, p));
	*(struct dss__DeviceGetName*)p = *(struct dss__DeviceGetName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetNameResponse(struct soap *soap, struct dss__DeviceGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetNameResponse(struct soap *soap, const struct dss__DeviceGetNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetNameResponse(struct soap *soap, const struct dss__DeviceGetNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetNameResponse);
	if (soap_out_dss__DeviceGetNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetNameResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetNameResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetNameResponse * SOAP_FMAC4 soap_get_dss__DeviceGetNameResponse(struct soap *soap, struct dss__DeviceGetNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetNameResponse * SOAP_FMAC4 soap_in_dss__DeviceGetNameResponse(struct soap *soap, const char *tag, struct dss__DeviceGetNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetNameResponse, sizeof(struct dss__DeviceGetNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetNameResponse, 0, sizeof(struct dss__DeviceGetNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetNameResponse * SOAP_FMAC6 soap_new_dss__DeviceGetNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetNameResponse(struct soap *soap, struct dss__DeviceGetNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetNameResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceGetNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetNameResponse;
		if (size)
			*size = sizeof(struct dss__DeviceGetNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetNameResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetNameResponse*)p = *(struct dss__DeviceGetNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSaveScene(struct soap *soap, struct dss__DeviceSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSaveScene(struct soap *soap, const struct dss__DeviceSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSaveScene(struct soap *soap, const struct dss__DeviceSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSaveScene);
	if (soap_out_dss__DeviceSaveScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSaveScene(struct soap *soap, const char *tag, int id, const struct dss__DeviceSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSaveScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSaveScene * SOAP_FMAC4 soap_get_dss__DeviceSaveScene(struct soap *soap, struct dss__DeviceSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceSaveScene * SOAP_FMAC4 soap_in_dss__DeviceSaveScene(struct soap *soap, const char *tag, struct dss__DeviceSaveScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSaveScene, sizeof(struct dss__DeviceSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSaveScene, 0, sizeof(struct dss__DeviceSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceSaveScene * SOAP_FMAC6 soap_new_dss__DeviceSaveScene(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceSaveScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceSaveScene(struct soap *soap, struct dss__DeviceSaveScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceSaveScene * SOAP_FMAC4 soap_instantiate_dss__DeviceSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceSaveScene;
		if (size)
			*size = sizeof(struct dss__DeviceSaveScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceSaveScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSaveScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSaveScene %p -> %p\n", q, p));
	*(struct dss__DeviceSaveScene*)p = *(struct dss__DeviceSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSaveSceneResponse(struct soap *soap, struct dss__DeviceSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSaveSceneResponse(struct soap *soap, const struct dss__DeviceSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSaveSceneResponse(struct soap *soap, const struct dss__DeviceSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSaveSceneResponse);
	if (soap_out_dss__DeviceSaveSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSaveSceneResponse * SOAP_FMAC4 soap_get_dss__DeviceSaveSceneResponse(struct soap *soap, struct dss__DeviceSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceSaveSceneResponse * SOAP_FMAC4 soap_in_dss__DeviceSaveSceneResponse(struct soap *soap, const char *tag, struct dss__DeviceSaveSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSaveSceneResponse, sizeof(struct dss__DeviceSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSaveSceneResponse, 0, sizeof(struct dss__DeviceSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceSaveSceneResponse * SOAP_FMAC6 soap_new_dss__DeviceSaveSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceSaveSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceSaveSceneResponse(struct soap *soap, struct dss__DeviceSaveSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceSaveSceneResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceSaveSceneResponse;
		if (size)
			*size = sizeof(struct dss__DeviceSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceSaveSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSaveSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__DeviceSaveSceneResponse*)p = *(struct dss__DeviceSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceCallScene(struct soap *soap, struct dss__DeviceCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceCallScene(struct soap *soap, const struct dss__DeviceCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceCallScene(struct soap *soap, const struct dss__DeviceCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceCallScene);
	if (soap_out_dss__DeviceCallScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceCallScene(struct soap *soap, const char *tag, int id, const struct dss__DeviceCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceCallScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceCallScene * SOAP_FMAC4 soap_get_dss__DeviceCallScene(struct soap *soap, struct dss__DeviceCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceCallScene * SOAP_FMAC4 soap_in_dss__DeviceCallScene(struct soap *soap, const char *tag, struct dss__DeviceCallScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceCallScene, sizeof(struct dss__DeviceCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceCallScene, 0, sizeof(struct dss__DeviceCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceCallScene * SOAP_FMAC6 soap_new_dss__DeviceCallScene(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceCallScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceCallScene(struct soap *soap, struct dss__DeviceCallScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceCallScene * SOAP_FMAC4 soap_instantiate_dss__DeviceCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceCallScene;
		if (size)
			*size = sizeof(struct dss__DeviceCallScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceCallScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceCallScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceCallScene %p -> %p\n", q, p));
	*(struct dss__DeviceCallScene*)p = *(struct dss__DeviceCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceCallSceneResponse(struct soap *soap, struct dss__DeviceCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceCallSceneResponse(struct soap *soap, const struct dss__DeviceCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceCallSceneResponse(struct soap *soap, const struct dss__DeviceCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceCallSceneResponse);
	if (soap_out_dss__DeviceCallSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceCallSceneResponse * SOAP_FMAC4 soap_get_dss__DeviceCallSceneResponse(struct soap *soap, struct dss__DeviceCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceCallSceneResponse * SOAP_FMAC4 soap_in_dss__DeviceCallSceneResponse(struct soap *soap, const char *tag, struct dss__DeviceCallSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceCallSceneResponse, sizeof(struct dss__DeviceCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceCallSceneResponse, 0, sizeof(struct dss__DeviceCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceCallSceneResponse * SOAP_FMAC6 soap_new_dss__DeviceCallSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceCallSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceCallSceneResponse(struct soap *soap, struct dss__DeviceCallSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceCallSceneResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceCallSceneResponse;
		if (size)
			*size = sizeof(struct dss__DeviceCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceCallSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceCallSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__DeviceCallSceneResponse*)p = *(struct dss__DeviceCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetValue(struct soap *soap, struct dss__DeviceGetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetValue(struct soap *soap, const struct dss__DeviceGetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetValue(struct soap *soap, const struct dss__DeviceGetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetValue);
	if (soap_out_dss__DeviceGetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetValue(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetValue * SOAP_FMAC4 soap_get_dss__DeviceGetValue(struct soap *soap, struct dss__DeviceGetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetValue * SOAP_FMAC4 soap_in_dss__DeviceGetValue(struct soap *soap, const char *tag, struct dss__DeviceGetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetValue, sizeof(struct dss__DeviceGetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetValue, 0, sizeof(struct dss__DeviceGetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetValue * SOAP_FMAC6 soap_new_dss__DeviceGetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetValue(struct soap *soap, struct dss__DeviceGetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetValue * SOAP_FMAC4 soap_instantiate_dss__DeviceGetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetValue;
		if (size)
			*size = sizeof(struct dss__DeviceGetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetValue %p -> %p\n", q, p));
	*(struct dss__DeviceGetValue*)p = *(struct dss__DeviceGetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceGetValueResponse(struct soap *soap, struct dss__DeviceGetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_double(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceGetValueResponse(struct soap *soap, const struct dss__DeviceGetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceGetValueResponse(struct soap *soap, const struct dss__DeviceGetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceGetValueResponse);
	if (soap_out_dss__DeviceGetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceGetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceGetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceGetValueResponse), type))
		return soap->error;
	if (soap_out_double(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceGetValueResponse * SOAP_FMAC4 soap_get_dss__DeviceGetValueResponse(struct soap *soap, struct dss__DeviceGetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceGetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceGetValueResponse * SOAP_FMAC4 soap_in_dss__DeviceGetValueResponse(struct soap *soap, const char *tag, struct dss__DeviceGetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceGetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceGetValueResponse, sizeof(struct dss__DeviceGetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceGetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "result", &a->result, "xsd:double"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceGetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceGetValueResponse, 0, sizeof(struct dss__DeviceGetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceGetValueResponse * SOAP_FMAC6 soap_new_dss__DeviceGetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceGetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceGetValueResponse(struct soap *soap, struct dss__DeviceGetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceGetValueResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceGetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceGetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceGetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceGetValueResponse;
		if (size)
			*size = sizeof(struct dss__DeviceGetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceGetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceGetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceGetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceGetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceGetValueResponse %p -> %p\n", q, p));
	*(struct dss__DeviceGetValueResponse*)p = *(struct dss__DeviceGetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetValue(struct soap *soap, struct dss__DeviceSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetValue(struct soap *soap, const struct dss__DeviceSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetValue(struct soap *soap, const struct dss__DeviceSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetValue);
	if (soap_out_dss__DeviceSetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetValue(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetValue * SOAP_FMAC4 soap_get_dss__DeviceSetValue(struct soap *soap, struct dss__DeviceSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceSetValue * SOAP_FMAC4 soap_in_dss__DeviceSetValue(struct soap *soap, const char *tag, struct dss__DeviceSetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetValue, sizeof(struct dss__DeviceSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetValue, 0, sizeof(struct dss__DeviceSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceSetValue * SOAP_FMAC6 soap_new_dss__DeviceSetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceSetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceSetValue(struct soap *soap, struct dss__DeviceSetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceSetValue * SOAP_FMAC4 soap_instantiate_dss__DeviceSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceSetValue;
		if (size)
			*size = sizeof(struct dss__DeviceSetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceSetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetValue %p -> %p\n", q, p));
	*(struct dss__DeviceSetValue*)p = *(struct dss__DeviceSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceSetValueResponse(struct soap *soap, struct dss__DeviceSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceSetValueResponse(struct soap *soap, const struct dss__DeviceSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceSetValueResponse(struct soap *soap, const struct dss__DeviceSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceSetValueResponse);
	if (soap_out_dss__DeviceSetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceSetValueResponse * SOAP_FMAC4 soap_get_dss__DeviceSetValueResponse(struct soap *soap, struct dss__DeviceSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceSetValueResponse * SOAP_FMAC4 soap_in_dss__DeviceSetValueResponse(struct soap *soap, const char *tag, struct dss__DeviceSetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceSetValueResponse, sizeof(struct dss__DeviceSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceSetValueResponse, 0, sizeof(struct dss__DeviceSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceSetValueResponse * SOAP_FMAC6 soap_new_dss__DeviceSetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceSetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceSetValueResponse(struct soap *soap, struct dss__DeviceSetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceSetValueResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceSetValueResponse;
		if (size)
			*size = sizeof(struct dss__DeviceSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceSetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceSetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceSetValueResponse %p -> %p\n", q, p));
	*(struct dss__DeviceSetValueResponse*)p = *(struct dss__DeviceSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceEndDim(struct soap *soap, struct dss__DeviceEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceEndDim(struct soap *soap, const struct dss__DeviceEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceEndDim(struct soap *soap, const struct dss__DeviceEndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceEndDim);
	if (soap_out_dss__DeviceEndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceEndDim(struct soap *soap, const char *tag, int id, const struct dss__DeviceEndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceEndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceEndDim * SOAP_FMAC4 soap_get_dss__DeviceEndDim(struct soap *soap, struct dss__DeviceEndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceEndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceEndDim * SOAP_FMAC4 soap_in_dss__DeviceEndDim(struct soap *soap, const char *tag, struct dss__DeviceEndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceEndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceEndDim, sizeof(struct dss__DeviceEndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceEndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceEndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceEndDim, 0, sizeof(struct dss__DeviceEndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceEndDim * SOAP_FMAC6 soap_new_dss__DeviceEndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceEndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceEndDim(struct soap *soap, struct dss__DeviceEndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceEndDim * SOAP_FMAC4 soap_instantiate_dss__DeviceEndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceEndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceEndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceEndDim;
		if (size)
			*size = sizeof(struct dss__DeviceEndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceEndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceEndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceEndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceEndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceEndDim %p -> %p\n", q, p));
	*(struct dss__DeviceEndDim*)p = *(struct dss__DeviceEndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceEndDimResponse(struct soap *soap, struct dss__DeviceEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceEndDimResponse(struct soap *soap, const struct dss__DeviceEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceEndDimResponse(struct soap *soap, const struct dss__DeviceEndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceEndDimResponse);
	if (soap_out_dss__DeviceEndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceEndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceEndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceEndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceEndDimResponse * SOAP_FMAC4 soap_get_dss__DeviceEndDimResponse(struct soap *soap, struct dss__DeviceEndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceEndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceEndDimResponse * SOAP_FMAC4 soap_in_dss__DeviceEndDimResponse(struct soap *soap, const char *tag, struct dss__DeviceEndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceEndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceEndDimResponse, sizeof(struct dss__DeviceEndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceEndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceEndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceEndDimResponse, 0, sizeof(struct dss__DeviceEndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceEndDimResponse * SOAP_FMAC6 soap_new_dss__DeviceEndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceEndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceEndDimResponse(struct soap *soap, struct dss__DeviceEndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceEndDimResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceEndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceEndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceEndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceEndDimResponse;
		if (size)
			*size = sizeof(struct dss__DeviceEndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceEndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceEndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceEndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceEndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceEndDimResponse %p -> %p\n", q, p));
	*(struct dss__DeviceEndDimResponse*)p = *(struct dss__DeviceEndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceStartDim(struct soap *soap, struct dss__DeviceStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceStartDim(struct soap *soap, const struct dss__DeviceStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceStartDim(struct soap *soap, const struct dss__DeviceStartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceStartDim);
	if (soap_out_dss__DeviceStartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceStartDim(struct soap *soap, const char *tag, int id, const struct dss__DeviceStartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceStartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceStartDim * SOAP_FMAC4 soap_get_dss__DeviceStartDim(struct soap *soap, struct dss__DeviceStartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceStartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceStartDim * SOAP_FMAC4 soap_in_dss__DeviceStartDim(struct soap *soap, const char *tag, struct dss__DeviceStartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceStartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceStartDim, sizeof(struct dss__DeviceStartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceStartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceStartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceStartDim, 0, sizeof(struct dss__DeviceStartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceStartDim * SOAP_FMAC6 soap_new_dss__DeviceStartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceStartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceStartDim(struct soap *soap, struct dss__DeviceStartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceStartDim * SOAP_FMAC4 soap_instantiate_dss__DeviceStartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceStartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceStartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceStartDim;
		if (size)
			*size = sizeof(struct dss__DeviceStartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceStartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceStartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceStartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceStartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceStartDim %p -> %p\n", q, p));
	*(struct dss__DeviceStartDim*)p = *(struct dss__DeviceStartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceStartDimResponse(struct soap *soap, struct dss__DeviceStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceStartDimResponse(struct soap *soap, const struct dss__DeviceStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceStartDimResponse(struct soap *soap, const struct dss__DeviceStartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceStartDimResponse);
	if (soap_out_dss__DeviceStartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceStartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceStartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceStartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceStartDimResponse * SOAP_FMAC4 soap_get_dss__DeviceStartDimResponse(struct soap *soap, struct dss__DeviceStartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceStartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceStartDimResponse * SOAP_FMAC4 soap_in_dss__DeviceStartDimResponse(struct soap *soap, const char *tag, struct dss__DeviceStartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceStartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceStartDimResponse, sizeof(struct dss__DeviceStartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceStartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceStartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceStartDimResponse, 0, sizeof(struct dss__DeviceStartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceStartDimResponse * SOAP_FMAC6 soap_new_dss__DeviceStartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceStartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceStartDimResponse(struct soap *soap, struct dss__DeviceStartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceStartDimResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceStartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceStartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceStartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceStartDimResponse;
		if (size)
			*size = sizeof(struct dss__DeviceStartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceStartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceStartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceStartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceStartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceStartDimResponse %p -> %p\n", q, p));
	*(struct dss__DeviceStartDimResponse*)p = *(struct dss__DeviceStartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceDisable(struct soap *soap, struct dss__DeviceDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceDisable(struct soap *soap, const struct dss__DeviceDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceDisable(struct soap *soap, const struct dss__DeviceDisable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceDisable);
	if (soap_out_dss__DeviceDisable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceDisable(struct soap *soap, const char *tag, int id, const struct dss__DeviceDisable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceDisable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceDisable * SOAP_FMAC4 soap_get_dss__DeviceDisable(struct soap *soap, struct dss__DeviceDisable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceDisable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceDisable * SOAP_FMAC4 soap_in_dss__DeviceDisable(struct soap *soap, const char *tag, struct dss__DeviceDisable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceDisable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceDisable, sizeof(struct dss__DeviceDisable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceDisable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceDisable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceDisable, 0, sizeof(struct dss__DeviceDisable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceDisable * SOAP_FMAC6 soap_new_dss__DeviceDisable(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceDisable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceDisable(struct soap *soap, struct dss__DeviceDisable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceDisable * SOAP_FMAC4 soap_instantiate_dss__DeviceDisable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceDisable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceDisable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceDisable;
		if (size)
			*size = sizeof(struct dss__DeviceDisable);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceDisable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceDisable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceDisable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceDisable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceDisable %p -> %p\n", q, p));
	*(struct dss__DeviceDisable*)p = *(struct dss__DeviceDisable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceDisableResponse(struct soap *soap, struct dss__DeviceDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceDisableResponse(struct soap *soap, const struct dss__DeviceDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceDisableResponse(struct soap *soap, const struct dss__DeviceDisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceDisableResponse);
	if (soap_out_dss__DeviceDisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceDisableResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceDisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceDisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceDisableResponse * SOAP_FMAC4 soap_get_dss__DeviceDisableResponse(struct soap *soap, struct dss__DeviceDisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceDisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceDisableResponse * SOAP_FMAC4 soap_in_dss__DeviceDisableResponse(struct soap *soap, const char *tag, struct dss__DeviceDisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceDisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceDisableResponse, sizeof(struct dss__DeviceDisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceDisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceDisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceDisableResponse, 0, sizeof(struct dss__DeviceDisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceDisableResponse * SOAP_FMAC6 soap_new_dss__DeviceDisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceDisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceDisableResponse(struct soap *soap, struct dss__DeviceDisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceDisableResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceDisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceDisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceDisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceDisableResponse;
		if (size)
			*size = sizeof(struct dss__DeviceDisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceDisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceDisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceDisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceDisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceDisableResponse %p -> %p\n", q, p));
	*(struct dss__DeviceDisableResponse*)p = *(struct dss__DeviceDisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceEnable(struct soap *soap, struct dss__DeviceEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceEnable(struct soap *soap, const struct dss__DeviceEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceEnable(struct soap *soap, const struct dss__DeviceEnable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceEnable);
	if (soap_out_dss__DeviceEnable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceEnable(struct soap *soap, const char *tag, int id, const struct dss__DeviceEnable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceEnable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceEnable * SOAP_FMAC4 soap_get_dss__DeviceEnable(struct soap *soap, struct dss__DeviceEnable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceEnable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceEnable * SOAP_FMAC4 soap_in_dss__DeviceEnable(struct soap *soap, const char *tag, struct dss__DeviceEnable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceEnable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceEnable, sizeof(struct dss__DeviceEnable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceEnable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceEnable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceEnable, 0, sizeof(struct dss__DeviceEnable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceEnable * SOAP_FMAC6 soap_new_dss__DeviceEnable(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceEnable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceEnable(struct soap *soap, struct dss__DeviceEnable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceEnable * SOAP_FMAC4 soap_instantiate_dss__DeviceEnable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceEnable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceEnable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceEnable;
		if (size)
			*size = sizeof(struct dss__DeviceEnable);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceEnable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceEnable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceEnable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceEnable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceEnable %p -> %p\n", q, p));
	*(struct dss__DeviceEnable*)p = *(struct dss__DeviceEnable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceEnableResponse(struct soap *soap, struct dss__DeviceEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceEnableResponse(struct soap *soap, const struct dss__DeviceEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceEnableResponse(struct soap *soap, const struct dss__DeviceEnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceEnableResponse);
	if (soap_out_dss__DeviceEnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceEnableResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceEnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceEnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceEnableResponse * SOAP_FMAC4 soap_get_dss__DeviceEnableResponse(struct soap *soap, struct dss__DeviceEnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceEnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceEnableResponse * SOAP_FMAC4 soap_in_dss__DeviceEnableResponse(struct soap *soap, const char *tag, struct dss__DeviceEnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceEnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceEnableResponse, sizeof(struct dss__DeviceEnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceEnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceEnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceEnableResponse, 0, sizeof(struct dss__DeviceEnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceEnableResponse * SOAP_FMAC6 soap_new_dss__DeviceEnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceEnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceEnableResponse(struct soap *soap, struct dss__DeviceEnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceEnableResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceEnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceEnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceEnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceEnableResponse;
		if (size)
			*size = sizeof(struct dss__DeviceEnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceEnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceEnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceEnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceEnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceEnableResponse %p -> %p\n", q, p));
	*(struct dss__DeviceEnableResponse*)p = *(struct dss__DeviceEnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceDecreaseValue(struct soap *soap, struct dss__DeviceDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceDecreaseValue(struct soap *soap, const struct dss__DeviceDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceDecreaseValue(struct soap *soap, const struct dss__DeviceDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceDecreaseValue);
	if (soap_out_dss__DeviceDecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__DeviceDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceDecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValue * SOAP_FMAC4 soap_get_dss__DeviceDecreaseValue(struct soap *soap, struct dss__DeviceDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceDecreaseValue * SOAP_FMAC4 soap_in_dss__DeviceDecreaseValue(struct soap *soap, const char *tag, struct dss__DeviceDecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceDecreaseValue, sizeof(struct dss__DeviceDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceDecreaseValue, 0, sizeof(struct dss__DeviceDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceDecreaseValue * SOAP_FMAC6 soap_new_dss__DeviceDecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceDecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceDecreaseValue(struct soap *soap, struct dss__DeviceDecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValue * SOAP_FMAC4 soap_instantiate_dss__DeviceDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceDecreaseValue;
		if (size)
			*size = sizeof(struct dss__DeviceDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceDecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceDecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceDecreaseValue %p -> %p\n", q, p));
	*(struct dss__DeviceDecreaseValue*)p = *(struct dss__DeviceDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceDecreaseValueResponse(struct soap *soap, struct dss__DeviceDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceDecreaseValueResponse(struct soap *soap, const struct dss__DeviceDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceDecreaseValueResponse(struct soap *soap, const struct dss__DeviceDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceDecreaseValueResponse);
	if (soap_out_dss__DeviceDecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__DeviceDecreaseValueResponse(struct soap *soap, struct dss__DeviceDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__DeviceDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__DeviceDecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceDecreaseValueResponse, sizeof(struct dss__DeviceDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceDecreaseValueResponse, 0, sizeof(struct dss__DeviceDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceDecreaseValueResponse * SOAP_FMAC6 soap_new_dss__DeviceDecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceDecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceDecreaseValueResponse(struct soap *soap, struct dss__DeviceDecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceDecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceDecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__DeviceDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceDecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceDecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__DeviceDecreaseValueResponse*)p = *(struct dss__DeviceDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceIncreaseValue(struct soap *soap, struct dss__DeviceIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceIncreaseValue(struct soap *soap, const struct dss__DeviceIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceIncreaseValue(struct soap *soap, const struct dss__DeviceIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceIncreaseValue);
	if (soap_out_dss__DeviceIncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__DeviceIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceIncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValue * SOAP_FMAC4 soap_get_dss__DeviceIncreaseValue(struct soap *soap, struct dss__DeviceIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceIncreaseValue * SOAP_FMAC4 soap_in_dss__DeviceIncreaseValue(struct soap *soap, const char *tag, struct dss__DeviceIncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceIncreaseValue, sizeof(struct dss__DeviceIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceIncreaseValue, 0, sizeof(struct dss__DeviceIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceIncreaseValue * SOAP_FMAC6 soap_new_dss__DeviceIncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceIncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceIncreaseValue(struct soap *soap, struct dss__DeviceIncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValue * SOAP_FMAC4 soap_instantiate_dss__DeviceIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceIncreaseValue;
		if (size)
			*size = sizeof(struct dss__DeviceIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceIncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceIncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceIncreaseValue %p -> %p\n", q, p));
	*(struct dss__DeviceIncreaseValue*)p = *(struct dss__DeviceIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceIncreaseValueResponse(struct soap *soap, struct dss__DeviceIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceIncreaseValueResponse(struct soap *soap, const struct dss__DeviceIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceIncreaseValueResponse(struct soap *soap, const struct dss__DeviceIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceIncreaseValueResponse);
	if (soap_out_dss__DeviceIncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__DeviceIncreaseValueResponse(struct soap *soap, struct dss__DeviceIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__DeviceIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__DeviceIncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceIncreaseValueResponse, sizeof(struct dss__DeviceIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceIncreaseValueResponse, 0, sizeof(struct dss__DeviceIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceIncreaseValueResponse * SOAP_FMAC6 soap_new_dss__DeviceIncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceIncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceIncreaseValueResponse(struct soap *soap, struct dss__DeviceIncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceIncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceIncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__DeviceIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceIncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceIncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__DeviceIncreaseValueResponse*)p = *(struct dss__DeviceIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOff(struct soap *soap, struct dss__DeviceTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOff(struct soap *soap, const struct dss__DeviceTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOff(struct soap *soap, const struct dss__DeviceTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOff);
	if (soap_out_dss__DeviceTurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOff(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOff * SOAP_FMAC4 soap_get_dss__DeviceTurnOff(struct soap *soap, struct dss__DeviceTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceTurnOff * SOAP_FMAC4 soap_in_dss__DeviceTurnOff(struct soap *soap, const char *tag, struct dss__DeviceTurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOff, sizeof(struct dss__DeviceTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOff, 0, sizeof(struct dss__DeviceTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceTurnOff * SOAP_FMAC6 soap_new_dss__DeviceTurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceTurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceTurnOff(struct soap *soap, struct dss__DeviceTurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceTurnOff * SOAP_FMAC4 soap_instantiate_dss__DeviceTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceTurnOff;
		if (size)
			*size = sizeof(struct dss__DeviceTurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceTurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOff %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOff*)p = *(struct dss__DeviceTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOffResponse(struct soap *soap, struct dss__DeviceTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOffResponse(struct soap *soap, const struct dss__DeviceTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOffResponse(struct soap *soap, const struct dss__DeviceTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOffResponse);
	if (soap_out_dss__DeviceTurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOffResponse * SOAP_FMAC4 soap_get_dss__DeviceTurnOffResponse(struct soap *soap, struct dss__DeviceTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceTurnOffResponse * SOAP_FMAC4 soap_in_dss__DeviceTurnOffResponse(struct soap *soap, const char *tag, struct dss__DeviceTurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOffResponse, sizeof(struct dss__DeviceTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOffResponse, 0, sizeof(struct dss__DeviceTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceTurnOffResponse * SOAP_FMAC6 soap_new_dss__DeviceTurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceTurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceTurnOffResponse(struct soap *soap, struct dss__DeviceTurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceTurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceTurnOffResponse;
		if (size)
			*size = sizeof(struct dss__DeviceTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceTurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOffResponse*)p = *(struct dss__DeviceTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOn(struct soap *soap, struct dss__DeviceTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOn(struct soap *soap, const struct dss__DeviceTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOn(struct soap *soap, const struct dss__DeviceTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOn);
	if (soap_out_dss__DeviceTurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOn(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOn * SOAP_FMAC4 soap_get_dss__DeviceTurnOn(struct soap *soap, struct dss__DeviceTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceTurnOn * SOAP_FMAC4 soap_in_dss__DeviceTurnOn(struct soap *soap, const char *tag, struct dss__DeviceTurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOn, sizeof(struct dss__DeviceTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOn, 0, sizeof(struct dss__DeviceTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceTurnOn * SOAP_FMAC6 soap_new_dss__DeviceTurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceTurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceTurnOn(struct soap *soap, struct dss__DeviceTurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceTurnOn * SOAP_FMAC4 soap_instantiate_dss__DeviceTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceTurnOn;
		if (size)
			*size = sizeof(struct dss__DeviceTurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceTurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOn %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOn*)p = *(struct dss__DeviceTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__DeviceTurnOnResponse(struct soap *soap, struct dss__DeviceTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__DeviceTurnOnResponse(struct soap *soap, const struct dss__DeviceTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__DeviceTurnOnResponse(struct soap *soap, const struct dss__DeviceTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__DeviceTurnOnResponse);
	if (soap_out_dss__DeviceTurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__DeviceTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__DeviceTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__DeviceTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__DeviceTurnOnResponse * SOAP_FMAC4 soap_get_dss__DeviceTurnOnResponse(struct soap *soap, struct dss__DeviceTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__DeviceTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__DeviceTurnOnResponse * SOAP_FMAC4 soap_in_dss__DeviceTurnOnResponse(struct soap *soap, const char *tag, struct dss__DeviceTurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__DeviceTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__DeviceTurnOnResponse, sizeof(struct dss__DeviceTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__DeviceTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__DeviceTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__DeviceTurnOnResponse, 0, sizeof(struct dss__DeviceTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__DeviceTurnOnResponse * SOAP_FMAC6 soap_new_dss__DeviceTurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__DeviceTurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__DeviceTurnOnResponse(struct soap *soap, struct dss__DeviceTurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__DeviceTurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__DeviceTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__DeviceTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__DeviceTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__DeviceTurnOnResponse;
		if (size)
			*size = sizeof(struct dss__DeviceTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__DeviceTurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__DeviceTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__DeviceTurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__DeviceTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__DeviceTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__DeviceTurnOnResponse*)p = *(struct dss__DeviceTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSaveScene(struct soap *soap, struct dss__ZoneSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSaveScene(struct soap *soap, const struct dss__ZoneSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSaveScene(struct soap *soap, const struct dss__ZoneSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSaveScene);
	if (soap_out_dss__ZoneSaveScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSaveScene(struct soap *soap, const char *tag, int id, const struct dss__ZoneSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSaveScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSaveScene * SOAP_FMAC4 soap_get_dss__ZoneSaveScene(struct soap *soap, struct dss__ZoneSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneSaveScene * SOAP_FMAC4 soap_in_dss__ZoneSaveScene(struct soap *soap, const char *tag, struct dss__ZoneSaveScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSaveScene, sizeof(struct dss__ZoneSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSaveScene, 0, sizeof(struct dss__ZoneSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneSaveScene * SOAP_FMAC6 soap_new_dss__ZoneSaveScene(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneSaveScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneSaveScene(struct soap *soap, struct dss__ZoneSaveScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneSaveScene * SOAP_FMAC4 soap_instantiate_dss__ZoneSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneSaveScene;
		if (size)
			*size = sizeof(struct dss__ZoneSaveScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneSaveScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSaveScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSaveScene %p -> %p\n", q, p));
	*(struct dss__ZoneSaveScene*)p = *(struct dss__ZoneSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSaveSceneResponse(struct soap *soap, struct dss__ZoneSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSaveSceneResponse(struct soap *soap, const struct dss__ZoneSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSaveSceneResponse(struct soap *soap, const struct dss__ZoneSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSaveSceneResponse);
	if (soap_out_dss__ZoneSaveSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSaveSceneResponse * SOAP_FMAC4 soap_get_dss__ZoneSaveSceneResponse(struct soap *soap, struct dss__ZoneSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneSaveSceneResponse * SOAP_FMAC4 soap_in_dss__ZoneSaveSceneResponse(struct soap *soap, const char *tag, struct dss__ZoneSaveSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSaveSceneResponse, sizeof(struct dss__ZoneSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSaveSceneResponse, 0, sizeof(struct dss__ZoneSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneSaveSceneResponse * SOAP_FMAC6 soap_new_dss__ZoneSaveSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneSaveSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneSaveSceneResponse(struct soap *soap, struct dss__ZoneSaveSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneSaveSceneResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneSaveSceneResponse;
		if (size)
			*size = sizeof(struct dss__ZoneSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneSaveSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSaveSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__ZoneSaveSceneResponse*)p = *(struct dss__ZoneSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneCallScene(struct soap *soap, struct dss__ZoneCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneCallScene(struct soap *soap, const struct dss__ZoneCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneCallScene(struct soap *soap, const struct dss__ZoneCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneCallScene);
	if (soap_out_dss__ZoneCallScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneCallScene(struct soap *soap, const char *tag, int id, const struct dss__ZoneCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneCallScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneCallScene * SOAP_FMAC4 soap_get_dss__ZoneCallScene(struct soap *soap, struct dss__ZoneCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneCallScene * SOAP_FMAC4 soap_in_dss__ZoneCallScene(struct soap *soap, const char *tag, struct dss__ZoneCallScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneCallScene, sizeof(struct dss__ZoneCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneCallScene, 0, sizeof(struct dss__ZoneCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneCallScene * SOAP_FMAC6 soap_new_dss__ZoneCallScene(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneCallScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneCallScene(struct soap *soap, struct dss__ZoneCallScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneCallScene * SOAP_FMAC4 soap_instantiate_dss__ZoneCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneCallScene;
		if (size)
			*size = sizeof(struct dss__ZoneCallScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneCallScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneCallScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneCallScene %p -> %p\n", q, p));
	*(struct dss__ZoneCallScene*)p = *(struct dss__ZoneCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneCallSceneResponse(struct soap *soap, struct dss__ZoneCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneCallSceneResponse(struct soap *soap, const struct dss__ZoneCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneCallSceneResponse(struct soap *soap, const struct dss__ZoneCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneCallSceneResponse);
	if (soap_out_dss__ZoneCallSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneCallSceneResponse * SOAP_FMAC4 soap_get_dss__ZoneCallSceneResponse(struct soap *soap, struct dss__ZoneCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneCallSceneResponse * SOAP_FMAC4 soap_in_dss__ZoneCallSceneResponse(struct soap *soap, const char *tag, struct dss__ZoneCallSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneCallSceneResponse, sizeof(struct dss__ZoneCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneCallSceneResponse, 0, sizeof(struct dss__ZoneCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneCallSceneResponse * SOAP_FMAC6 soap_new_dss__ZoneCallSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneCallSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneCallSceneResponse(struct soap *soap, struct dss__ZoneCallSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneCallSceneResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneCallSceneResponse;
		if (size)
			*size = sizeof(struct dss__ZoneCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneCallSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneCallSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__ZoneCallSceneResponse*)p = *(struct dss__ZoneCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSetValue(struct soap *soap, struct dss__ZoneSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSetValue(struct soap *soap, const struct dss__ZoneSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSetValue(struct soap *soap, const struct dss__ZoneSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSetValue);
	if (soap_out_dss__ZoneSetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSetValue(struct soap *soap, const char *tag, int id, const struct dss__ZoneSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSetValue * SOAP_FMAC4 soap_get_dss__ZoneSetValue(struct soap *soap, struct dss__ZoneSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneSetValue * SOAP_FMAC4 soap_in_dss__ZoneSetValue(struct soap *soap, const char *tag, struct dss__ZoneSetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSetValue, sizeof(struct dss__ZoneSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSetValue, 0, sizeof(struct dss__ZoneSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneSetValue * SOAP_FMAC6 soap_new_dss__ZoneSetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneSetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneSetValue(struct soap *soap, struct dss__ZoneSetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneSetValue * SOAP_FMAC4 soap_instantiate_dss__ZoneSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneSetValue;
		if (size)
			*size = sizeof(struct dss__ZoneSetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneSetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSetValue %p -> %p\n", q, p));
	*(struct dss__ZoneSetValue*)p = *(struct dss__ZoneSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneSetValueResponse(struct soap *soap, struct dss__ZoneSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneSetValueResponse(struct soap *soap, const struct dss__ZoneSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneSetValueResponse(struct soap *soap, const struct dss__ZoneSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneSetValueResponse);
	if (soap_out_dss__ZoneSetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneSetValueResponse * SOAP_FMAC4 soap_get_dss__ZoneSetValueResponse(struct soap *soap, struct dss__ZoneSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneSetValueResponse * SOAP_FMAC4 soap_in_dss__ZoneSetValueResponse(struct soap *soap, const char *tag, struct dss__ZoneSetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneSetValueResponse, sizeof(struct dss__ZoneSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneSetValueResponse, 0, sizeof(struct dss__ZoneSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneSetValueResponse * SOAP_FMAC6 soap_new_dss__ZoneSetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneSetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneSetValueResponse(struct soap *soap, struct dss__ZoneSetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneSetValueResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneSetValueResponse;
		if (size)
			*size = sizeof(struct dss__ZoneSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneSetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneSetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneSetValueResponse %p -> %p\n", q, p));
	*(struct dss__ZoneSetValueResponse*)p = *(struct dss__ZoneSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneEndDim(struct soap *soap, struct dss__ZoneEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneEndDim(struct soap *soap, const struct dss__ZoneEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneEndDim(struct soap *soap, const struct dss__ZoneEndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneEndDim);
	if (soap_out_dss__ZoneEndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneEndDim(struct soap *soap, const char *tag, int id, const struct dss__ZoneEndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneEndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneEndDim * SOAP_FMAC4 soap_get_dss__ZoneEndDim(struct soap *soap, struct dss__ZoneEndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneEndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneEndDim * SOAP_FMAC4 soap_in_dss__ZoneEndDim(struct soap *soap, const char *tag, struct dss__ZoneEndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneEndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneEndDim, sizeof(struct dss__ZoneEndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneEndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneEndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneEndDim, 0, sizeof(struct dss__ZoneEndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneEndDim * SOAP_FMAC6 soap_new_dss__ZoneEndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneEndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneEndDim(struct soap *soap, struct dss__ZoneEndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneEndDim * SOAP_FMAC4 soap_instantiate_dss__ZoneEndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneEndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneEndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneEndDim;
		if (size)
			*size = sizeof(struct dss__ZoneEndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneEndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneEndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneEndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneEndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneEndDim %p -> %p\n", q, p));
	*(struct dss__ZoneEndDim*)p = *(struct dss__ZoneEndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneEndDimResponse(struct soap *soap, struct dss__ZoneEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneEndDimResponse(struct soap *soap, const struct dss__ZoneEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneEndDimResponse(struct soap *soap, const struct dss__ZoneEndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneEndDimResponse);
	if (soap_out_dss__ZoneEndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneEndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneEndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneEndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneEndDimResponse * SOAP_FMAC4 soap_get_dss__ZoneEndDimResponse(struct soap *soap, struct dss__ZoneEndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneEndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneEndDimResponse * SOAP_FMAC4 soap_in_dss__ZoneEndDimResponse(struct soap *soap, const char *tag, struct dss__ZoneEndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneEndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneEndDimResponse, sizeof(struct dss__ZoneEndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneEndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneEndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneEndDimResponse, 0, sizeof(struct dss__ZoneEndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneEndDimResponse * SOAP_FMAC6 soap_new_dss__ZoneEndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneEndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneEndDimResponse(struct soap *soap, struct dss__ZoneEndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneEndDimResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneEndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneEndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneEndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneEndDimResponse;
		if (size)
			*size = sizeof(struct dss__ZoneEndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneEndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneEndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneEndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneEndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneEndDimResponse %p -> %p\n", q, p));
	*(struct dss__ZoneEndDimResponse*)p = *(struct dss__ZoneEndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneStartDim(struct soap *soap, struct dss__ZoneStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneStartDim(struct soap *soap, const struct dss__ZoneStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneStartDim(struct soap *soap, const struct dss__ZoneStartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneStartDim);
	if (soap_out_dss__ZoneStartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneStartDim(struct soap *soap, const char *tag, int id, const struct dss__ZoneStartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneStartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneStartDim * SOAP_FMAC4 soap_get_dss__ZoneStartDim(struct soap *soap, struct dss__ZoneStartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneStartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneStartDim * SOAP_FMAC4 soap_in_dss__ZoneStartDim(struct soap *soap, const char *tag, struct dss__ZoneStartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneStartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneStartDim, sizeof(struct dss__ZoneStartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneStartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneStartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneStartDim, 0, sizeof(struct dss__ZoneStartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneStartDim * SOAP_FMAC6 soap_new_dss__ZoneStartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneStartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneStartDim(struct soap *soap, struct dss__ZoneStartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneStartDim * SOAP_FMAC4 soap_instantiate_dss__ZoneStartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneStartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneStartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneStartDim;
		if (size)
			*size = sizeof(struct dss__ZoneStartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneStartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneStartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneStartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneStartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneStartDim %p -> %p\n", q, p));
	*(struct dss__ZoneStartDim*)p = *(struct dss__ZoneStartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneStartDimResponse(struct soap *soap, struct dss__ZoneStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneStartDimResponse(struct soap *soap, const struct dss__ZoneStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneStartDimResponse(struct soap *soap, const struct dss__ZoneStartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneStartDimResponse);
	if (soap_out_dss__ZoneStartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneStartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneStartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneStartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneStartDimResponse * SOAP_FMAC4 soap_get_dss__ZoneStartDimResponse(struct soap *soap, struct dss__ZoneStartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneStartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneStartDimResponse * SOAP_FMAC4 soap_in_dss__ZoneStartDimResponse(struct soap *soap, const char *tag, struct dss__ZoneStartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneStartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneStartDimResponse, sizeof(struct dss__ZoneStartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneStartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneStartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneStartDimResponse, 0, sizeof(struct dss__ZoneStartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneStartDimResponse * SOAP_FMAC6 soap_new_dss__ZoneStartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneStartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneStartDimResponse(struct soap *soap, struct dss__ZoneStartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneStartDimResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneStartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneStartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneStartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneStartDimResponse;
		if (size)
			*size = sizeof(struct dss__ZoneStartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneStartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneStartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneStartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneStartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneStartDimResponse %p -> %p\n", q, p));
	*(struct dss__ZoneStartDimResponse*)p = *(struct dss__ZoneStartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneDisable(struct soap *soap, struct dss__ZoneDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneDisable(struct soap *soap, const struct dss__ZoneDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneDisable(struct soap *soap, const struct dss__ZoneDisable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneDisable);
	if (soap_out_dss__ZoneDisable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneDisable(struct soap *soap, const char *tag, int id, const struct dss__ZoneDisable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneDisable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneDisable * SOAP_FMAC4 soap_get_dss__ZoneDisable(struct soap *soap, struct dss__ZoneDisable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneDisable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneDisable * SOAP_FMAC4 soap_in_dss__ZoneDisable(struct soap *soap, const char *tag, struct dss__ZoneDisable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneDisable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneDisable, sizeof(struct dss__ZoneDisable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneDisable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneDisable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneDisable, 0, sizeof(struct dss__ZoneDisable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneDisable * SOAP_FMAC6 soap_new_dss__ZoneDisable(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneDisable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneDisable(struct soap *soap, struct dss__ZoneDisable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneDisable * SOAP_FMAC4 soap_instantiate_dss__ZoneDisable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneDisable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneDisable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneDisable;
		if (size)
			*size = sizeof(struct dss__ZoneDisable);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneDisable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneDisable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneDisable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneDisable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneDisable %p -> %p\n", q, p));
	*(struct dss__ZoneDisable*)p = *(struct dss__ZoneDisable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneDisableResponse(struct soap *soap, struct dss__ZoneDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneDisableResponse(struct soap *soap, const struct dss__ZoneDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneDisableResponse(struct soap *soap, const struct dss__ZoneDisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneDisableResponse);
	if (soap_out_dss__ZoneDisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneDisableResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneDisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneDisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneDisableResponse * SOAP_FMAC4 soap_get_dss__ZoneDisableResponse(struct soap *soap, struct dss__ZoneDisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneDisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneDisableResponse * SOAP_FMAC4 soap_in_dss__ZoneDisableResponse(struct soap *soap, const char *tag, struct dss__ZoneDisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneDisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneDisableResponse, sizeof(struct dss__ZoneDisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneDisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneDisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneDisableResponse, 0, sizeof(struct dss__ZoneDisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneDisableResponse * SOAP_FMAC6 soap_new_dss__ZoneDisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneDisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneDisableResponse(struct soap *soap, struct dss__ZoneDisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneDisableResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneDisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneDisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneDisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneDisableResponse;
		if (size)
			*size = sizeof(struct dss__ZoneDisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneDisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneDisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneDisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneDisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneDisableResponse %p -> %p\n", q, p));
	*(struct dss__ZoneDisableResponse*)p = *(struct dss__ZoneDisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneEnable(struct soap *soap, struct dss__ZoneEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneEnable(struct soap *soap, const struct dss__ZoneEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneEnable(struct soap *soap, const struct dss__ZoneEnable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneEnable);
	if (soap_out_dss__ZoneEnable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneEnable(struct soap *soap, const char *tag, int id, const struct dss__ZoneEnable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneEnable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneEnable * SOAP_FMAC4 soap_get_dss__ZoneEnable(struct soap *soap, struct dss__ZoneEnable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneEnable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneEnable * SOAP_FMAC4 soap_in_dss__ZoneEnable(struct soap *soap, const char *tag, struct dss__ZoneEnable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneEnable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneEnable, sizeof(struct dss__ZoneEnable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneEnable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneEnable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneEnable, 0, sizeof(struct dss__ZoneEnable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneEnable * SOAP_FMAC6 soap_new_dss__ZoneEnable(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneEnable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneEnable(struct soap *soap, struct dss__ZoneEnable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneEnable * SOAP_FMAC4 soap_instantiate_dss__ZoneEnable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneEnable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneEnable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneEnable;
		if (size)
			*size = sizeof(struct dss__ZoneEnable);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneEnable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneEnable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneEnable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneEnable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneEnable %p -> %p\n", q, p));
	*(struct dss__ZoneEnable*)p = *(struct dss__ZoneEnable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneEnableResponse(struct soap *soap, struct dss__ZoneEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneEnableResponse(struct soap *soap, const struct dss__ZoneEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneEnableResponse(struct soap *soap, const struct dss__ZoneEnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneEnableResponse);
	if (soap_out_dss__ZoneEnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneEnableResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneEnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneEnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneEnableResponse * SOAP_FMAC4 soap_get_dss__ZoneEnableResponse(struct soap *soap, struct dss__ZoneEnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneEnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneEnableResponse * SOAP_FMAC4 soap_in_dss__ZoneEnableResponse(struct soap *soap, const char *tag, struct dss__ZoneEnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneEnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneEnableResponse, sizeof(struct dss__ZoneEnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneEnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneEnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneEnableResponse, 0, sizeof(struct dss__ZoneEnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneEnableResponse * SOAP_FMAC6 soap_new_dss__ZoneEnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneEnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneEnableResponse(struct soap *soap, struct dss__ZoneEnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneEnableResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneEnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneEnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneEnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneEnableResponse;
		if (size)
			*size = sizeof(struct dss__ZoneEnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneEnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneEnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneEnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneEnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneEnableResponse %p -> %p\n", q, p));
	*(struct dss__ZoneEnableResponse*)p = *(struct dss__ZoneEnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneDecreaseValue(struct soap *soap, struct dss__ZoneDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneDecreaseValue(struct soap *soap, const struct dss__ZoneDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneDecreaseValue(struct soap *soap, const struct dss__ZoneDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneDecreaseValue);
	if (soap_out_dss__ZoneDecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ZoneDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneDecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValue * SOAP_FMAC4 soap_get_dss__ZoneDecreaseValue(struct soap *soap, struct dss__ZoneDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneDecreaseValue * SOAP_FMAC4 soap_in_dss__ZoneDecreaseValue(struct soap *soap, const char *tag, struct dss__ZoneDecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneDecreaseValue, sizeof(struct dss__ZoneDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneDecreaseValue, 0, sizeof(struct dss__ZoneDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneDecreaseValue * SOAP_FMAC6 soap_new_dss__ZoneDecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneDecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneDecreaseValue(struct soap *soap, struct dss__ZoneDecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValue * SOAP_FMAC4 soap_instantiate_dss__ZoneDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneDecreaseValue;
		if (size)
			*size = sizeof(struct dss__ZoneDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneDecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneDecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneDecreaseValue %p -> %p\n", q, p));
	*(struct dss__ZoneDecreaseValue*)p = *(struct dss__ZoneDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneDecreaseValueResponse(struct soap *soap, struct dss__ZoneDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneDecreaseValueResponse(struct soap *soap, const struct dss__ZoneDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneDecreaseValueResponse(struct soap *soap, const struct dss__ZoneDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneDecreaseValueResponse);
	if (soap_out_dss__ZoneDecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__ZoneDecreaseValueResponse(struct soap *soap, struct dss__ZoneDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__ZoneDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__ZoneDecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneDecreaseValueResponse, sizeof(struct dss__ZoneDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneDecreaseValueResponse, 0, sizeof(struct dss__ZoneDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneDecreaseValueResponse * SOAP_FMAC6 soap_new_dss__ZoneDecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneDecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneDecreaseValueResponse(struct soap *soap, struct dss__ZoneDecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneDecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneDecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__ZoneDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneDecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneDecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ZoneDecreaseValueResponse*)p = *(struct dss__ZoneDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneIncreaseValue(struct soap *soap, struct dss__ZoneIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneIncreaseValue(struct soap *soap, const struct dss__ZoneIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneIncreaseValue(struct soap *soap, const struct dss__ZoneIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneIncreaseValue);
	if (soap_out_dss__ZoneIncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ZoneIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneIncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValue * SOAP_FMAC4 soap_get_dss__ZoneIncreaseValue(struct soap *soap, struct dss__ZoneIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneIncreaseValue * SOAP_FMAC4 soap_in_dss__ZoneIncreaseValue(struct soap *soap, const char *tag, struct dss__ZoneIncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneIncreaseValue, sizeof(struct dss__ZoneIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneIncreaseValue, 0, sizeof(struct dss__ZoneIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneIncreaseValue * SOAP_FMAC6 soap_new_dss__ZoneIncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneIncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneIncreaseValue(struct soap *soap, struct dss__ZoneIncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValue * SOAP_FMAC4 soap_instantiate_dss__ZoneIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneIncreaseValue;
		if (size)
			*size = sizeof(struct dss__ZoneIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneIncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneIncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneIncreaseValue %p -> %p\n", q, p));
	*(struct dss__ZoneIncreaseValue*)p = *(struct dss__ZoneIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneIncreaseValueResponse(struct soap *soap, struct dss__ZoneIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneIncreaseValueResponse(struct soap *soap, const struct dss__ZoneIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneIncreaseValueResponse(struct soap *soap, const struct dss__ZoneIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneIncreaseValueResponse);
	if (soap_out_dss__ZoneIncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__ZoneIncreaseValueResponse(struct soap *soap, struct dss__ZoneIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__ZoneIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__ZoneIncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneIncreaseValueResponse, sizeof(struct dss__ZoneIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneIncreaseValueResponse, 0, sizeof(struct dss__ZoneIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneIncreaseValueResponse * SOAP_FMAC6 soap_new_dss__ZoneIncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneIncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneIncreaseValueResponse(struct soap *soap, struct dss__ZoneIncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneIncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneIncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__ZoneIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneIncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneIncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ZoneIncreaseValueResponse*)p = *(struct dss__ZoneIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOff(struct soap *soap, struct dss__ZoneTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOff(struct soap *soap, const struct dss__ZoneTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOff(struct soap *soap, const struct dss__ZoneTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOff);
	if (soap_out_dss__ZoneTurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOff(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOff * SOAP_FMAC4 soap_get_dss__ZoneTurnOff(struct soap *soap, struct dss__ZoneTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneTurnOff * SOAP_FMAC4 soap_in_dss__ZoneTurnOff(struct soap *soap, const char *tag, struct dss__ZoneTurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOff, sizeof(struct dss__ZoneTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOff, 0, sizeof(struct dss__ZoneTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneTurnOff * SOAP_FMAC6 soap_new_dss__ZoneTurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneTurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneTurnOff(struct soap *soap, struct dss__ZoneTurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneTurnOff * SOAP_FMAC4 soap_instantiate_dss__ZoneTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneTurnOff;
		if (size)
			*size = sizeof(struct dss__ZoneTurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneTurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOff %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOff*)p = *(struct dss__ZoneTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOffResponse(struct soap *soap, struct dss__ZoneTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOffResponse(struct soap *soap, const struct dss__ZoneTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOffResponse(struct soap *soap, const struct dss__ZoneTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOffResponse);
	if (soap_out_dss__ZoneTurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOffResponse * SOAP_FMAC4 soap_get_dss__ZoneTurnOffResponse(struct soap *soap, struct dss__ZoneTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneTurnOffResponse * SOAP_FMAC4 soap_in_dss__ZoneTurnOffResponse(struct soap *soap, const char *tag, struct dss__ZoneTurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOffResponse, sizeof(struct dss__ZoneTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOffResponse, 0, sizeof(struct dss__ZoneTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneTurnOffResponse * SOAP_FMAC6 soap_new_dss__ZoneTurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneTurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneTurnOffResponse(struct soap *soap, struct dss__ZoneTurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneTurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneTurnOffResponse;
		if (size)
			*size = sizeof(struct dss__ZoneTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneTurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOffResponse*)p = *(struct dss__ZoneTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOn(struct soap *soap, struct dss__ZoneTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_zoneID);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOn(struct soap *soap, const struct dss__ZoneTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOn(struct soap *soap, const struct dss__ZoneTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOn);
	if (soap_out_dss__ZoneTurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOn(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->_zoneID, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOn * SOAP_FMAC4 soap_get_dss__ZoneTurnOn(struct soap *soap, struct dss__ZoneTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneTurnOn * SOAP_FMAC4 soap_in_dss__ZoneTurnOn(struct soap *soap, const char *tag, struct dss__ZoneTurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneID = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOn, sizeof(struct dss__ZoneTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_zoneID, "xsd:int"))
				{	soap_flag__zoneID--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOn, 0, sizeof(struct dss__ZoneTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__zoneID > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneTurnOn * SOAP_FMAC6 soap_new_dss__ZoneTurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneTurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneTurnOn(struct soap *soap, struct dss__ZoneTurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneTurnOn * SOAP_FMAC4 soap_instantiate_dss__ZoneTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneTurnOn;
		if (size)
			*size = sizeof(struct dss__ZoneTurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneTurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOn %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOn*)p = *(struct dss__ZoneTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ZoneTurnOnResponse(struct soap *soap, struct dss__ZoneTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ZoneTurnOnResponse(struct soap *soap, const struct dss__ZoneTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ZoneTurnOnResponse(struct soap *soap, const struct dss__ZoneTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ZoneTurnOnResponse);
	if (soap_out_dss__ZoneTurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ZoneTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__ZoneTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ZoneTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ZoneTurnOnResponse * SOAP_FMAC4 soap_get_dss__ZoneTurnOnResponse(struct soap *soap, struct dss__ZoneTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ZoneTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ZoneTurnOnResponse * SOAP_FMAC4 soap_in_dss__ZoneTurnOnResponse(struct soap *soap, const char *tag, struct dss__ZoneTurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ZoneTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ZoneTurnOnResponse, sizeof(struct dss__ZoneTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ZoneTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ZoneTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ZoneTurnOnResponse, 0, sizeof(struct dss__ZoneTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ZoneTurnOnResponse * SOAP_FMAC6 soap_new_dss__ZoneTurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ZoneTurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ZoneTurnOnResponse(struct soap *soap, struct dss__ZoneTurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ZoneTurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__ZoneTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ZoneTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ZoneTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ZoneTurnOnResponse;
		if (size)
			*size = sizeof(struct dss__ZoneTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ZoneTurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ZoneTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ZoneTurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ZoneTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ZoneTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__ZoneTurnOnResponse*)p = *(struct dss__ZoneTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__CircuitRescan(struct soap *soap, struct dss__CircuitRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_dsid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__CircuitRescan(struct soap *soap, const struct dss__CircuitRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_dsid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__CircuitRescan(struct soap *soap, const struct dss__CircuitRescan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__CircuitRescan);
	if (soap_out_dss__CircuitRescan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__CircuitRescan(struct soap *soap, const char *tag, int id, const struct dss__CircuitRescan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__CircuitRescan), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "dsid", -1, &a->_dsid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__CircuitRescan * SOAP_FMAC4 soap_get_dss__CircuitRescan(struct soap *soap, struct dss__CircuitRescan *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__CircuitRescan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__CircuitRescan * SOAP_FMAC4 soap_in_dss__CircuitRescan(struct soap *soap, const char *tag, struct dss__CircuitRescan *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__dsid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__CircuitRescan *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__CircuitRescan, sizeof(struct dss__CircuitRescan), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__CircuitRescan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__dsid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_dsid, "xsd:string"))
				{	soap_flag__dsid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__CircuitRescan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__CircuitRescan, 0, sizeof(struct dss__CircuitRescan), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__CircuitRescan * SOAP_FMAC6 soap_new_dss__CircuitRescan(struct soap *soap, int n)
{	return soap_instantiate_dss__CircuitRescan(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__CircuitRescan(struct soap *soap, struct dss__CircuitRescan *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__CircuitRescan * SOAP_FMAC4 soap_instantiate_dss__CircuitRescan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__CircuitRescan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__CircuitRescan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__CircuitRescan;
		if (size)
			*size = sizeof(struct dss__CircuitRescan);
	}
	else
	{	cp->ptr = (void*)new struct dss__CircuitRescan[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__CircuitRescan);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__CircuitRescan*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__CircuitRescan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__CircuitRescan %p -> %p\n", q, p));
	*(struct dss__CircuitRescan*)p = *(struct dss__CircuitRescan*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__CircuitRescanResponse(struct soap *soap, struct dss__CircuitRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__CircuitRescanResponse(struct soap *soap, const struct dss__CircuitRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__CircuitRescanResponse(struct soap *soap, const struct dss__CircuitRescanResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__CircuitRescanResponse);
	if (soap_out_dss__CircuitRescanResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__CircuitRescanResponse(struct soap *soap, const char *tag, int id, const struct dss__CircuitRescanResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__CircuitRescanResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__CircuitRescanResponse * SOAP_FMAC4 soap_get_dss__CircuitRescanResponse(struct soap *soap, struct dss__CircuitRescanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__CircuitRescanResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__CircuitRescanResponse * SOAP_FMAC4 soap_in_dss__CircuitRescanResponse(struct soap *soap, const char *tag, struct dss__CircuitRescanResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__CircuitRescanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__CircuitRescanResponse, sizeof(struct dss__CircuitRescanResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__CircuitRescanResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__CircuitRescanResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__CircuitRescanResponse, 0, sizeof(struct dss__CircuitRescanResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__CircuitRescanResponse * SOAP_FMAC6 soap_new_dss__CircuitRescanResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__CircuitRescanResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__CircuitRescanResponse(struct soap *soap, struct dss__CircuitRescanResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__CircuitRescanResponse * SOAP_FMAC4 soap_instantiate_dss__CircuitRescanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__CircuitRescanResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__CircuitRescanResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__CircuitRescanResponse;
		if (size)
			*size = sizeof(struct dss__CircuitRescanResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__CircuitRescanResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__CircuitRescanResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__CircuitRescanResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__CircuitRescanResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__CircuitRescanResponse %p -> %p\n", q, p));
	*(struct dss__CircuitRescanResponse*)p = *(struct dss__CircuitRescanResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentRescan(struct soap *soap, struct dss__ApartmentRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentRescan(struct soap *soap, const struct dss__ApartmentRescan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentRescan(struct soap *soap, const struct dss__ApartmentRescan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentRescan);
	if (soap_out_dss__ApartmentRescan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentRescan(struct soap *soap, const char *tag, int id, const struct dss__ApartmentRescan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentRescan), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentRescan * SOAP_FMAC4 soap_get_dss__ApartmentRescan(struct soap *soap, struct dss__ApartmentRescan *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentRescan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentRescan * SOAP_FMAC4 soap_in_dss__ApartmentRescan(struct soap *soap, const char *tag, struct dss__ApartmentRescan *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentRescan *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentRescan, sizeof(struct dss__ApartmentRescan), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentRescan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentRescan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentRescan, 0, sizeof(struct dss__ApartmentRescan), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentRescan * SOAP_FMAC6 soap_new_dss__ApartmentRescan(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentRescan(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentRescan(struct soap *soap, struct dss__ApartmentRescan *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentRescan * SOAP_FMAC4 soap_instantiate_dss__ApartmentRescan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentRescan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentRescan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentRescan;
		if (size)
			*size = sizeof(struct dss__ApartmentRescan);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentRescan[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentRescan);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentRescan*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentRescan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentRescan %p -> %p\n", q, p));
	*(struct dss__ApartmentRescan*)p = *(struct dss__ApartmentRescan*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentRescanResponse(struct soap *soap, struct dss__ApartmentRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentRescanResponse(struct soap *soap, const struct dss__ApartmentRescanResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentRescanResponse(struct soap *soap, const struct dss__ApartmentRescanResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentRescanResponse);
	if (soap_out_dss__ApartmentRescanResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentRescanResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentRescanResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentRescanResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentRescanResponse * SOAP_FMAC4 soap_get_dss__ApartmentRescanResponse(struct soap *soap, struct dss__ApartmentRescanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentRescanResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentRescanResponse * SOAP_FMAC4 soap_in_dss__ApartmentRescanResponse(struct soap *soap, const char *tag, struct dss__ApartmentRescanResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentRescanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentRescanResponse, sizeof(struct dss__ApartmentRescanResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentRescanResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentRescanResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentRescanResponse, 0, sizeof(struct dss__ApartmentRescanResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentRescanResponse * SOAP_FMAC6 soap_new_dss__ApartmentRescanResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentRescanResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentRescanResponse(struct soap *soap, struct dss__ApartmentRescanResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentRescanResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentRescanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentRescanResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentRescanResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentRescanResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentRescanResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentRescanResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentRescanResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentRescanResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentRescanResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentRescanResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentRescanResponse*)p = *(struct dss__ApartmentRescanResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSaveScene(struct soap *soap, struct dss__ApartmentSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSaveScene(struct soap *soap, const struct dss__ApartmentSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSaveScene(struct soap *soap, const struct dss__ApartmentSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSaveScene);
	if (soap_out_dss__ApartmentSaveScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSaveScene(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSaveScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSaveScene * SOAP_FMAC4 soap_get_dss__ApartmentSaveScene(struct soap *soap, struct dss__ApartmentSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentSaveScene * SOAP_FMAC4 soap_in_dss__ApartmentSaveScene(struct soap *soap, const char *tag, struct dss__ApartmentSaveScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSaveScene, sizeof(struct dss__ApartmentSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSaveScene, 0, sizeof(struct dss__ApartmentSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentSaveScene * SOAP_FMAC6 soap_new_dss__ApartmentSaveScene(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentSaveScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentSaveScene(struct soap *soap, struct dss__ApartmentSaveScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentSaveScene * SOAP_FMAC4 soap_instantiate_dss__ApartmentSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentSaveScene;
		if (size)
			*size = sizeof(struct dss__ApartmentSaveScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentSaveScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSaveScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSaveScene %p -> %p\n", q, p));
	*(struct dss__ApartmentSaveScene*)p = *(struct dss__ApartmentSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSaveSceneResponse(struct soap *soap, struct dss__ApartmentSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSaveSceneResponse(struct soap *soap, const struct dss__ApartmentSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSaveSceneResponse(struct soap *soap, const struct dss__ApartmentSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSaveSceneResponse);
	if (soap_out_dss__ApartmentSaveSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSaveSceneResponse * SOAP_FMAC4 soap_get_dss__ApartmentSaveSceneResponse(struct soap *soap, struct dss__ApartmentSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentSaveSceneResponse * SOAP_FMAC4 soap_in_dss__ApartmentSaveSceneResponse(struct soap *soap, const char *tag, struct dss__ApartmentSaveSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSaveSceneResponse, sizeof(struct dss__ApartmentSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSaveSceneResponse, 0, sizeof(struct dss__ApartmentSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentSaveSceneResponse * SOAP_FMAC6 soap_new_dss__ApartmentSaveSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentSaveSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentSaveSceneResponse(struct soap *soap, struct dss__ApartmentSaveSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentSaveSceneResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentSaveSceneResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentSaveSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSaveSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentSaveSceneResponse*)p = *(struct dss__ApartmentSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCallScene(struct soap *soap, struct dss__ApartmentCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCallScene(struct soap *soap, const struct dss__ApartmentCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCallScene(struct soap *soap, const struct dss__ApartmentCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCallScene);
	if (soap_out_dss__ApartmentCallScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCallScene(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCallScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCallScene * SOAP_FMAC4 soap_get_dss__ApartmentCallScene(struct soap *soap, struct dss__ApartmentCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCallScene * SOAP_FMAC4 soap_in_dss__ApartmentCallScene(struct soap *soap, const char *tag, struct dss__ApartmentCallScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCallScene, sizeof(struct dss__ApartmentCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCallScene, 0, sizeof(struct dss__ApartmentCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCallScene * SOAP_FMAC6 soap_new_dss__ApartmentCallScene(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCallScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCallScene(struct soap *soap, struct dss__ApartmentCallScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCallScene * SOAP_FMAC4 soap_instantiate_dss__ApartmentCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCallScene;
		if (size)
			*size = sizeof(struct dss__ApartmentCallScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCallScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCallScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCallScene %p -> %p\n", q, p));
	*(struct dss__ApartmentCallScene*)p = *(struct dss__ApartmentCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCallSceneResponse(struct soap *soap, struct dss__ApartmentCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCallSceneResponse(struct soap *soap, const struct dss__ApartmentCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCallSceneResponse(struct soap *soap, const struct dss__ApartmentCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCallSceneResponse);
	if (soap_out_dss__ApartmentCallSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCallSceneResponse * SOAP_FMAC4 soap_get_dss__ApartmentCallSceneResponse(struct soap *soap, struct dss__ApartmentCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCallSceneResponse * SOAP_FMAC4 soap_in_dss__ApartmentCallSceneResponse(struct soap *soap, const char *tag, struct dss__ApartmentCallSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCallSceneResponse, sizeof(struct dss__ApartmentCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCallSceneResponse, 0, sizeof(struct dss__ApartmentCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCallSceneResponse * SOAP_FMAC6 soap_new_dss__ApartmentCallSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCallSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCallSceneResponse(struct soap *soap, struct dss__ApartmentCallSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCallSceneResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCallSceneResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCallSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCallSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCallSceneResponse*)p = *(struct dss__ApartmentCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSetValue(struct soap *soap, struct dss__ApartmentSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSetValue(struct soap *soap, const struct dss__ApartmentSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSetValue(struct soap *soap, const struct dss__ApartmentSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSetValue);
	if (soap_out_dss__ApartmentSetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSetValue(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSetValue * SOAP_FMAC4 soap_get_dss__ApartmentSetValue(struct soap *soap, struct dss__ApartmentSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentSetValue * SOAP_FMAC4 soap_in_dss__ApartmentSetValue(struct soap *soap, const char *tag, struct dss__ApartmentSetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSetValue, sizeof(struct dss__ApartmentSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSetValue, 0, sizeof(struct dss__ApartmentSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentSetValue * SOAP_FMAC6 soap_new_dss__ApartmentSetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentSetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentSetValue(struct soap *soap, struct dss__ApartmentSetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentSetValue * SOAP_FMAC4 soap_instantiate_dss__ApartmentSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentSetValue;
		if (size)
			*size = sizeof(struct dss__ApartmentSetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentSetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSetValue %p -> %p\n", q, p));
	*(struct dss__ApartmentSetValue*)p = *(struct dss__ApartmentSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentSetValueResponse(struct soap *soap, struct dss__ApartmentSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentSetValueResponse(struct soap *soap, const struct dss__ApartmentSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentSetValueResponse(struct soap *soap, const struct dss__ApartmentSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentSetValueResponse);
	if (soap_out_dss__ApartmentSetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentSetValueResponse * SOAP_FMAC4 soap_get_dss__ApartmentSetValueResponse(struct soap *soap, struct dss__ApartmentSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentSetValueResponse * SOAP_FMAC4 soap_in_dss__ApartmentSetValueResponse(struct soap *soap, const char *tag, struct dss__ApartmentSetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentSetValueResponse, sizeof(struct dss__ApartmentSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentSetValueResponse, 0, sizeof(struct dss__ApartmentSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentSetValueResponse * SOAP_FMAC6 soap_new_dss__ApartmentSetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentSetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentSetValueResponse(struct soap *soap, struct dss__ApartmentSetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentSetValueResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentSetValueResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentSetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentSetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentSetValueResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentSetValueResponse*)p = *(struct dss__ApartmentSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentEndDim(struct soap *soap, struct dss__ApartmentEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentEndDim(struct soap *soap, const struct dss__ApartmentEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentEndDim(struct soap *soap, const struct dss__ApartmentEndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentEndDim);
	if (soap_out_dss__ApartmentEndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentEndDim(struct soap *soap, const char *tag, int id, const struct dss__ApartmentEndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentEndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentEndDim * SOAP_FMAC4 soap_get_dss__ApartmentEndDim(struct soap *soap, struct dss__ApartmentEndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentEndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentEndDim * SOAP_FMAC4 soap_in_dss__ApartmentEndDim(struct soap *soap, const char *tag, struct dss__ApartmentEndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentEndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentEndDim, sizeof(struct dss__ApartmentEndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentEndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentEndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentEndDim, 0, sizeof(struct dss__ApartmentEndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentEndDim * SOAP_FMAC6 soap_new_dss__ApartmentEndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentEndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentEndDim(struct soap *soap, struct dss__ApartmentEndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentEndDim * SOAP_FMAC4 soap_instantiate_dss__ApartmentEndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentEndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentEndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentEndDim;
		if (size)
			*size = sizeof(struct dss__ApartmentEndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentEndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentEndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentEndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentEndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentEndDim %p -> %p\n", q, p));
	*(struct dss__ApartmentEndDim*)p = *(struct dss__ApartmentEndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentEndDimResponse(struct soap *soap, struct dss__ApartmentEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentEndDimResponse(struct soap *soap, const struct dss__ApartmentEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentEndDimResponse(struct soap *soap, const struct dss__ApartmentEndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentEndDimResponse);
	if (soap_out_dss__ApartmentEndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentEndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentEndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentEndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentEndDimResponse * SOAP_FMAC4 soap_get_dss__ApartmentEndDimResponse(struct soap *soap, struct dss__ApartmentEndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentEndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentEndDimResponse * SOAP_FMAC4 soap_in_dss__ApartmentEndDimResponse(struct soap *soap, const char *tag, struct dss__ApartmentEndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentEndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentEndDimResponse, sizeof(struct dss__ApartmentEndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentEndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentEndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentEndDimResponse, 0, sizeof(struct dss__ApartmentEndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentEndDimResponse * SOAP_FMAC6 soap_new_dss__ApartmentEndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentEndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentEndDimResponse(struct soap *soap, struct dss__ApartmentEndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentEndDimResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentEndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentEndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentEndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentEndDimResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentEndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentEndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentEndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentEndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentEndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentEndDimResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentEndDimResponse*)p = *(struct dss__ApartmentEndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentStartDim(struct soap *soap, struct dss__ApartmentStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentStartDim(struct soap *soap, const struct dss__ApartmentStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentStartDim(struct soap *soap, const struct dss__ApartmentStartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentStartDim);
	if (soap_out_dss__ApartmentStartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentStartDim(struct soap *soap, const char *tag, int id, const struct dss__ApartmentStartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentStartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentStartDim * SOAP_FMAC4 soap_get_dss__ApartmentStartDim(struct soap *soap, struct dss__ApartmentStartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentStartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentStartDim * SOAP_FMAC4 soap_in_dss__ApartmentStartDim(struct soap *soap, const char *tag, struct dss__ApartmentStartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentStartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentStartDim, sizeof(struct dss__ApartmentStartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentStartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentStartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentStartDim, 0, sizeof(struct dss__ApartmentStartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentStartDim * SOAP_FMAC6 soap_new_dss__ApartmentStartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentStartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentStartDim(struct soap *soap, struct dss__ApartmentStartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentStartDim * SOAP_FMAC4 soap_instantiate_dss__ApartmentStartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentStartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentStartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentStartDim;
		if (size)
			*size = sizeof(struct dss__ApartmentStartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentStartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentStartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentStartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentStartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentStartDim %p -> %p\n", q, p));
	*(struct dss__ApartmentStartDim*)p = *(struct dss__ApartmentStartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentStartDimResponse(struct soap *soap, struct dss__ApartmentStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentStartDimResponse(struct soap *soap, const struct dss__ApartmentStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentStartDimResponse(struct soap *soap, const struct dss__ApartmentStartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentStartDimResponse);
	if (soap_out_dss__ApartmentStartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentStartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentStartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentStartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentStartDimResponse * SOAP_FMAC4 soap_get_dss__ApartmentStartDimResponse(struct soap *soap, struct dss__ApartmentStartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentStartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentStartDimResponse * SOAP_FMAC4 soap_in_dss__ApartmentStartDimResponse(struct soap *soap, const char *tag, struct dss__ApartmentStartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentStartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentStartDimResponse, sizeof(struct dss__ApartmentStartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentStartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentStartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentStartDimResponse, 0, sizeof(struct dss__ApartmentStartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentStartDimResponse * SOAP_FMAC6 soap_new_dss__ApartmentStartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentStartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentStartDimResponse(struct soap *soap, struct dss__ApartmentStartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentStartDimResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentStartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentStartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentStartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentStartDimResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentStartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentStartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentStartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentStartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentStartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentStartDimResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentStartDimResponse*)p = *(struct dss__ApartmentStartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDisable(struct soap *soap, struct dss__ApartmentDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDisable(struct soap *soap, const struct dss__ApartmentDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDisable(struct soap *soap, const struct dss__ApartmentDisable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDisable);
	if (soap_out_dss__ApartmentDisable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDisable(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDisable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDisable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDisable * SOAP_FMAC4 soap_get_dss__ApartmentDisable(struct soap *soap, struct dss__ApartmentDisable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDisable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentDisable * SOAP_FMAC4 soap_in_dss__ApartmentDisable(struct soap *soap, const char *tag, struct dss__ApartmentDisable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDisable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDisable, sizeof(struct dss__ApartmentDisable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDisable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDisable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDisable, 0, sizeof(struct dss__ApartmentDisable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentDisable * SOAP_FMAC6 soap_new_dss__ApartmentDisable(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentDisable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentDisable(struct soap *soap, struct dss__ApartmentDisable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentDisable * SOAP_FMAC4 soap_instantiate_dss__ApartmentDisable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDisable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDisable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentDisable;
		if (size)
			*size = sizeof(struct dss__ApartmentDisable);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentDisable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDisable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDisable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDisable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDisable %p -> %p\n", q, p));
	*(struct dss__ApartmentDisable*)p = *(struct dss__ApartmentDisable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDisableResponse(struct soap *soap, struct dss__ApartmentDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDisableResponse(struct soap *soap, const struct dss__ApartmentDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDisableResponse(struct soap *soap, const struct dss__ApartmentDisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDisableResponse);
	if (soap_out_dss__ApartmentDisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDisableResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDisableResponse * SOAP_FMAC4 soap_get_dss__ApartmentDisableResponse(struct soap *soap, struct dss__ApartmentDisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentDisableResponse * SOAP_FMAC4 soap_in_dss__ApartmentDisableResponse(struct soap *soap, const char *tag, struct dss__ApartmentDisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDisableResponse, sizeof(struct dss__ApartmentDisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDisableResponse, 0, sizeof(struct dss__ApartmentDisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentDisableResponse * SOAP_FMAC6 soap_new_dss__ApartmentDisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentDisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentDisableResponse(struct soap *soap, struct dss__ApartmentDisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentDisableResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentDisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentDisableResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentDisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentDisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDisableResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentDisableResponse*)p = *(struct dss__ApartmentDisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentEnable(struct soap *soap, struct dss__ApartmentEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentEnable(struct soap *soap, const struct dss__ApartmentEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentEnable(struct soap *soap, const struct dss__ApartmentEnable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentEnable);
	if (soap_out_dss__ApartmentEnable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentEnable(struct soap *soap, const char *tag, int id, const struct dss__ApartmentEnable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentEnable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentEnable * SOAP_FMAC4 soap_get_dss__ApartmentEnable(struct soap *soap, struct dss__ApartmentEnable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentEnable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentEnable * SOAP_FMAC4 soap_in_dss__ApartmentEnable(struct soap *soap, const char *tag, struct dss__ApartmentEnable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentEnable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentEnable, sizeof(struct dss__ApartmentEnable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentEnable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentEnable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentEnable, 0, sizeof(struct dss__ApartmentEnable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentEnable * SOAP_FMAC6 soap_new_dss__ApartmentEnable(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentEnable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentEnable(struct soap *soap, struct dss__ApartmentEnable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentEnable * SOAP_FMAC4 soap_instantiate_dss__ApartmentEnable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentEnable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentEnable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentEnable;
		if (size)
			*size = sizeof(struct dss__ApartmentEnable);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentEnable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentEnable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentEnable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentEnable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentEnable %p -> %p\n", q, p));
	*(struct dss__ApartmentEnable*)p = *(struct dss__ApartmentEnable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentEnableResponse(struct soap *soap, struct dss__ApartmentEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentEnableResponse(struct soap *soap, const struct dss__ApartmentEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentEnableResponse(struct soap *soap, const struct dss__ApartmentEnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentEnableResponse);
	if (soap_out_dss__ApartmentEnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentEnableResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentEnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentEnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentEnableResponse * SOAP_FMAC4 soap_get_dss__ApartmentEnableResponse(struct soap *soap, struct dss__ApartmentEnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentEnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentEnableResponse * SOAP_FMAC4 soap_in_dss__ApartmentEnableResponse(struct soap *soap, const char *tag, struct dss__ApartmentEnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentEnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentEnableResponse, sizeof(struct dss__ApartmentEnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentEnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentEnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentEnableResponse, 0, sizeof(struct dss__ApartmentEnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentEnableResponse * SOAP_FMAC6 soap_new_dss__ApartmentEnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentEnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentEnableResponse(struct soap *soap, struct dss__ApartmentEnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentEnableResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentEnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentEnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentEnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentEnableResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentEnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentEnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentEnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentEnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentEnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentEnableResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentEnableResponse*)p = *(struct dss__ApartmentEnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDecreaseValue(struct soap *soap, struct dss__ApartmentDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDecreaseValue(struct soap *soap, const struct dss__ApartmentDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDecreaseValue(struct soap *soap, const struct dss__ApartmentDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDecreaseValue);
	if (soap_out_dss__ApartmentDecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValue * SOAP_FMAC4 soap_get_dss__ApartmentDecreaseValue(struct soap *soap, struct dss__ApartmentDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValue * SOAP_FMAC4 soap_in_dss__ApartmentDecreaseValue(struct soap *soap, const char *tag, struct dss__ApartmentDecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDecreaseValue, sizeof(struct dss__ApartmentDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDecreaseValue, 0, sizeof(struct dss__ApartmentDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentDecreaseValue * SOAP_FMAC6 soap_new_dss__ApartmentDecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentDecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentDecreaseValue(struct soap *soap, struct dss__ApartmentDecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValue * SOAP_FMAC4 soap_instantiate_dss__ApartmentDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentDecreaseValue;
		if (size)
			*size = sizeof(struct dss__ApartmentDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentDecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDecreaseValue %p -> %p\n", q, p));
	*(struct dss__ApartmentDecreaseValue*)p = *(struct dss__ApartmentDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentDecreaseValueResponse(struct soap *soap, struct dss__ApartmentDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentDecreaseValueResponse(struct soap *soap, const struct dss__ApartmentDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentDecreaseValueResponse(struct soap *soap, const struct dss__ApartmentDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentDecreaseValueResponse);
	if (soap_out_dss__ApartmentDecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__ApartmentDecreaseValueResponse(struct soap *soap, struct dss__ApartmentDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__ApartmentDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__ApartmentDecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentDecreaseValueResponse, sizeof(struct dss__ApartmentDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentDecreaseValueResponse, 0, sizeof(struct dss__ApartmentDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentDecreaseValueResponse * SOAP_FMAC6 soap_new_dss__ApartmentDecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentDecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentDecreaseValueResponse(struct soap *soap, struct dss__ApartmentDecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentDecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentDecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentDecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentDecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentDecreaseValueResponse*)p = *(struct dss__ApartmentDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentIncreaseValue(struct soap *soap, struct dss__ApartmentIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentIncreaseValue(struct soap *soap, const struct dss__ApartmentIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentIncreaseValue(struct soap *soap, const struct dss__ApartmentIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentIncreaseValue);
	if (soap_out_dss__ApartmentIncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__ApartmentIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentIncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValue * SOAP_FMAC4 soap_get_dss__ApartmentIncreaseValue(struct soap *soap, struct dss__ApartmentIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValue * SOAP_FMAC4 soap_in_dss__ApartmentIncreaseValue(struct soap *soap, const char *tag, struct dss__ApartmentIncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentIncreaseValue, sizeof(struct dss__ApartmentIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentIncreaseValue, 0, sizeof(struct dss__ApartmentIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentIncreaseValue * SOAP_FMAC6 soap_new_dss__ApartmentIncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentIncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentIncreaseValue(struct soap *soap, struct dss__ApartmentIncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValue * SOAP_FMAC4 soap_instantiate_dss__ApartmentIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentIncreaseValue;
		if (size)
			*size = sizeof(struct dss__ApartmentIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentIncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentIncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentIncreaseValue %p -> %p\n", q, p));
	*(struct dss__ApartmentIncreaseValue*)p = *(struct dss__ApartmentIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentIncreaseValueResponse(struct soap *soap, struct dss__ApartmentIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentIncreaseValueResponse(struct soap *soap, const struct dss__ApartmentIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentIncreaseValueResponse(struct soap *soap, const struct dss__ApartmentIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentIncreaseValueResponse);
	if (soap_out_dss__ApartmentIncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__ApartmentIncreaseValueResponse(struct soap *soap, struct dss__ApartmentIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__ApartmentIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__ApartmentIncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentIncreaseValueResponse, sizeof(struct dss__ApartmentIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentIncreaseValueResponse, 0, sizeof(struct dss__ApartmentIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentIncreaseValueResponse * SOAP_FMAC6 soap_new_dss__ApartmentIncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentIncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentIncreaseValueResponse(struct soap *soap, struct dss__ApartmentIncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentIncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentIncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentIncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentIncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentIncreaseValueResponse*)p = *(struct dss__ApartmentIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOff(struct soap *soap, struct dss__ApartmentTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOff(struct soap *soap, const struct dss__ApartmentTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOff(struct soap *soap, const struct dss__ApartmentTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOff);
	if (soap_out_dss__ApartmentTurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOff(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOff * SOAP_FMAC4 soap_get_dss__ApartmentTurnOff(struct soap *soap, struct dss__ApartmentTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentTurnOff * SOAP_FMAC4 soap_in_dss__ApartmentTurnOff(struct soap *soap, const char *tag, struct dss__ApartmentTurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOff, sizeof(struct dss__ApartmentTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOff, 0, sizeof(struct dss__ApartmentTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentTurnOff * SOAP_FMAC6 soap_new_dss__ApartmentTurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentTurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentTurnOff(struct soap *soap, struct dss__ApartmentTurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentTurnOff * SOAP_FMAC4 soap_instantiate_dss__ApartmentTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOff;
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOff %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOff*)p = *(struct dss__ApartmentTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOffResponse(struct soap *soap, struct dss__ApartmentTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOffResponse(struct soap *soap, const struct dss__ApartmentTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOffResponse(struct soap *soap, const struct dss__ApartmentTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOffResponse);
	if (soap_out_dss__ApartmentTurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOffResponse * SOAP_FMAC4 soap_get_dss__ApartmentTurnOffResponse(struct soap *soap, struct dss__ApartmentTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentTurnOffResponse * SOAP_FMAC4 soap_in_dss__ApartmentTurnOffResponse(struct soap *soap, const char *tag, struct dss__ApartmentTurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOffResponse, sizeof(struct dss__ApartmentTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOffResponse, 0, sizeof(struct dss__ApartmentTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentTurnOffResponse * SOAP_FMAC6 soap_new_dss__ApartmentTurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentTurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentTurnOffResponse(struct soap *soap, struct dss__ApartmentTurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentTurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOffResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOffResponse*)p = *(struct dss__ApartmentTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOn(struct soap *soap, struct dss__ApartmentTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOn(struct soap *soap, const struct dss__ApartmentTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOn(struct soap *soap, const struct dss__ApartmentTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOn);
	if (soap_out_dss__ApartmentTurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOn(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOn * SOAP_FMAC4 soap_get_dss__ApartmentTurnOn(struct soap *soap, struct dss__ApartmentTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentTurnOn * SOAP_FMAC4 soap_in_dss__ApartmentTurnOn(struct soap *soap, const char *tag, struct dss__ApartmentTurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOn, sizeof(struct dss__ApartmentTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOn, 0, sizeof(struct dss__ApartmentTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentTurnOn * SOAP_FMAC6 soap_new_dss__ApartmentTurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentTurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentTurnOn(struct soap *soap, struct dss__ApartmentTurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentTurnOn * SOAP_FMAC4 soap_instantiate_dss__ApartmentTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOn;
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOn %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOn*)p = *(struct dss__ApartmentTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentTurnOnResponse(struct soap *soap, struct dss__ApartmentTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentTurnOnResponse(struct soap *soap, const struct dss__ApartmentTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentTurnOnResponse(struct soap *soap, const struct dss__ApartmentTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentTurnOnResponse);
	if (soap_out_dss__ApartmentTurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentTurnOnResponse * SOAP_FMAC4 soap_get_dss__ApartmentTurnOnResponse(struct soap *soap, struct dss__ApartmentTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentTurnOnResponse * SOAP_FMAC4 soap_in_dss__ApartmentTurnOnResponse(struct soap *soap, const char *tag, struct dss__ApartmentTurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentTurnOnResponse, sizeof(struct dss__ApartmentTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentTurnOnResponse, 0, sizeof(struct dss__ApartmentTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentTurnOnResponse * SOAP_FMAC6 soap_new_dss__ApartmentTurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentTurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentTurnOnResponse(struct soap *soap, struct dss__ApartmentTurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentTurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOnResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentTurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentTurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentTurnOnResponse*)p = *(struct dss__ApartmentTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSaveScene(struct soap *soap, struct dss__SetSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSaveScene(struct soap *soap, const struct dss__SetSaveScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSaveScene(struct soap *soap, const struct dss__SetSaveScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSaveScene);
	if (soap_out_dss__SetSaveScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSaveScene(struct soap *soap, const char *tag, int id, const struct dss__SetSaveScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSaveScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSaveScene * SOAP_FMAC4 soap_get_dss__SetSaveScene(struct soap *soap, struct dss__SetSaveScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSaveScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetSaveScene * SOAP_FMAC4 soap_in_dss__SetSaveScene(struct soap *soap, const char *tag, struct dss__SetSaveScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSaveScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSaveScene, sizeof(struct dss__SetSaveScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSaveScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSaveScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSaveScene, 0, sizeof(struct dss__SetSaveScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetSaveScene * SOAP_FMAC6 soap_new_dss__SetSaveScene(struct soap *soap, int n)
{	return soap_instantiate_dss__SetSaveScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetSaveScene(struct soap *soap, struct dss__SetSaveScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetSaveScene * SOAP_FMAC4 soap_instantiate_dss__SetSaveScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSaveScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSaveScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetSaveScene;
		if (size)
			*size = sizeof(struct dss__SetSaveScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetSaveScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSaveScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSaveScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSaveScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSaveScene %p -> %p\n", q, p));
	*(struct dss__SetSaveScene*)p = *(struct dss__SetSaveScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSaveSceneResponse(struct soap *soap, struct dss__SetSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSaveSceneResponse(struct soap *soap, const struct dss__SetSaveSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSaveSceneResponse(struct soap *soap, const struct dss__SetSaveSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSaveSceneResponse);
	if (soap_out_dss__SetSaveSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSaveSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__SetSaveSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSaveSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSaveSceneResponse * SOAP_FMAC4 soap_get_dss__SetSaveSceneResponse(struct soap *soap, struct dss__SetSaveSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSaveSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetSaveSceneResponse * SOAP_FMAC4 soap_in_dss__SetSaveSceneResponse(struct soap *soap, const char *tag, struct dss__SetSaveSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSaveSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSaveSceneResponse, sizeof(struct dss__SetSaveSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSaveSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSaveSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSaveSceneResponse, 0, sizeof(struct dss__SetSaveSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetSaveSceneResponse * SOAP_FMAC6 soap_new_dss__SetSaveSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetSaveSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetSaveSceneResponse(struct soap *soap, struct dss__SetSaveSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetSaveSceneResponse * SOAP_FMAC4 soap_instantiate_dss__SetSaveSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSaveSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSaveSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetSaveSceneResponse;
		if (size)
			*size = sizeof(struct dss__SetSaveSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetSaveSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSaveSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSaveSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSaveSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSaveSceneResponse %p -> %p\n", q, p));
	*(struct dss__SetSaveSceneResponse*)p = *(struct dss__SetSaveSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCallScene(struct soap *soap, struct dss__SetCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_sceneNr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCallScene(struct soap *soap, const struct dss__SetCallScene *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCallScene(struct soap *soap, const struct dss__SetCallScene *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCallScene);
	if (soap_out_dss__SetCallScene(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCallScene(struct soap *soap, const char *tag, int id, const struct dss__SetCallScene *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCallScene), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "sceneNr", -1, &a->_sceneNr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCallScene * SOAP_FMAC4 soap_get_dss__SetCallScene(struct soap *soap, struct dss__SetCallScene *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCallScene(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetCallScene * SOAP_FMAC4 soap_in_dss__SetCallScene(struct soap *soap, const char *tag, struct dss__SetCallScene *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__sceneNr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCallScene *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCallScene, sizeof(struct dss__SetCallScene), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetCallScene(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__sceneNr && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_sceneNr, "xsd:int"))
				{	soap_flag__sceneNr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCallScene *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCallScene, 0, sizeof(struct dss__SetCallScene), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__sceneNr > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetCallScene * SOAP_FMAC6 soap_new_dss__SetCallScene(struct soap *soap, int n)
{	return soap_instantiate_dss__SetCallScene(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetCallScene(struct soap *soap, struct dss__SetCallScene *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetCallScene * SOAP_FMAC4 soap_instantiate_dss__SetCallScene(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCallScene(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCallScene, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetCallScene;
		if (size)
			*size = sizeof(struct dss__SetCallScene);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetCallScene[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCallScene);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCallScene*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCallScene(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCallScene %p -> %p\n", q, p));
	*(struct dss__SetCallScene*)p = *(struct dss__SetCallScene*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCallSceneResponse(struct soap *soap, struct dss__SetCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCallSceneResponse(struct soap *soap, const struct dss__SetCallSceneResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCallSceneResponse(struct soap *soap, const struct dss__SetCallSceneResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCallSceneResponse);
	if (soap_out_dss__SetCallSceneResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCallSceneResponse(struct soap *soap, const char *tag, int id, const struct dss__SetCallSceneResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCallSceneResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCallSceneResponse * SOAP_FMAC4 soap_get_dss__SetCallSceneResponse(struct soap *soap, struct dss__SetCallSceneResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCallSceneResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetCallSceneResponse * SOAP_FMAC4 soap_in_dss__SetCallSceneResponse(struct soap *soap, const char *tag, struct dss__SetCallSceneResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCallSceneResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCallSceneResponse, sizeof(struct dss__SetCallSceneResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetCallSceneResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCallSceneResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCallSceneResponse, 0, sizeof(struct dss__SetCallSceneResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetCallSceneResponse * SOAP_FMAC6 soap_new_dss__SetCallSceneResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetCallSceneResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetCallSceneResponse(struct soap *soap, struct dss__SetCallSceneResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetCallSceneResponse * SOAP_FMAC4 soap_instantiate_dss__SetCallSceneResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCallSceneResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCallSceneResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetCallSceneResponse;
		if (size)
			*size = sizeof(struct dss__SetCallSceneResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetCallSceneResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCallSceneResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCallSceneResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCallSceneResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCallSceneResponse %p -> %p\n", q, p));
	*(struct dss__SetCallSceneResponse*)p = *(struct dss__SetCallSceneResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSetValue(struct soap *soap, struct dss__SetSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_double(soap, &a->_value);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSetValue(struct soap *soap, const struct dss__SetSetValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSetValue(struct soap *soap, const struct dss__SetSetValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSetValue);
	if (soap_out_dss__SetSetValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSetValue(struct soap *soap, const char *tag, int id, const struct dss__SetSetValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSetValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &a->_value, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSetValue * SOAP_FMAC4 soap_get_dss__SetSetValue(struct soap *soap, struct dss__SetSetValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSetValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetSetValue * SOAP_FMAC4 soap_in_dss__SetSetValue(struct soap *soap, const char *tag, struct dss__SetSetValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__value = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSetValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSetValue, sizeof(struct dss__SetSetValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSetValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, NULL, &a->_value, "xsd:double"))
				{	soap_flag__value--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSetValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSetValue, 0, sizeof(struct dss__SetSetValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__value > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetSetValue * SOAP_FMAC6 soap_new_dss__SetSetValue(struct soap *soap, int n)
{	return soap_instantiate_dss__SetSetValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetSetValue(struct soap *soap, struct dss__SetSetValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetSetValue * SOAP_FMAC4 soap_instantiate_dss__SetSetValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSetValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSetValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetSetValue;
		if (size)
			*size = sizeof(struct dss__SetSetValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetSetValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSetValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSetValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSetValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSetValue %p -> %p\n", q, p));
	*(struct dss__SetSetValue*)p = *(struct dss__SetSetValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetSetValueResponse(struct soap *soap, struct dss__SetSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetSetValueResponse(struct soap *soap, const struct dss__SetSetValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetSetValueResponse(struct soap *soap, const struct dss__SetSetValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetSetValueResponse);
	if (soap_out_dss__SetSetValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetSetValueResponse(struct soap *soap, const char *tag, int id, const struct dss__SetSetValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetSetValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetSetValueResponse * SOAP_FMAC4 soap_get_dss__SetSetValueResponse(struct soap *soap, struct dss__SetSetValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetSetValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetSetValueResponse * SOAP_FMAC4 soap_in_dss__SetSetValueResponse(struct soap *soap, const char *tag, struct dss__SetSetValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetSetValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetSetValueResponse, sizeof(struct dss__SetSetValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetSetValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetSetValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetSetValueResponse, 0, sizeof(struct dss__SetSetValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetSetValueResponse * SOAP_FMAC6 soap_new_dss__SetSetValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetSetValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetSetValueResponse(struct soap *soap, struct dss__SetSetValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetSetValueResponse * SOAP_FMAC4 soap_instantiate_dss__SetSetValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetSetValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetSetValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetSetValueResponse;
		if (size)
			*size = sizeof(struct dss__SetSetValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetSetValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetSetValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetSetValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetSetValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetSetValueResponse %p -> %p\n", q, p));
	*(struct dss__SetSetValueResponse*)p = *(struct dss__SetSetValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetEndDim(struct soap *soap, struct dss__SetEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetEndDim(struct soap *soap, const struct dss__SetEndDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetEndDim(struct soap *soap, const struct dss__SetEndDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetEndDim);
	if (soap_out_dss__SetEndDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetEndDim(struct soap *soap, const char *tag, int id, const struct dss__SetEndDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetEndDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetEndDim * SOAP_FMAC4 soap_get_dss__SetEndDim(struct soap *soap, struct dss__SetEndDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetEndDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetEndDim * SOAP_FMAC4 soap_in_dss__SetEndDim(struct soap *soap, const char *tag, struct dss__SetEndDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetEndDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetEndDim, sizeof(struct dss__SetEndDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetEndDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetEndDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetEndDim, 0, sizeof(struct dss__SetEndDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetEndDim * SOAP_FMAC6 soap_new_dss__SetEndDim(struct soap *soap, int n)
{	return soap_instantiate_dss__SetEndDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetEndDim(struct soap *soap, struct dss__SetEndDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetEndDim * SOAP_FMAC4 soap_instantiate_dss__SetEndDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetEndDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetEndDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetEndDim;
		if (size)
			*size = sizeof(struct dss__SetEndDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetEndDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetEndDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetEndDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetEndDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetEndDim %p -> %p\n", q, p));
	*(struct dss__SetEndDim*)p = *(struct dss__SetEndDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetEndDimResponse(struct soap *soap, struct dss__SetEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetEndDimResponse(struct soap *soap, const struct dss__SetEndDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetEndDimResponse(struct soap *soap, const struct dss__SetEndDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetEndDimResponse);
	if (soap_out_dss__SetEndDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetEndDimResponse(struct soap *soap, const char *tag, int id, const struct dss__SetEndDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetEndDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetEndDimResponse * SOAP_FMAC4 soap_get_dss__SetEndDimResponse(struct soap *soap, struct dss__SetEndDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetEndDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetEndDimResponse * SOAP_FMAC4 soap_in_dss__SetEndDimResponse(struct soap *soap, const char *tag, struct dss__SetEndDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetEndDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetEndDimResponse, sizeof(struct dss__SetEndDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetEndDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetEndDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetEndDimResponse, 0, sizeof(struct dss__SetEndDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetEndDimResponse * SOAP_FMAC6 soap_new_dss__SetEndDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetEndDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetEndDimResponse(struct soap *soap, struct dss__SetEndDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetEndDimResponse * SOAP_FMAC4 soap_instantiate_dss__SetEndDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetEndDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetEndDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetEndDimResponse;
		if (size)
			*size = sizeof(struct dss__SetEndDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetEndDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetEndDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetEndDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetEndDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetEndDimResponse %p -> %p\n", q, p));
	*(struct dss__SetEndDimResponse*)p = *(struct dss__SetEndDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetStartDim(struct soap *soap, struct dss__SetStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_bool(soap, &a->_directionUp);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetStartDim(struct soap *soap, const struct dss__SetStartDim *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetStartDim(struct soap *soap, const struct dss__SetStartDim *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetStartDim);
	if (soap_out_dss__SetStartDim(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetStartDim(struct soap *soap, const char *tag, int id, const struct dss__SetStartDim *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetStartDim), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_bool(soap, "directionUp", -1, &a->_directionUp, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetStartDim * SOAP_FMAC4 soap_get_dss__SetStartDim(struct soap *soap, struct dss__SetStartDim *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetStartDim(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetStartDim * SOAP_FMAC4 soap_in_dss__SetStartDim(struct soap *soap, const char *tag, struct dss__SetStartDim *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__directionUp = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetStartDim *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetStartDim, sizeof(struct dss__SetStartDim), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetStartDim(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__directionUp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_directionUp, "xsd:boolean"))
				{	soap_flag__directionUp--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetStartDim *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetStartDim, 0, sizeof(struct dss__SetStartDim), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__directionUp > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetStartDim * SOAP_FMAC6 soap_new_dss__SetStartDim(struct soap *soap, int n)
{	return soap_instantiate_dss__SetStartDim(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetStartDim(struct soap *soap, struct dss__SetStartDim *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetStartDim * SOAP_FMAC4 soap_instantiate_dss__SetStartDim(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetStartDim(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetStartDim, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetStartDim;
		if (size)
			*size = sizeof(struct dss__SetStartDim);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetStartDim[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetStartDim);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetStartDim*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetStartDim(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetStartDim %p -> %p\n", q, p));
	*(struct dss__SetStartDim*)p = *(struct dss__SetStartDim*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetStartDimResponse(struct soap *soap, struct dss__SetStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetStartDimResponse(struct soap *soap, const struct dss__SetStartDimResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetStartDimResponse(struct soap *soap, const struct dss__SetStartDimResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetStartDimResponse);
	if (soap_out_dss__SetStartDimResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetStartDimResponse(struct soap *soap, const char *tag, int id, const struct dss__SetStartDimResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetStartDimResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetStartDimResponse * SOAP_FMAC4 soap_get_dss__SetStartDimResponse(struct soap *soap, struct dss__SetStartDimResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetStartDimResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetStartDimResponse * SOAP_FMAC4 soap_in_dss__SetStartDimResponse(struct soap *soap, const char *tag, struct dss__SetStartDimResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetStartDimResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetStartDimResponse, sizeof(struct dss__SetStartDimResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetStartDimResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetStartDimResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetStartDimResponse, 0, sizeof(struct dss__SetStartDimResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetStartDimResponse * SOAP_FMAC6 soap_new_dss__SetStartDimResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetStartDimResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetStartDimResponse(struct soap *soap, struct dss__SetStartDimResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetStartDimResponse * SOAP_FMAC4 soap_instantiate_dss__SetStartDimResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetStartDimResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetStartDimResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetStartDimResponse;
		if (size)
			*size = sizeof(struct dss__SetStartDimResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetStartDimResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetStartDimResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetStartDimResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetStartDimResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetStartDimResponse %p -> %p\n", q, p));
	*(struct dss__SetStartDimResponse*)p = *(struct dss__SetStartDimResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetDisable(struct soap *soap, struct dss__SetDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetDisable(struct soap *soap, const struct dss__SetDisable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetDisable(struct soap *soap, const struct dss__SetDisable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetDisable);
	if (soap_out_dss__SetDisable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetDisable(struct soap *soap, const char *tag, int id, const struct dss__SetDisable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetDisable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetDisable * SOAP_FMAC4 soap_get_dss__SetDisable(struct soap *soap, struct dss__SetDisable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetDisable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetDisable * SOAP_FMAC4 soap_in_dss__SetDisable(struct soap *soap, const char *tag, struct dss__SetDisable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetDisable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetDisable, sizeof(struct dss__SetDisable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetDisable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetDisable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetDisable, 0, sizeof(struct dss__SetDisable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetDisable * SOAP_FMAC6 soap_new_dss__SetDisable(struct soap *soap, int n)
{	return soap_instantiate_dss__SetDisable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetDisable(struct soap *soap, struct dss__SetDisable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetDisable * SOAP_FMAC4 soap_instantiate_dss__SetDisable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetDisable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetDisable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetDisable;
		if (size)
			*size = sizeof(struct dss__SetDisable);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetDisable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetDisable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetDisable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetDisable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetDisable %p -> %p\n", q, p));
	*(struct dss__SetDisable*)p = *(struct dss__SetDisable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetDisableResponse(struct soap *soap, struct dss__SetDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetDisableResponse(struct soap *soap, const struct dss__SetDisableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetDisableResponse(struct soap *soap, const struct dss__SetDisableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetDisableResponse);
	if (soap_out_dss__SetDisableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetDisableResponse(struct soap *soap, const char *tag, int id, const struct dss__SetDisableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetDisableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetDisableResponse * SOAP_FMAC4 soap_get_dss__SetDisableResponse(struct soap *soap, struct dss__SetDisableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetDisableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetDisableResponse * SOAP_FMAC4 soap_in_dss__SetDisableResponse(struct soap *soap, const char *tag, struct dss__SetDisableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetDisableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetDisableResponse, sizeof(struct dss__SetDisableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetDisableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetDisableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetDisableResponse, 0, sizeof(struct dss__SetDisableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetDisableResponse * SOAP_FMAC6 soap_new_dss__SetDisableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetDisableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetDisableResponse(struct soap *soap, struct dss__SetDisableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetDisableResponse * SOAP_FMAC4 soap_instantiate_dss__SetDisableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetDisableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetDisableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetDisableResponse;
		if (size)
			*size = sizeof(struct dss__SetDisableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetDisableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetDisableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetDisableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetDisableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetDisableResponse %p -> %p\n", q, p));
	*(struct dss__SetDisableResponse*)p = *(struct dss__SetDisableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetEnable(struct soap *soap, struct dss__SetEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetEnable(struct soap *soap, const struct dss__SetEnable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetEnable(struct soap *soap, const struct dss__SetEnable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetEnable);
	if (soap_out_dss__SetEnable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetEnable(struct soap *soap, const char *tag, int id, const struct dss__SetEnable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetEnable), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetEnable * SOAP_FMAC4 soap_get_dss__SetEnable(struct soap *soap, struct dss__SetEnable *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetEnable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetEnable * SOAP_FMAC4 soap_in_dss__SetEnable(struct soap *soap, const char *tag, struct dss__SetEnable *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetEnable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetEnable, sizeof(struct dss__SetEnable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetEnable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetEnable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetEnable, 0, sizeof(struct dss__SetEnable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetEnable * SOAP_FMAC6 soap_new_dss__SetEnable(struct soap *soap, int n)
{	return soap_instantiate_dss__SetEnable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetEnable(struct soap *soap, struct dss__SetEnable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetEnable * SOAP_FMAC4 soap_instantiate_dss__SetEnable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetEnable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetEnable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetEnable;
		if (size)
			*size = sizeof(struct dss__SetEnable);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetEnable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetEnable);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetEnable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetEnable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetEnable %p -> %p\n", q, p));
	*(struct dss__SetEnable*)p = *(struct dss__SetEnable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetEnableResponse(struct soap *soap, struct dss__SetEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetEnableResponse(struct soap *soap, const struct dss__SetEnableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetEnableResponse(struct soap *soap, const struct dss__SetEnableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetEnableResponse);
	if (soap_out_dss__SetEnableResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetEnableResponse(struct soap *soap, const char *tag, int id, const struct dss__SetEnableResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetEnableResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetEnableResponse * SOAP_FMAC4 soap_get_dss__SetEnableResponse(struct soap *soap, struct dss__SetEnableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetEnableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetEnableResponse * SOAP_FMAC4 soap_in_dss__SetEnableResponse(struct soap *soap, const char *tag, struct dss__SetEnableResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetEnableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetEnableResponse, sizeof(struct dss__SetEnableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetEnableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetEnableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetEnableResponse, 0, sizeof(struct dss__SetEnableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetEnableResponse * SOAP_FMAC6 soap_new_dss__SetEnableResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetEnableResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetEnableResponse(struct soap *soap, struct dss__SetEnableResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetEnableResponse * SOAP_FMAC4 soap_instantiate_dss__SetEnableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetEnableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetEnableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetEnableResponse;
		if (size)
			*size = sizeof(struct dss__SetEnableResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetEnableResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetEnableResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetEnableResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetEnableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetEnableResponse %p -> %p\n", q, p));
	*(struct dss__SetEnableResponse*)p = *(struct dss__SetEnableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetDecreaseValue(struct soap *soap, struct dss__SetDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetDecreaseValue(struct soap *soap, const struct dss__SetDecreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetDecreaseValue(struct soap *soap, const struct dss__SetDecreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetDecreaseValue);
	if (soap_out_dss__SetDecreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetDecreaseValue(struct soap *soap, const char *tag, int id, const struct dss__SetDecreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetDecreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetDecreaseValue * SOAP_FMAC4 soap_get_dss__SetDecreaseValue(struct soap *soap, struct dss__SetDecreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetDecreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetDecreaseValue * SOAP_FMAC4 soap_in_dss__SetDecreaseValue(struct soap *soap, const char *tag, struct dss__SetDecreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetDecreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetDecreaseValue, sizeof(struct dss__SetDecreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetDecreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetDecreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetDecreaseValue, 0, sizeof(struct dss__SetDecreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetDecreaseValue * SOAP_FMAC6 soap_new_dss__SetDecreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__SetDecreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetDecreaseValue(struct soap *soap, struct dss__SetDecreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetDecreaseValue * SOAP_FMAC4 soap_instantiate_dss__SetDecreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetDecreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetDecreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetDecreaseValue;
		if (size)
			*size = sizeof(struct dss__SetDecreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetDecreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetDecreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetDecreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetDecreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetDecreaseValue %p -> %p\n", q, p));
	*(struct dss__SetDecreaseValue*)p = *(struct dss__SetDecreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetDecreaseValueResponse(struct soap *soap, struct dss__SetDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetDecreaseValueResponse(struct soap *soap, const struct dss__SetDecreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetDecreaseValueResponse(struct soap *soap, const struct dss__SetDecreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetDecreaseValueResponse);
	if (soap_out_dss__SetDecreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetDecreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__SetDecreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetDecreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetDecreaseValueResponse * SOAP_FMAC4 soap_get_dss__SetDecreaseValueResponse(struct soap *soap, struct dss__SetDecreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetDecreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetDecreaseValueResponse * SOAP_FMAC4 soap_in_dss__SetDecreaseValueResponse(struct soap *soap, const char *tag, struct dss__SetDecreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetDecreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetDecreaseValueResponse, sizeof(struct dss__SetDecreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetDecreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetDecreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetDecreaseValueResponse, 0, sizeof(struct dss__SetDecreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetDecreaseValueResponse * SOAP_FMAC6 soap_new_dss__SetDecreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetDecreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetDecreaseValueResponse(struct soap *soap, struct dss__SetDecreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetDecreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__SetDecreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetDecreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetDecreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetDecreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__SetDecreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetDecreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetDecreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetDecreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetDecreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetDecreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__SetDecreaseValueResponse*)p = *(struct dss__SetDecreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetIncreaseValue(struct soap *soap, struct dss__SetIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_paramID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetIncreaseValue(struct soap *soap, const struct dss__SetIncreaseValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetIncreaseValue(struct soap *soap, const struct dss__SetIncreaseValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetIncreaseValue);
	if (soap_out_dss__SetIncreaseValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetIncreaseValue(struct soap *soap, const char *tag, int id, const struct dss__SetIncreaseValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetIncreaseValue), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "paramID", -1, &a->_paramID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetIncreaseValue * SOAP_FMAC4 soap_get_dss__SetIncreaseValue(struct soap *soap, struct dss__SetIncreaseValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetIncreaseValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetIncreaseValue * SOAP_FMAC4 soap_in_dss__SetIncreaseValue(struct soap *soap, const char *tag, struct dss__SetIncreaseValue *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__paramID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetIncreaseValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetIncreaseValue, sizeof(struct dss__SetIncreaseValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetIncreaseValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__paramID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_paramID, "xsd:int"))
				{	soap_flag__paramID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetIncreaseValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetIncreaseValue, 0, sizeof(struct dss__SetIncreaseValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__paramID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetIncreaseValue * SOAP_FMAC6 soap_new_dss__SetIncreaseValue(struct soap *soap, int n)
{	return soap_instantiate_dss__SetIncreaseValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetIncreaseValue(struct soap *soap, struct dss__SetIncreaseValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetIncreaseValue * SOAP_FMAC4 soap_instantiate_dss__SetIncreaseValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetIncreaseValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetIncreaseValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetIncreaseValue;
		if (size)
			*size = sizeof(struct dss__SetIncreaseValue);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetIncreaseValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetIncreaseValue);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetIncreaseValue*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetIncreaseValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetIncreaseValue %p -> %p\n", q, p));
	*(struct dss__SetIncreaseValue*)p = *(struct dss__SetIncreaseValue*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetIncreaseValueResponse(struct soap *soap, struct dss__SetIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetIncreaseValueResponse(struct soap *soap, const struct dss__SetIncreaseValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetIncreaseValueResponse(struct soap *soap, const struct dss__SetIncreaseValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetIncreaseValueResponse);
	if (soap_out_dss__SetIncreaseValueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetIncreaseValueResponse(struct soap *soap, const char *tag, int id, const struct dss__SetIncreaseValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetIncreaseValueResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetIncreaseValueResponse * SOAP_FMAC4 soap_get_dss__SetIncreaseValueResponse(struct soap *soap, struct dss__SetIncreaseValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetIncreaseValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetIncreaseValueResponse * SOAP_FMAC4 soap_in_dss__SetIncreaseValueResponse(struct soap *soap, const char *tag, struct dss__SetIncreaseValueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetIncreaseValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetIncreaseValueResponse, sizeof(struct dss__SetIncreaseValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetIncreaseValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetIncreaseValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetIncreaseValueResponse, 0, sizeof(struct dss__SetIncreaseValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetIncreaseValueResponse * SOAP_FMAC6 soap_new_dss__SetIncreaseValueResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetIncreaseValueResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetIncreaseValueResponse(struct soap *soap, struct dss__SetIncreaseValueResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetIncreaseValueResponse * SOAP_FMAC4 soap_instantiate_dss__SetIncreaseValueResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetIncreaseValueResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetIncreaseValueResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetIncreaseValueResponse;
		if (size)
			*size = sizeof(struct dss__SetIncreaseValueResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetIncreaseValueResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetIncreaseValueResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetIncreaseValueResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetIncreaseValueResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetIncreaseValueResponse %p -> %p\n", q, p));
	*(struct dss__SetIncreaseValueResponse*)p = *(struct dss__SetIncreaseValueResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOff(struct soap *soap, struct dss__SetTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOff(struct soap *soap, const struct dss__SetTurnOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOff(struct soap *soap, const struct dss__SetTurnOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOff);
	if (soap_out_dss__SetTurnOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOff(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOff * SOAP_FMAC4 soap_get_dss__SetTurnOff(struct soap *soap, struct dss__SetTurnOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetTurnOff * SOAP_FMAC4 soap_in_dss__SetTurnOff(struct soap *soap, const char *tag, struct dss__SetTurnOff *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOff, sizeof(struct dss__SetTurnOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOff, 0, sizeof(struct dss__SetTurnOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetTurnOff * SOAP_FMAC6 soap_new_dss__SetTurnOff(struct soap *soap, int n)
{	return soap_instantiate_dss__SetTurnOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetTurnOff(struct soap *soap, struct dss__SetTurnOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetTurnOff * SOAP_FMAC4 soap_instantiate_dss__SetTurnOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetTurnOff;
		if (size)
			*size = sizeof(struct dss__SetTurnOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetTurnOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOff %p -> %p\n", q, p));
	*(struct dss__SetTurnOff*)p = *(struct dss__SetTurnOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOffResponse(struct soap *soap, struct dss__SetTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOffResponse(struct soap *soap, const struct dss__SetTurnOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOffResponse(struct soap *soap, const struct dss__SetTurnOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOffResponse);
	if (soap_out_dss__SetTurnOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOffResponse(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOffResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOffResponse * SOAP_FMAC4 soap_get_dss__SetTurnOffResponse(struct soap *soap, struct dss__SetTurnOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetTurnOffResponse * SOAP_FMAC4 soap_in_dss__SetTurnOffResponse(struct soap *soap, const char *tag, struct dss__SetTurnOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOffResponse, sizeof(struct dss__SetTurnOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOffResponse, 0, sizeof(struct dss__SetTurnOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetTurnOffResponse * SOAP_FMAC6 soap_new_dss__SetTurnOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetTurnOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetTurnOffResponse(struct soap *soap, struct dss__SetTurnOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetTurnOffResponse * SOAP_FMAC4 soap_instantiate_dss__SetTurnOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetTurnOffResponse;
		if (size)
			*size = sizeof(struct dss__SetTurnOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetTurnOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOffResponse %p -> %p\n", q, p));
	*(struct dss__SetTurnOffResponse*)p = *(struct dss__SetTurnOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOn(struct soap *soap, struct dss__SetTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOn(struct soap *soap, const struct dss__SetTurnOn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOn(struct soap *soap, const struct dss__SetTurnOn *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOn);
	if (soap_out_dss__SetTurnOn(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOn(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOn), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOn * SOAP_FMAC4 soap_get_dss__SetTurnOn(struct soap *soap, struct dss__SetTurnOn *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetTurnOn * SOAP_FMAC4 soap_in_dss__SetTurnOn(struct soap *soap, const char *tag, struct dss__SetTurnOn *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOn, sizeof(struct dss__SetTurnOn), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOn, 0, sizeof(struct dss__SetTurnOn), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetTurnOn * SOAP_FMAC6 soap_new_dss__SetTurnOn(struct soap *soap, int n)
{	return soap_instantiate_dss__SetTurnOn(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetTurnOn(struct soap *soap, struct dss__SetTurnOn *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetTurnOn * SOAP_FMAC4 soap_instantiate_dss__SetTurnOn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetTurnOn;
		if (size)
			*size = sizeof(struct dss__SetTurnOn);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetTurnOn[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOn);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOn*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOn %p -> %p\n", q, p));
	*(struct dss__SetTurnOn*)p = *(struct dss__SetTurnOn*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetTurnOnResponse(struct soap *soap, struct dss__SetTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetTurnOnResponse(struct soap *soap, const struct dss__SetTurnOnResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetTurnOnResponse(struct soap *soap, const struct dss__SetTurnOnResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetTurnOnResponse);
	if (soap_out_dss__SetTurnOnResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetTurnOnResponse(struct soap *soap, const char *tag, int id, const struct dss__SetTurnOnResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetTurnOnResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetTurnOnResponse * SOAP_FMAC4 soap_get_dss__SetTurnOnResponse(struct soap *soap, struct dss__SetTurnOnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetTurnOnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetTurnOnResponse * SOAP_FMAC4 soap_in_dss__SetTurnOnResponse(struct soap *soap, const char *tag, struct dss__SetTurnOnResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetTurnOnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetTurnOnResponse, sizeof(struct dss__SetTurnOnResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetTurnOnResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "result", &a->result, "xsd:boolean"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetTurnOnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetTurnOnResponse, 0, sizeof(struct dss__SetTurnOnResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetTurnOnResponse * SOAP_FMAC6 soap_new_dss__SetTurnOnResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetTurnOnResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetTurnOnResponse(struct soap *soap, struct dss__SetTurnOnResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetTurnOnResponse * SOAP_FMAC4 soap_instantiate_dss__SetTurnOnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetTurnOnResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetTurnOnResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetTurnOnResponse;
		if (size)
			*size = sizeof(struct dss__SetTurnOnResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetTurnOnResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetTurnOnResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetTurnOnResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetTurnOnResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetTurnOnResponse %p -> %p\n", q, p));
	*(struct dss__SetTurnOnResponse*)p = *(struct dss__SetTurnOnResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneIDs(struct soap *soap, struct dss__ApartmentGetZoneIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneIDs(struct soap *soap, const struct dss__ApartmentGetZoneIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneIDs(struct soap *soap, const struct dss__ApartmentGetZoneIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneIDs);
	if (soap_out_dss__ApartmentGetZoneIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneIDs(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDs * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneIDs(struct soap *soap, struct dss__ApartmentGetZoneIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDs * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneIDs(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneIDs, sizeof(struct dss__ApartmentGetZoneIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneIDs, 0, sizeof(struct dss__ApartmentGetZoneIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetZoneIDs * SOAP_FMAC6 soap_new_dss__ApartmentGetZoneIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetZoneIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetZoneIDs(struct soap *soap, struct dss__ApartmentGetZoneIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDs * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetZoneIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneIDs;
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneIDs %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneIDs*)p = *(struct dss__ApartmentGetZoneIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneIDsResponse(struct soap *soap, struct dss__ApartmentGetZoneIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfint(soap, &a->zoneIDs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const struct dss__ApartmentGetZoneIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &a->zoneIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const struct dss__ApartmentGetZoneIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse);
	if (soap_out_dss__ApartmentGetZoneIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "zoneIDs", -1, &a->zoneIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDsResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneIDsResponse(struct soap *soap, struct dss__ApartmentGetZoneIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDsResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneIDsResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneIDsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse, sizeof(struct dss__ApartmentGetZoneIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "zoneIDs", &a->zoneIDs, "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse, 0, sizeof(struct dss__ApartmentGetZoneIDsResponse), 0, soap_copy_dss__ApartmentGetZoneIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetZoneIDsResponse * SOAP_FMAC6 soap_new_dss__ApartmentGetZoneIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetZoneIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetZoneIDsResponse(struct soap *soap, struct dss__ApartmentGetZoneIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneIDsResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetZoneIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneIDsResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneIDsResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneIDsResponse*)p = *(struct dss__ApartmentGetZoneIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneByName(struct soap *soap, struct dss__ApartmentGetZoneByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_zoneName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneByName(struct soap *soap, const struct dss__ApartmentGetZoneByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_zoneName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneByName(struct soap *soap, const struct dss__ApartmentGetZoneByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneByName);
	if (soap_out_dss__ApartmentGetZoneByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneByName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "zoneName", -1, &a->_zoneName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByName * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneByName(struct soap *soap, struct dss__ApartmentGetZoneByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByName * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneByName(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__zoneName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneByName, sizeof(struct dss__ApartmentGetZoneByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__zoneName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_zoneName, "xsd:string"))
				{	soap_flag__zoneName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneByName, 0, sizeof(struct dss__ApartmentGetZoneByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetZoneByName * SOAP_FMAC6 soap_new_dss__ApartmentGetZoneByName(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetZoneByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetZoneByName(struct soap *soap, struct dss__ApartmentGetZoneByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByName * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetZoneByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneByName;
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneByName %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneByName*)p = *(struct dss__ApartmentGetZoneByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetZoneByNameResponse(struct soap *soap, struct dss__ApartmentGetZoneByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->zoneID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const struct dss__ApartmentGetZoneByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const struct dss__ApartmentGetZoneByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse);
	if (soap_out_dss__ApartmentGetZoneByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetZoneByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "zoneID", -1, &a->zoneID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetZoneByNameResponse(struct soap *soap, struct dss__ApartmentGetZoneByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetZoneByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetZoneByNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetZoneByNameResponse *a, const char *type)
{
	short soap_flag_zoneID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetZoneByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse, sizeof(struct dss__ApartmentGetZoneByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetZoneByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zoneID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "zoneID", &a->zoneID, "xsd:int"))
				{	soap_flag_zoneID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetZoneByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse, 0, sizeof(struct dss__ApartmentGetZoneByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zoneID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetZoneByNameResponse * SOAP_FMAC6 soap_new_dss__ApartmentGetZoneByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetZoneByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetZoneByNameResponse(struct soap *soap, struct dss__ApartmentGetZoneByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetZoneByNameResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetZoneByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetZoneByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetZoneByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneByNameResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentGetZoneByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetZoneByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetZoneByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetZoneByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetZoneByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetZoneByNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetZoneByNameResponse*)p = *(struct dss__ApartmentGetZoneByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetGroupByName(struct soap *soap, struct dss__ApartmentGetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetGroupByName(struct soap *soap, const struct dss__ApartmentGetGroupByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetGroupByName(struct soap *soap, const struct dss__ApartmentGetGroupByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetGroupByName);
	if (soap_out_dss__ApartmentGetGroupByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetGroupByName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetGroupByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetGroupByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByName * SOAP_FMAC4 soap_get_dss__ApartmentGetGroupByName(struct soap *soap, struct dss__ApartmentGetGroupByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetGroupByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByName * SOAP_FMAC4 soap_in_dss__ApartmentGetGroupByName(struct soap *soap, const char *tag, struct dss__ApartmentGetGroupByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetGroupByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetGroupByName, sizeof(struct dss__ApartmentGetGroupByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetGroupByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetGroupByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetGroupByName, 0, sizeof(struct dss__ApartmentGetGroupByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetGroupByName * SOAP_FMAC6 soap_new_dss__ApartmentGetGroupByName(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetGroupByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetGroupByName(struct soap *soap, struct dss__ApartmentGetGroupByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByName * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetGroupByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetGroupByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetGroupByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetGroupByName;
		if (size)
			*size = sizeof(struct dss__ApartmentGetGroupByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetGroupByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetGroupByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetGroupByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetGroupByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetGroupByName %p -> %p\n", q, p));
	*(struct dss__ApartmentGetGroupByName*)p = *(struct dss__ApartmentGetGroupByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetGroupByNameResponse(struct soap *soap, struct dss__ApartmentGetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const struct dss__ApartmentGetGroupByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const struct dss__ApartmentGetGroupByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse);
	if (soap_out_dss__ApartmentGetGroupByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetGroupByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse), type))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetGroupByNameResponse(struct soap *soap, struct dss__ApartmentGetGroupByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetGroupByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetGroupByNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetGroupByNameResponse *a, const char *type)
{
	short soap_flag_groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetGroupByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse, sizeof(struct dss__ApartmentGetGroupByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetGroupByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupID", &a->groupID, "xsd:int"))
				{	soap_flag_groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetGroupByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse, 0, sizeof(struct dss__ApartmentGetGroupByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetGroupByNameResponse * SOAP_FMAC6 soap_new_dss__ApartmentGetGroupByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetGroupByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetGroupByNameResponse(struct soap *soap, struct dss__ApartmentGetGroupByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetGroupByNameResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetGroupByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetGroupByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetGroupByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetGroupByNameResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentGetGroupByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetGroupByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetGroupByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetGroupByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetGroupByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetGroupByNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetGroupByNameResponse*)p = *(struct dss__ApartmentGetGroupByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetGetContainedDevices(struct soap *soap, struct dss__SetGetContainedDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetGetContainedDevices(struct soap *soap, const struct dss__SetGetContainedDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetGetContainedDevices(struct soap *soap, const struct dss__SetGetContainedDevices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetGetContainedDevices);
	if (soap_out_dss__SetGetContainedDevices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetGetContainedDevices(struct soap *soap, const char *tag, int id, const struct dss__SetGetContainedDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetGetContainedDevices), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetGetContainedDevices * SOAP_FMAC4 soap_get_dss__SetGetContainedDevices(struct soap *soap, struct dss__SetGetContainedDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetGetContainedDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetGetContainedDevices * SOAP_FMAC4 soap_in_dss__SetGetContainedDevices(struct soap *soap, const char *tag, struct dss__SetGetContainedDevices *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetGetContainedDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetGetContainedDevices, sizeof(struct dss__SetGetContainedDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetGetContainedDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetGetContainedDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetGetContainedDevices, 0, sizeof(struct dss__SetGetContainedDevices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetGetContainedDevices * SOAP_FMAC6 soap_new_dss__SetGetContainedDevices(struct soap *soap, int n)
{	return soap_instantiate_dss__SetGetContainedDevices(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetGetContainedDevices(struct soap *soap, struct dss__SetGetContainedDevices *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetGetContainedDevices * SOAP_FMAC4 soap_instantiate_dss__SetGetContainedDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetGetContainedDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetGetContainedDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetGetContainedDevices;
		if (size)
			*size = sizeof(struct dss__SetGetContainedDevices);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetGetContainedDevices[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetGetContainedDevices);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetGetContainedDevices*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetGetContainedDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetGetContainedDevices %p -> %p\n", q, p));
	*(struct dss__SetGetContainedDevices*)p = *(struct dss__SetGetContainedDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetGetContainedDevicesResponse(struct soap *soap, struct dss__SetGetContainedDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfstd__string(soap, &a->deviceIDs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetGetContainedDevicesResponse(struct soap *soap, const struct dss__SetGetContainedDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->deviceIDs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetGetContainedDevicesResponse(struct soap *soap, const struct dss__SetGetContainedDevicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetGetContainedDevicesResponse);
	if (soap_out_dss__SetGetContainedDevicesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetGetContainedDevicesResponse(struct soap *soap, const char *tag, int id, const struct dss__SetGetContainedDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetGetContainedDevicesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "deviceIDs", -1, &a->deviceIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetGetContainedDevicesResponse * SOAP_FMAC4 soap_get_dss__SetGetContainedDevicesResponse(struct soap *soap, struct dss__SetGetContainedDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetGetContainedDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetGetContainedDevicesResponse * SOAP_FMAC4 soap_in_dss__SetGetContainedDevicesResponse(struct soap *soap, const char *tag, struct dss__SetGetContainedDevicesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetGetContainedDevicesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetGetContainedDevicesResponse, sizeof(struct dss__SetGetContainedDevicesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetGetContainedDevicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "deviceIDs", &a->deviceIDs, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetGetContainedDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetGetContainedDevicesResponse, 0, sizeof(struct dss__SetGetContainedDevicesResponse), 0, soap_copy_dss__SetGetContainedDevicesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetGetContainedDevicesResponse * SOAP_FMAC6 soap_new_dss__SetGetContainedDevicesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetGetContainedDevicesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetGetContainedDevicesResponse(struct soap *soap, struct dss__SetGetContainedDevicesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetGetContainedDevicesResponse * SOAP_FMAC4 soap_instantiate_dss__SetGetContainedDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetGetContainedDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetGetContainedDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetGetContainedDevicesResponse;
		if (size)
			*size = sizeof(struct dss__SetGetContainedDevicesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetGetContainedDevicesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetGetContainedDevicesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetGetContainedDevicesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetGetContainedDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetGetContainedDevicesResponse %p -> %p\n", q, p));
	*(struct dss__SetGetContainedDevicesResponse*)p = *(struct dss__SetGetContainedDevicesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetByGroup(struct soap *soap, struct dss__SetByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_int(soap, &a->_groupID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetByGroup(struct soap *soap, const struct dss__SetByGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetByGroup(struct soap *soap, const struct dss__SetByGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetByGroup);
	if (soap_out_dss__SetByGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetByGroup(struct soap *soap, const char *tag, int id, const struct dss__SetByGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetByGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_int(soap, "groupID", -1, &a->_groupID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetByGroup * SOAP_FMAC4 soap_get_dss__SetByGroup(struct soap *soap, struct dss__SetByGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetByGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetByGroup * SOAP_FMAC4 soap_in_dss__SetByGroup(struct soap *soap, const char *tag, struct dss__SetByGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__groupID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetByGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetByGroup, sizeof(struct dss__SetByGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetByGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__groupID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_groupID, "xsd:int"))
				{	soap_flag__groupID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetByGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetByGroup, 0, sizeof(struct dss__SetByGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0 || soap_flag__groupID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetByGroup * SOAP_FMAC6 soap_new_dss__SetByGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__SetByGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetByGroup(struct soap *soap, struct dss__SetByGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetByGroup * SOAP_FMAC4 soap_instantiate_dss__SetByGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetByGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetByGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetByGroup;
		if (size)
			*size = sizeof(struct dss__SetByGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetByGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetByGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetByGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetByGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetByGroup %p -> %p\n", q, p));
	*(struct dss__SetByGroup*)p = *(struct dss__SetByGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetByGroupResponse(struct soap *soap, struct dss__SetByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetByGroupResponse(struct soap *soap, const struct dss__SetByGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetByGroupResponse(struct soap *soap, const struct dss__SetByGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetByGroupResponse);
	if (soap_out_dss__SetByGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetByGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__SetByGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetByGroupResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetByGroupResponse * SOAP_FMAC4 soap_get_dss__SetByGroupResponse(struct soap *soap, struct dss__SetByGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetByGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetByGroupResponse * SOAP_FMAC4 soap_in_dss__SetByGroupResponse(struct soap *soap, const char *tag, struct dss__SetByGroupResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetByGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetByGroupResponse, sizeof(struct dss__SetByGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetByGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetByGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetByGroupResponse, 0, sizeof(struct dss__SetByGroupResponse), 0, soap_copy_dss__SetByGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetByGroupResponse * SOAP_FMAC6 soap_new_dss__SetByGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetByGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetByGroupResponse(struct soap *soap, struct dss__SetByGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetByGroupResponse * SOAP_FMAC4 soap_instantiate_dss__SetByGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetByGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetByGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetByGroupResponse;
		if (size)
			*size = sizeof(struct dss__SetByGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetByGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetByGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetByGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetByGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetByGroupResponse %p -> %p\n", q, p));
	*(struct dss__SetByGroupResponse*)p = *(struct dss__SetByGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemove(struct soap *soap, struct dss__SetRemove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_setSpecToRemove);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemove(struct soap *soap, const struct dss__SetRemove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_setSpecToRemove);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemove(struct soap *soap, const struct dss__SetRemove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemove);
	if (soap_out_dss__SetRemove(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemove(struct soap *soap, const char *tag, int id, const struct dss__SetRemove *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemove), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpecToRemove", -1, &a->_setSpecToRemove, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemove * SOAP_FMAC4 soap_get_dss__SetRemove(struct soap *soap, struct dss__SetRemove *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetRemove * SOAP_FMAC4 soap_in_dss__SetRemove(struct soap *soap, const char *tag, struct dss__SetRemove *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__setSpecToRemove = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemove, sizeof(struct dss__SetRemove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetRemove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__setSpecToRemove && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpecToRemove, "xsd:string"))
				{	soap_flag__setSpecToRemove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemove, 0, sizeof(struct dss__SetRemove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetRemove * SOAP_FMAC6 soap_new_dss__SetRemove(struct soap *soap, int n)
{	return soap_instantiate_dss__SetRemove(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetRemove(struct soap *soap, struct dss__SetRemove *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetRemove * SOAP_FMAC4 soap_instantiate_dss__SetRemove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetRemove;
		if (size)
			*size = sizeof(struct dss__SetRemove);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetRemove[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemove);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemove*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemove %p -> %p\n", q, p));
	*(struct dss__SetRemove*)p = *(struct dss__SetRemove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemoveResponse(struct soap *soap, struct dss__SetRemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemoveResponse(struct soap *soap, const struct dss__SetRemoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemoveResponse(struct soap *soap, const struct dss__SetRemoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemoveResponse);
	if (soap_out_dss__SetRemoveResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemoveResponse(struct soap *soap, const char *tag, int id, const struct dss__SetRemoveResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemoveResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemoveResponse * SOAP_FMAC4 soap_get_dss__SetRemoveResponse(struct soap *soap, struct dss__SetRemoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetRemoveResponse * SOAP_FMAC4 soap_in_dss__SetRemoveResponse(struct soap *soap, const char *tag, struct dss__SetRemoveResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemoveResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemoveResponse, sizeof(struct dss__SetRemoveResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetRemoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemoveResponse, 0, sizeof(struct dss__SetRemoveResponse), 0, soap_copy_dss__SetRemoveResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetRemoveResponse * SOAP_FMAC6 soap_new_dss__SetRemoveResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetRemoveResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetRemoveResponse(struct soap *soap, struct dss__SetRemoveResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetRemoveResponse * SOAP_FMAC4 soap_instantiate_dss__SetRemoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemoveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemoveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetRemoveResponse;
		if (size)
			*size = sizeof(struct dss__SetRemoveResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetRemoveResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemoveResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemoveResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemoveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemoveResponse %p -> %p\n", q, p));
	*(struct dss__SetRemoveResponse*)p = *(struct dss__SetRemoveResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCombine(struct soap *soap, struct dss__SetCombine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec1);
	soap_default_string(soap, &a->_setSpec2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCombine(struct soap *soap, const struct dss__SetCombine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec1);
	soap_serialize_string(soap, &a->_setSpec2);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCombine(struct soap *soap, const struct dss__SetCombine *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCombine);
	if (soap_out_dss__SetCombine(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCombine(struct soap *soap, const char *tag, int id, const struct dss__SetCombine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCombine), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec1", -1, &a->_setSpec1, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec2", -1, &a->_setSpec2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCombine * SOAP_FMAC4 soap_get_dss__SetCombine(struct soap *soap, struct dss__SetCombine *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCombine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetCombine * SOAP_FMAC4 soap_in_dss__SetCombine(struct soap *soap, const char *tag, struct dss__SetCombine *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec1 = 1, soap_flag__setSpec2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCombine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCombine, sizeof(struct dss__SetCombine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetCombine(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec1, "xsd:string"))
				{	soap_flag__setSpec1--;
					continue;
				}
			if (soap_flag__setSpec2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec2, "xsd:string"))
				{	soap_flag__setSpec2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCombine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCombine, 0, sizeof(struct dss__SetCombine), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetCombine * SOAP_FMAC6 soap_new_dss__SetCombine(struct soap *soap, int n)
{	return soap_instantiate_dss__SetCombine(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetCombine(struct soap *soap, struct dss__SetCombine *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetCombine * SOAP_FMAC4 soap_instantiate_dss__SetCombine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCombine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCombine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetCombine;
		if (size)
			*size = sizeof(struct dss__SetCombine);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetCombine[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCombine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCombine*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCombine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCombine %p -> %p\n", q, p));
	*(struct dss__SetCombine*)p = *(struct dss__SetCombine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetCombineResponse(struct soap *soap, struct dss__SetCombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetCombineResponse(struct soap *soap, const struct dss__SetCombineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetCombineResponse(struct soap *soap, const struct dss__SetCombineResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetCombineResponse);
	if (soap_out_dss__SetCombineResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetCombineResponse(struct soap *soap, const char *tag, int id, const struct dss__SetCombineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetCombineResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetCombineResponse * SOAP_FMAC4 soap_get_dss__SetCombineResponse(struct soap *soap, struct dss__SetCombineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetCombineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetCombineResponse * SOAP_FMAC4 soap_in_dss__SetCombineResponse(struct soap *soap, const char *tag, struct dss__SetCombineResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetCombineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetCombineResponse, sizeof(struct dss__SetCombineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetCombineResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetCombineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetCombineResponse, 0, sizeof(struct dss__SetCombineResponse), 0, soap_copy_dss__SetCombineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetCombineResponse * SOAP_FMAC6 soap_new_dss__SetCombineResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetCombineResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetCombineResponse(struct soap *soap, struct dss__SetCombineResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetCombineResponse * SOAP_FMAC4 soap_instantiate_dss__SetCombineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetCombineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetCombineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetCombineResponse;
		if (size)
			*size = sizeof(struct dss__SetCombineResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetCombineResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetCombineResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetCombineResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetCombineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetCombineResponse %p -> %p\n", q, p));
	*(struct dss__SetCombineResponse*)p = *(struct dss__SetCombineResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemoveDevice(struct soap *soap, struct dss__SetRemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemoveDevice(struct soap *soap, const struct dss__SetRemoveDevice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemoveDevice(struct soap *soap, const struct dss__SetRemoveDevice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemoveDevice);
	if (soap_out_dss__SetRemoveDevice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemoveDevice(struct soap *soap, const char *tag, int id, const struct dss__SetRemoveDevice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemoveDevice), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemoveDevice * SOAP_FMAC4 soap_get_dss__SetRemoveDevice(struct soap *soap, struct dss__SetRemoveDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemoveDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetRemoveDevice * SOAP_FMAC4 soap_in_dss__SetRemoveDevice(struct soap *soap, const char *tag, struct dss__SetRemoveDevice *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemoveDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemoveDevice, sizeof(struct dss__SetRemoveDevice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetRemoveDevice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemoveDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemoveDevice, 0, sizeof(struct dss__SetRemoveDevice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetRemoveDevice * SOAP_FMAC6 soap_new_dss__SetRemoveDevice(struct soap *soap, int n)
{	return soap_instantiate_dss__SetRemoveDevice(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetRemoveDevice(struct soap *soap, struct dss__SetRemoveDevice *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetRemoveDevice * SOAP_FMAC4 soap_instantiate_dss__SetRemoveDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemoveDevice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemoveDevice, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetRemoveDevice;
		if (size)
			*size = sizeof(struct dss__SetRemoveDevice);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetRemoveDevice[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemoveDevice);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemoveDevice*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemoveDevice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemoveDevice %p -> %p\n", q, p));
	*(struct dss__SetRemoveDevice*)p = *(struct dss__SetRemoveDevice*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetRemoveDeviceResponse(struct soap *soap, struct dss__SetRemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetRemoveDeviceResponse(struct soap *soap, const struct dss__SetRemoveDeviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetRemoveDeviceResponse(struct soap *soap, const struct dss__SetRemoveDeviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetRemoveDeviceResponse);
	if (soap_out_dss__SetRemoveDeviceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetRemoveDeviceResponse(struct soap *soap, const char *tag, int id, const struct dss__SetRemoveDeviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetRemoveDeviceResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetRemoveDeviceResponse * SOAP_FMAC4 soap_get_dss__SetRemoveDeviceResponse(struct soap *soap, struct dss__SetRemoveDeviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetRemoveDeviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetRemoveDeviceResponse * SOAP_FMAC4 soap_in_dss__SetRemoveDeviceResponse(struct soap *soap, const char *tag, struct dss__SetRemoveDeviceResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetRemoveDeviceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetRemoveDeviceResponse, sizeof(struct dss__SetRemoveDeviceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetRemoveDeviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetRemoveDeviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetRemoveDeviceResponse, 0, sizeof(struct dss__SetRemoveDeviceResponse), 0, soap_copy_dss__SetRemoveDeviceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetRemoveDeviceResponse * SOAP_FMAC6 soap_new_dss__SetRemoveDeviceResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetRemoveDeviceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetRemoveDeviceResponse(struct soap *soap, struct dss__SetRemoveDeviceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetRemoveDeviceResponse * SOAP_FMAC4 soap_instantiate_dss__SetRemoveDeviceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetRemoveDeviceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetRemoveDeviceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetRemoveDeviceResponse;
		if (size)
			*size = sizeof(struct dss__SetRemoveDeviceResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetRemoveDeviceResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetRemoveDeviceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetRemoveDeviceResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetRemoveDeviceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetRemoveDeviceResponse %p -> %p\n", q, p));
	*(struct dss__SetRemoveDeviceResponse*)p = *(struct dss__SetRemoveDeviceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByID(struct soap *soap, struct dss__SetAddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByID(struct soap *soap, const struct dss__SetAddDeviceByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByID(struct soap *soap, const struct dss__SetAddDeviceByID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByID);
	if (soap_out_dss__SetAddDeviceByID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByID(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByID), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceID", -1, &a->_deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByID * SOAP_FMAC4 soap_get_dss__SetAddDeviceByID(struct soap *soap, struct dss__SetAddDeviceByID *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetAddDeviceByID * SOAP_FMAC4 soap_in_dss__SetAddDeviceByID(struct soap *soap, const char *tag, struct dss__SetAddDeviceByID *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByID, sizeof(struct dss__SetAddDeviceByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceID, "xsd:string"))
				{	soap_flag__deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByID, 0, sizeof(struct dss__SetAddDeviceByID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetAddDeviceByID * SOAP_FMAC6 soap_new_dss__SetAddDeviceByID(struct soap *soap, int n)
{	return soap_instantiate_dss__SetAddDeviceByID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetAddDeviceByID(struct soap *soap, struct dss__SetAddDeviceByID *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetAddDeviceByID * SOAP_FMAC4 soap_instantiate_dss__SetAddDeviceByID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByID;
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByID);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByID[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByID);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByID*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByID %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByID*)p = *(struct dss__SetAddDeviceByID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByIDResponse(struct soap *soap, struct dss__SetAddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByIDResponse(struct soap *soap, const struct dss__SetAddDeviceByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByIDResponse(struct soap *soap, const struct dss__SetAddDeviceByIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByIDResponse);
	if (soap_out_dss__SetAddDeviceByIDResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByIDResponse(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByIDResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByIDResponse * SOAP_FMAC4 soap_get_dss__SetAddDeviceByIDResponse(struct soap *soap, struct dss__SetAddDeviceByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetAddDeviceByIDResponse * SOAP_FMAC4 soap_in_dss__SetAddDeviceByIDResponse(struct soap *soap, const char *tag, struct dss__SetAddDeviceByIDResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByIDResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByIDResponse, sizeof(struct dss__SetAddDeviceByIDResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByIDResponse, 0, sizeof(struct dss__SetAddDeviceByIDResponse), 0, soap_copy_dss__SetAddDeviceByIDResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetAddDeviceByIDResponse * SOAP_FMAC6 soap_new_dss__SetAddDeviceByIDResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetAddDeviceByIDResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetAddDeviceByIDResponse(struct soap *soap, struct dss__SetAddDeviceByIDResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetAddDeviceByIDResponse * SOAP_FMAC4 soap_instantiate_dss__SetAddDeviceByIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByIDResponse;
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByIDResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByIDResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByIDResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByIDResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByIDResponse %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByIDResponse*)p = *(struct dss__SetAddDeviceByIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByName(struct soap *soap, struct dss__SetAddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_setSpec);
	soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByName(struct soap *soap, const struct dss__SetAddDeviceByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_setSpec);
	soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByName(struct soap *soap, const struct dss__SetAddDeviceByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByName);
	if (soap_out_dss__SetAddDeviceByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByName(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "setSpec", -1, &a->_setSpec, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->_name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByName * SOAP_FMAC4 soap_get_dss__SetAddDeviceByName(struct soap *soap, struct dss__SetAddDeviceByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetAddDeviceByName * SOAP_FMAC4 soap_in_dss__SetAddDeviceByName(struct soap *soap, const char *tag, struct dss__SetAddDeviceByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__setSpec = 1, soap_flag__name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByName, sizeof(struct dss__SetAddDeviceByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__setSpec && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_setSpec, "xsd:string"))
				{	soap_flag__setSpec--;
					continue;
				}
			if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
				{	soap_flag__name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByName, 0, sizeof(struct dss__SetAddDeviceByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetAddDeviceByName * SOAP_FMAC6 soap_new_dss__SetAddDeviceByName(struct soap *soap, int n)
{	return soap_instantiate_dss__SetAddDeviceByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetAddDeviceByName(struct soap *soap, struct dss__SetAddDeviceByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetAddDeviceByName * SOAP_FMAC4 soap_instantiate_dss__SetAddDeviceByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByName;
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByName %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByName*)p = *(struct dss__SetAddDeviceByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SetAddDeviceByNameResponse(struct soap *soap, struct dss__SetAddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SetAddDeviceByNameResponse(struct soap *soap, const struct dss__SetAddDeviceByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SetAddDeviceByNameResponse(struct soap *soap, const struct dss__SetAddDeviceByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SetAddDeviceByNameResponse);
	if (soap_out_dss__SetAddDeviceByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SetAddDeviceByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__SetAddDeviceByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SetAddDeviceByNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SetAddDeviceByNameResponse * SOAP_FMAC4 soap_get_dss__SetAddDeviceByNameResponse(struct soap *soap, struct dss__SetAddDeviceByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SetAddDeviceByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SetAddDeviceByNameResponse * SOAP_FMAC4 soap_in_dss__SetAddDeviceByNameResponse(struct soap *soap, const char *tag, struct dss__SetAddDeviceByNameResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SetAddDeviceByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SetAddDeviceByNameResponse, sizeof(struct dss__SetAddDeviceByNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__SetAddDeviceByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SetAddDeviceByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SetAddDeviceByNameResponse, 0, sizeof(struct dss__SetAddDeviceByNameResponse), 0, soap_copy_dss__SetAddDeviceByNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SetAddDeviceByNameResponse * SOAP_FMAC6 soap_new_dss__SetAddDeviceByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SetAddDeviceByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SetAddDeviceByNameResponse(struct soap *soap, struct dss__SetAddDeviceByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SetAddDeviceByNameResponse * SOAP_FMAC4 soap_instantiate_dss__SetAddDeviceByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SetAddDeviceByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SetAddDeviceByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByNameResponse;
		if (size)
			*size = sizeof(struct dss__SetAddDeviceByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SetAddDeviceByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SetAddDeviceByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SetAddDeviceByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SetAddDeviceByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SetAddDeviceByNameResponse %p -> %p\n", q, p));
	*(struct dss__SetAddDeviceByNameResponse*)p = *(struct dss__SetAddDeviceByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDeviceIDByName(struct soap *soap, struct dss__ApartmentGetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_deviceName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDeviceIDByName(struct soap *soap, const struct dss__ApartmentGetDeviceIDByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_deviceName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDeviceIDByName(struct soap *soap, const struct dss__ApartmentGetDeviceIDByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDeviceIDByName);
	if (soap_out_dss__ApartmentGetDeviceIDByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDeviceIDByName(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDeviceIDByName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByName), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "deviceName", -1, &a->_deviceName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByName * SOAP_FMAC4 soap_get_dss__ApartmentGetDeviceIDByName(struct soap *soap, struct dss__ApartmentGetDeviceIDByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDeviceIDByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByName * SOAP_FMAC4 soap_in_dss__ApartmentGetDeviceIDByName(struct soap *soap, const char *tag, struct dss__ApartmentGetDeviceIDByName *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__deviceName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDeviceIDByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByName, sizeof(struct dss__ApartmentGetDeviceIDByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDeviceIDByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__deviceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_deviceName, "xsd:string"))
				{	soap_flag__deviceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDeviceIDByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDeviceIDByName, 0, sizeof(struct dss__ApartmentGetDeviceIDByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetDeviceIDByName * SOAP_FMAC6 soap_new_dss__ApartmentGetDeviceIDByName(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetDeviceIDByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetDeviceIDByName(struct soap *soap, struct dss__ApartmentGetDeviceIDByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByName * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetDeviceIDByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDeviceIDByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDeviceIDByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetDeviceIDByName;
		if (size)
			*size = sizeof(struct dss__ApartmentGetDeviceIDByName);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetDeviceIDByName[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDeviceIDByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDeviceIDByName*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDeviceIDByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDeviceIDByName %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDeviceIDByName*)p = *(struct dss__ApartmentGetDeviceIDByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, struct dss__ApartmentGetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const struct dss__ApartmentGetDeviceIDByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const struct dss__ApartmentGetDeviceIDByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse);
	if (soap_out_dss__ApartmentGetDeviceIDByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDeviceIDByNameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByNameResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, struct dss__ApartmentGetDeviceIDByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDeviceIDByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByNameResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetDeviceIDByNameResponse *a, const char *type)
{
	short soap_flag_deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDeviceIDByNameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse, sizeof(struct dss__ApartmentGetDeviceIDByNameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDeviceIDByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "deviceID", &a->deviceID, "xsd:string"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDeviceIDByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse, 0, sizeof(struct dss__ApartmentGetDeviceIDByNameResponse), 0, soap_copy_dss__ApartmentGetDeviceIDByNameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetDeviceIDByNameResponse * SOAP_FMAC6 soap_new_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetDeviceIDByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, struct dss__ApartmentGetDeviceIDByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetDeviceIDByNameResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDeviceIDByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDeviceIDByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetDeviceIDByNameResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentGetDeviceIDByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetDeviceIDByNameResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDeviceIDByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDeviceIDByNameResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDeviceIDByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDeviceIDByNameResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDeviceIDByNameResponse*)p = *(struct dss__ApartmentGetDeviceIDByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDevices(struct soap *soap, struct dss__ApartmentGetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDevices(struct soap *soap, const struct dss__ApartmentGetDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDevices(struct soap *soap, const struct dss__ApartmentGetDevices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDevices);
	if (soap_out_dss__ApartmentGetDevices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDevices(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDevices *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDevices), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDevices * SOAP_FMAC4 soap_get_dss__ApartmentGetDevices(struct soap *soap, struct dss__ApartmentGetDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetDevices * SOAP_FMAC4 soap_in_dss__ApartmentGetDevices(struct soap *soap, const char *tag, struct dss__ApartmentGetDevices *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDevices, sizeof(struct dss__ApartmentGetDevices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDevices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDevices, 0, sizeof(struct dss__ApartmentGetDevices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetDevices * SOAP_FMAC6 soap_new_dss__ApartmentGetDevices(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetDevices(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetDevices(struct soap *soap, struct dss__ApartmentGetDevices *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetDevices * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDevices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDevices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetDevices;
		if (size)
			*size = sizeof(struct dss__ApartmentGetDevices);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetDevices[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDevices);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDevices*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDevices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDevices %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDevices*)p = *(struct dss__ApartmentGetDevices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentGetDevicesResponse(struct soap *soap, struct dss__ApartmentGetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentGetDevicesResponse(struct soap *soap, const struct dss__ApartmentGetDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentGetDevicesResponse(struct soap *soap, const struct dss__ApartmentGetDevicesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentGetDevicesResponse);
	if (soap_out_dss__ApartmentGetDevicesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentGetDevicesResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentGetDevicesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentGetDevicesResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentGetDevicesResponse * SOAP_FMAC4 soap_get_dss__ApartmentGetDevicesResponse(struct soap *soap, struct dss__ApartmentGetDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentGetDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentGetDevicesResponse * SOAP_FMAC4 soap_in_dss__ApartmentGetDevicesResponse(struct soap *soap, const char *tag, struct dss__ApartmentGetDevicesResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentGetDevicesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentGetDevicesResponse, sizeof(struct dss__ApartmentGetDevicesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentGetDevicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentGetDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentGetDevicesResponse, 0, sizeof(struct dss__ApartmentGetDevicesResponse), 0, soap_copy_dss__ApartmentGetDevicesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentGetDevicesResponse * SOAP_FMAC6 soap_new_dss__ApartmentGetDevicesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentGetDevicesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentGetDevicesResponse(struct soap *soap, struct dss__ApartmentGetDevicesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentGetDevicesResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentGetDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentGetDevicesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentGetDevicesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentGetDevicesResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentGetDevicesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentGetDevicesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentGetDevicesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentGetDevicesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentGetDevicesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentGetDevicesResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentGetDevicesResponse*)p = *(struct dss__ApartmentGetDevicesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__vectorTemplateOfstd__string(soap, &a->_names);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->_names);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNames *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames);
	if (soap_out_dss__ApartmentCreateSetFromDeviceNames(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceNames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "names", -1, &a->_names, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNames * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNames * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceNames *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceNames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames, sizeof(struct dss__ApartmentCreateSetFromDeviceNames), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, NULL, &a->_names, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceNames), 0, soap_copy_dss__ApartmentCreateSetFromDeviceNames);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCreateSetFromDeviceNames * SOAP_FMAC6 soap_new_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCreateSetFromDeviceNames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNames * SOAP_FMAC4 soap_instantiate_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceNames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceNames;
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceNames);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceNames[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceNames);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceNames*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceNames %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceNames*)p = *(struct dss__ApartmentCreateSetFromDeviceNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceNamesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse);
	if (soap_out_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceNamesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceNamesResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceNamesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse, sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse), 0, soap_copy_dss__ApartmentCreateSetFromDeviceNamesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCreateSetFromDeviceNamesResponse * SOAP_FMAC6 soap_new_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCreateSetFromDeviceNamesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceNamesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceNamesResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceNamesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceNamesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceNamesResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceNamesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceNamesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceNamesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceNamesResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceNamesResponse*)p = *(struct dss__ApartmentCreateSetFromDeviceNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_std__vectorTemplateOfstd__string(soap, &a->_ids);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &a->_ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs);
	if (soap_out_dss__ApartmentCreateSetFromDeviceIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ids", -1, &a->_ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDs * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDs * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceIDs *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceIDs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs, sizeof(struct dss__ApartmentCreateSetFromDeviceIDs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, NULL, &a->_ids, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceIDs), 0, soap_copy_dss__ApartmentCreateSetFromDeviceIDs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCreateSetFromDeviceIDs * SOAP_FMAC6 soap_new_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCreateSetFromDeviceIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDs * SOAP_FMAC4 soap_instantiate_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceIDs;
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceIDs);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceIDs %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceIDs*)p = *(struct dss__ApartmentCreateSetFromDeviceIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromDeviceIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse);
	if (soap_out_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromDeviceIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromDeviceIDsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromDeviceIDsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse, sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromDeviceIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse, 0, sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse), 0, soap_copy_dss__ApartmentCreateSetFromDeviceIDsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCreateSetFromDeviceIDsResponse * SOAP_FMAC6 soap_new_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCreateSetFromDeviceIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, struct dss__ApartmentCreateSetFromDeviceIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromDeviceIDsResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromDeviceIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromDeviceIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceIDsResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromDeviceIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromDeviceIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromDeviceIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromDeviceIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromDeviceIDsResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromDeviceIDsResponse*)p = *(struct dss__ApartmentCreateSetFromDeviceIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromGroup(struct soap *soap, struct dss__ApartmentCreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
	soap_default_string(soap, &a->_groupName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromGroup(struct soap *soap, const struct dss__ApartmentCreateSetFromGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_groupName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromGroup(struct soap *soap, const struct dss__ApartmentCreateSetFromGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromGroup);
	if (soap_out_dss__ApartmentCreateSetFromGroup(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromGroup(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroup), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->_groupName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroup * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromGroup(struct soap *soap, struct dss__ApartmentCreateSetFromGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroup * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromGroup(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromGroup *a, const char *type)
{
	short soap_flag__token = 1, soap_flag__groupName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroup, sizeof(struct dss__ApartmentCreateSetFromGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap_flag__groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_groupName, "xsd:string"))
				{	soap_flag__groupName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromGroup, 0, sizeof(struct dss__ApartmentCreateSetFromGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCreateSetFromGroup * SOAP_FMAC6 soap_new_dss__ApartmentCreateSetFromGroup(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCreateSetFromGroup(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCreateSetFromGroup(struct soap *soap, struct dss__ApartmentCreateSetFromGroup *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroup * SOAP_FMAC4 soap_instantiate_dss__ApartmentCreateSetFromGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromGroup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromGroup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromGroup;
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromGroup);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromGroup[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromGroup);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromGroup*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromGroup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromGroup %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromGroup*)p = *(struct dss__ApartmentCreateSetFromGroup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, struct dss__ApartmentCreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const struct dss__ApartmentCreateSetFromGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse);
	if (soap_out_dss__ApartmentCreateSetFromGroupResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const char *tag, int id, const struct dss__ApartmentCreateSetFromGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroupResponse * SOAP_FMAC4 soap_get_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, struct dss__ApartmentCreateSetFromGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__ApartmentCreateSetFromGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroupResponse * SOAP_FMAC4 soap_in_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, const char *tag, struct dss__ApartmentCreateSetFromGroupResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__ApartmentCreateSetFromGroupResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse, sizeof(struct dss__ApartmentCreateSetFromGroupResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_dss__ApartmentCreateSetFromGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__ApartmentCreateSetFromGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse, 0, sizeof(struct dss__ApartmentCreateSetFromGroupResponse), 0, soap_copy_dss__ApartmentCreateSetFromGroupResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__ApartmentCreateSetFromGroupResponse * SOAP_FMAC6 soap_new_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__ApartmentCreateSetFromGroupResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, struct dss__ApartmentCreateSetFromGroupResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__ApartmentCreateSetFromGroupResponse * SOAP_FMAC4 soap_instantiate_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__ApartmentCreateSetFromGroupResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__ApartmentCreateSetFromGroupResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromGroupResponse;
		if (size)
			*size = sizeof(struct dss__ApartmentCreateSetFromGroupResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__ApartmentCreateSetFromGroupResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__ApartmentCreateSetFromGroupResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__ApartmentCreateSetFromGroupResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__ApartmentCreateSetFromGroupResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__ApartmentCreateSetFromGroupResponse %p -> %p\n", q, p));
	*(struct dss__ApartmentCreateSetFromGroupResponse*)p = *(struct dss__ApartmentCreateSetFromGroupResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOff(struct soap *soap, struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOff(struct soap *soap, const struct dss__SignOff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOff(struct soap *soap, const struct dss__SignOff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOff);
	if (soap_out_dss__SignOff(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOff(struct soap *soap, const char *tag, int id, const struct dss__SignOff *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOff), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->_token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_get_dss__SignOff(struct soap *soap, struct dss__SignOff *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_in_dss__SignOff(struct soap *soap, const char *tag, struct dss__SignOff *a, const char *type)
{
	short soap_flag__token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOff, sizeof(struct dss__SignOff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_token, "xsd:int"))
				{	soap_flag__token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOff, 0, sizeof(struct dss__SignOff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SignOff * SOAP_FMAC6 soap_new_dss__SignOff(struct soap *soap, int n)
{	return soap_instantiate_dss__SignOff(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SignOff(struct soap *soap, struct dss__SignOff *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SignOff * SOAP_FMAC4 soap_instantiate_dss__SignOff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SignOff;
		if (size)
			*size = sizeof(struct dss__SignOff);
	}
	else
	{	cp->ptr = (void*)new struct dss__SignOff[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOff);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOff*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOff %p -> %p\n", q, p));
	*(struct dss__SignOff*)p = *(struct dss__SignOff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__SignOffResponse(struct soap *soap, const struct dss__SignOffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__SignOffResponse);
	if (soap_out_dss__SignOffResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__SignOffResponse(struct soap *soap, const char *tag, int id, const struct dss__SignOffResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__SignOffResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_get_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__SignOffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_in_dss__SignOffResponse(struct soap *soap, const char *tag, struct dss__SignOffResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__SignOffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__SignOffResponse, sizeof(struct dss__SignOffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__SignOffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__SignOffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__SignOffResponse, 0, sizeof(struct dss__SignOffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__SignOffResponse * SOAP_FMAC6 soap_new_dss__SignOffResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__SignOffResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__SignOffResponse(struct soap *soap, struct dss__SignOffResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__SignOffResponse * SOAP_FMAC4 soap_instantiate_dss__SignOffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__SignOffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__SignOffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__SignOffResponse;
		if (size)
			*size = sizeof(struct dss__SignOffResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__SignOffResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__SignOffResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__SignOffResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__SignOffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__SignOffResponse %p -> %p\n", q, p));
	*(struct dss__SignOffResponse*)p = *(struct dss__SignOffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__Authenticate(struct soap *soap, struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_userName);
	soap_default_string(soap, &a->_password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_userName);
	soap_serialize_string(soap, &a->_password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__Authenticate(struct soap *soap, const struct dss__Authenticate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__Authenticate);
	if (soap_out_dss__Authenticate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__Authenticate(struct soap *soap, const char *tag, int id, const struct dss__Authenticate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__Authenticate), type))
		return soap->error;
	if (soap_out_string(soap, "userName", -1, &a->_userName, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->_password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_get_dss__Authenticate(struct soap *soap, struct dss__Authenticate *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__Authenticate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_in_dss__Authenticate(struct soap *soap, const char *tag, struct dss__Authenticate *a, const char *type)
{
	short soap_flag__userName = 1, soap_flag__password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__Authenticate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__Authenticate, sizeof(struct dss__Authenticate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__Authenticate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__userName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_userName, "xsd:string"))
				{	soap_flag__userName--;
					continue;
				}
			if (soap_flag__password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_password, "xsd:string"))
				{	soap_flag__password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__Authenticate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__Authenticate, 0, sizeof(struct dss__Authenticate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__Authenticate * SOAP_FMAC6 soap_new_dss__Authenticate(struct soap *soap, int n)
{	return soap_instantiate_dss__Authenticate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__Authenticate(struct soap *soap, struct dss__Authenticate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__Authenticate * SOAP_FMAC4 soap_instantiate_dss__Authenticate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__Authenticate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__Authenticate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__Authenticate;
		if (size)
			*size = sizeof(struct dss__Authenticate);
	}
	else
	{	cp->ptr = (void*)new struct dss__Authenticate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__Authenticate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__Authenticate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__Authenticate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__Authenticate %p -> %p\n", q, p));
	*(struct dss__Authenticate*)p = *(struct dss__Authenticate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dss__AuthenticateResponse(struct soap *soap, const struct dss__AuthenticateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_dss__AuthenticateResponse);
	if (soap_out_dss__AuthenticateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dss__AuthenticateResponse(struct soap *soap, const char *tag, int id, const struct dss__AuthenticateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_dss__AuthenticateResponse), type))
		return soap->error;
	if (soap_out_int(soap, "token", -1, &a->token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_get_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_dss__AuthenticateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_in_dss__AuthenticateResponse(struct soap *soap, const char *tag, struct dss__AuthenticateResponse *a, const char *type)
{
	short soap_flag_token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct dss__AuthenticateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_dss__AuthenticateResponse, sizeof(struct dss__AuthenticateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_dss__AuthenticateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "token", &a->token, "xsd:int"))
				{	soap_flag_token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct dss__AuthenticateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_dss__AuthenticateResponse, 0, sizeof(struct dss__AuthenticateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct dss__AuthenticateResponse * SOAP_FMAC6 soap_new_dss__AuthenticateResponse(struct soap *soap, int n)
{	return soap_instantiate_dss__AuthenticateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_dss__AuthenticateResponse(struct soap *soap, struct dss__AuthenticateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct dss__AuthenticateResponse * SOAP_FMAC4 soap_instantiate_dss__AuthenticateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_dss__AuthenticateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_dss__AuthenticateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct dss__AuthenticateResponse;
		if (size)
			*size = sizeof(struct dss__AuthenticateResponse);
	}
	else
	{	cp->ptr = (void*)new struct dss__AuthenticateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct dss__AuthenticateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct dss__AuthenticateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_dss__AuthenticateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct dss__AuthenticateResponse %p -> %p\n", q, p));
	*(struct dss__AuthenticateResponse*)p = *(struct dss__AuthenticateResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdss__Event(struct soap *soap, std::vector<dss__Event >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdss__Event(struct soap *soap, const std::vector<dss__Event >*a)
{
	for (std::vector<dss__Event >::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdss__Event(struct soap *soap, const char *tag, int id, const std::vector<dss__Event >*a, const char *type)
{
	for (std::vector<dss__Event >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<dss__Event >* SOAP_FMAC4 soap_in_std__vectorTemplateOfdss__Event(struct soap *soap, const char *tag, std::vector<dss__Event >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfdss__Event(soap, -1)))
		return NULL;
	dss__Event n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n.soap_default(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_dss__Event, SOAP_TYPE_std__vectorTemplateOfdss__Event, sizeof(dss__Event), 0))
				break;
			if (!soap_in_dss__Event(soap, tag, NULL, "dss:Event"))
				break;
		}
		else
		{
			if (!soap_in_dss__Event(soap, tag, &n, "dss:Event"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<dss__Event > * SOAP_FMAC6 soap_new_std__vectorTemplateOfdss__Event(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfdss__Event(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfdss__Event(struct soap *soap, std::vector<dss__Event >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<dss__Event > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfdss__Event(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfdss__Event(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfdss__Event, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<dss__Event >;
		if (size)
			*size = sizeof(std::vector<dss__Event >);
	}
	else
	{	cp->ptr = (void*)new std::vector<dss__Event >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<dss__Event >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<dss__Event >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfdss__Event(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<dss__Event > %p -> %p\n", q, p));
	*(std::vector<dss__Event >*)p = *(std::vector<dss__Event >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfint(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<int >;
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

/* End of soapC.cpp */
